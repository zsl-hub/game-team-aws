{
  "version": 3,
  "sources": ["../../node_modules/ably/src/platform/web/index.ts", "../../node_modules/ably/src/common/platform.ts", "../../node_modules/ably/src/common/lib/util/logger.ts", "../../node_modules/ably/src/common/lib/util/utils.ts", "../../node_modules/ably/src/common/lib/types/errorinfo.ts", "../../node_modules/ably/package.json", "../../node_modules/ably/src/common/lib/util/defaults.ts", "../../node_modules/ably/src/common/lib/util/multicaster.ts", "../../node_modules/ably/src/common/constants/HttpMethods.ts", "../../node_modules/ably/src/common/constants/HttpStatusCodes.ts", "../../node_modules/ably/src/common/lib/client/auth.ts", "../../node_modules/ably/src/common/types/http.ts", "../../node_modules/ably/src/common/lib/client/baseclient.ts", "../../node_modules/ably/src/common/lib/types/devicedetails.ts", "../../node_modules/ably/src/common/lib/client/resource.ts", "../../node_modules/ably/src/common/lib/client/paginatedresource.ts", "../../node_modules/ably/src/common/lib/types/pushchannelsubscription.ts", "../../node_modules/ably/src/common/lib/client/push.ts", "../../node_modules/ably/src/common/lib/types/message.ts", "../../node_modules/ably/src/common/lib/types/presencemessage.ts", "../../node_modules/ably/src/common/lib/client/restpresence.ts", "../../node_modules/ably/src/common/lib/client/restchannel.ts", "../../node_modules/ably/src/common/lib/types/stats.ts", "../../node_modules/ably/src/common/lib/client/restchannelmixin.ts", "../../node_modules/ably/src/common/lib/client/restpresencemixin.ts", "../../node_modules/ably/src/common/lib/client/rest.ts", "../../node_modules/ably/src/common/lib/client/baserest.ts", "../../node_modules/ably/src/common/lib/client/modularplugins.ts", "../../node_modules/ably/src/common/lib/types/defaultmessage.ts", "../../node_modules/ably/src/common/lib/types/defaultpresencemessage.ts", "../../node_modules/ably/src/common/lib/client/defaultrest.ts", "../../node_modules/ably/src/common/lib/util/eventemitter.ts", "../../node_modules/ably/src/common/lib/types/protocolmessage.ts", "../../node_modules/ably/src/common/lib/transport/messagequeue.ts", "../../node_modules/ably/src/common/lib/transport/protocol.ts", "../../node_modules/ably/src/common/lib/client/connectionstatechange.ts", "../../node_modules/ably/src/common/lib/transport/connectionerrors.ts", "../../node_modules/ably/src/common/lib/transport/transport.ts", "../../node_modules/ably/src/common/constants/TransportName.ts", "../../node_modules/ably/src/common/lib/transport/connectionmanager.ts", "../../node_modules/ably/src/common/lib/client/connection.ts", "../../node_modules/ably/src/common/lib/client/channelstatechange.ts", "../../node_modules/ably/src/common/lib/client/realtimechannel.ts", "../../node_modules/ably/src/common/lib/client/baserealtime.ts", "../../node_modules/ably/src/common/lib/client/realtimepresence.ts", "../../node_modules/ably/src/common/lib/transport/websockettransport.ts", "../../node_modules/ably/src/common/lib/client/filteredsubscriptions.ts", "../../node_modules/ably/src/common/lib/client/defaultrealtime.ts", "../../node_modules/ably/src/platform/web/lib/util/hmac-sha256.ts", "../../node_modules/ably/src/platform/web/lib/util/bufferutils.ts", "../../node_modules/ably/src/platform/web/lib/util/crypto.ts", "../../node_modules/ably/src/common/constants/XHRStates.ts", "../../node_modules/ably/src/platform/web/lib/http/http.ts", "../../node_modules/ably/src/platform/web/config.ts", "../../node_modules/ably/src/common/lib/transport/comettransport.ts", "../../node_modules/ably/src/platform/web/lib/http/request/xhrrequest.ts", "../../node_modules/ably/src/platform/web/lib/transport/xhrpollingtransport.ts", "../../node_modules/ably/src/platform/web/lib/transport/index.ts", "../../node_modules/ably/src/platform/web/lib/util/webstorage.ts", "../../node_modules/ably/src/platform/web/lib/util/defaults.ts", "../../node_modules/ably/src/platform/web/lib/util/msgpack.ts", "../../node_modules/ably/src/platform/web/lib/http/request/fetchrequest.ts", "../../node_modules/ably/src/platform/web/lib/http/request/index.ts"],
  "sourcesContent": ["// Common\r\nimport { DefaultRest } from '../../common/lib/client/defaultrest';\r\nimport { DefaultRealtime } from '../../common/lib/client/defaultrealtime';\r\nimport Platform from '../../common/platform';\r\nimport ErrorInfo from '../../common/lib/types/errorinfo';\r\nimport { fromDeserializedIncludingDependencies as protocolMessageFromDeserialized } from '../../common/lib/types/protocolmessage';\r\n\r\n// Platform Specific\r\nimport BufferUtils from './lib/util/bufferutils';\r\n// @ts-ignore\r\nimport { createCryptoClass } from './lib/util/crypto';\r\nimport Http from './lib/http/http';\r\nimport Config from './config';\r\n// @ts-ignore\r\nimport Transports from './lib/transport';\r\nimport Logger from '../../common/lib/util/logger';\r\nimport { getDefaults } from '../../common/lib/util/defaults';\r\nimport WebStorage from './lib/util/webstorage';\r\nimport PlatformDefaults from './lib/util/defaults';\r\nimport msgpack from './lib/util/msgpack';\r\nimport { defaultBundledRequestImplementations } from './lib/http/request';\r\n\r\nconst Crypto = createCryptoClass(Config, BufferUtils);\r\n\r\nPlatform.Crypto = Crypto;\r\nPlatform.BufferUtils = BufferUtils;\r\nPlatform.Http = Http;\r\nPlatform.Config = Config;\r\nPlatform.Transports = Transports;\r\nPlatform.WebStorage = WebStorage;\r\n\r\nfor (const clientClass of [DefaultRest, DefaultRealtime]) {\r\n  clientClass.Crypto = Crypto;\r\n  clientClass._MsgPack = msgpack;\r\n}\r\n\r\nHttp.bundledRequestImplementations = defaultBundledRequestImplementations;\r\n\r\nLogger.initLogHandlers();\r\n\r\nPlatform.Defaults = getDefaults(PlatformDefaults);\r\n\r\nif (Platform.Config.agent) {\r\n  // @ts-ignore\r\n  Platform.Defaults.agent += ' ' + Platform.Config.agent;\r\n}\r\n\r\nexport { DefaultRest as Rest, DefaultRealtime as Realtime, msgpack, protocolMessageFromDeserialized, ErrorInfo };\r\n\r\nexport default {\r\n  ErrorInfo,\r\n  Rest: DefaultRest,\r\n  Realtime: DefaultRealtime,\r\n  msgpack,\r\n};\r\n", "import { IPlatformConfig } from './types/IPlatformConfig';\r\nimport { IPlatformHttpStatic } from './types/http';\r\nimport IDefaults from './types/IDefaults';\r\nimport IWebStorage from './types/IWebStorage';\r\nimport IBufferUtils from './types/IBufferUtils';\r\nimport * as WebBufferUtils from '../platform/web/lib/util/bufferutils';\r\nimport * as NodeBufferUtils from '../platform/nodejs/lib/util/bufferutils';\r\nimport { IUntypedCryptoStatic } from '../common/types/ICryptoStatic';\r\nimport TransportName from './constants/TransportName';\r\nimport { TransportCtor } from './lib/transport/transport';\r\n\r\nexport type Bufferlike = WebBufferUtils.Bufferlike | NodeBufferUtils.Bufferlike;\r\ntype BufferUtilsOutput = WebBufferUtils.Output | NodeBufferUtils.Output;\r\ntype ToBufferOutput = WebBufferUtils.ToBufferOutput | NodeBufferUtils.ToBufferOutput;\r\n\r\nexport type TransportImplementations = Partial<Record<TransportName, TransportCtor>>;\r\n\r\nexport default class Platform {\r\n  static Config: IPlatformConfig;\r\n  /*\r\n     What we actually _want_ is for Platform to be a generic class\r\n     parameterised by Bufferlike etc, but that requires far-reaching changes to\r\n     components that make use of Platform. So instead we have to advertise a\r\n     BufferUtils object that accepts a broader range of data types than it\r\n     can in reality handle.\r\n   */\r\n  static BufferUtils: IBufferUtils<Bufferlike, BufferUtilsOutput, ToBufferOutput>;\r\n  /*\r\n     We\u2019d like this to be ICryptoStatic with the correct generic arguments,\r\n     but Platform doesn\u2019t currently allow that, as described in the BufferUtils\r\n     comment above.\r\n   */\r\n  static Crypto: IUntypedCryptoStatic | null;\r\n  static Http: IPlatformHttpStatic;\r\n  static Transports: {\r\n    order: TransportName[];\r\n    // Transport implementations that always come with this platform\r\n    bundledImplementations: TransportImplementations;\r\n  };\r\n  static Defaults: IDefaults;\r\n  static WebStorage: IWebStorage | null;\r\n}\r\n", "import Platform from 'common/platform';\r\n\r\nexport type LoggerOptions = {\r\n  handler: LoggerFunction;\r\n  level: LogLevels;\r\n};\r\ntype LoggerFunction = (...args: string[]) => void;\r\n\r\n// Workaround for salesforce lightning locker compatibility\r\n// This is a shorthand version of Utils.getGlobalObject (which we can't use here without creating a circular import)\r\nlet globalObject = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : self;\r\n\r\nenum LogLevels {\r\n  None = 0,\r\n  Error = 1,\r\n  Major = 2,\r\n  Minor = 3,\r\n  Micro = 4,\r\n}\r\n\r\nfunction pad(timeSegment: number, three?: number) {\r\n  return `${timeSegment}`.padStart(three ? 3 : 2, '0');\r\n}\r\n\r\nfunction getHandler(logger: Function): Function {\r\n  return Platform.Config.logTimestamps\r\n    ? function (msg: unknown) {\r\n        const time = new Date();\r\n        logger(\r\n          pad(time.getHours()) +\r\n            ':' +\r\n            pad(time.getMinutes()) +\r\n            ':' +\r\n            pad(time.getSeconds()) +\r\n            '.' +\r\n            pad(time.getMilliseconds(), 1) +\r\n            ' ' +\r\n            msg,\r\n        );\r\n      }\r\n    : logger;\r\n}\r\n\r\nconst getDefaultLoggers = (): [Function, Function] => {\r\n  let consoleLogger;\r\n  let errorLogger;\r\n\r\n  // we expect ably-js to be run in environments which have `console` object available with its `log` function\r\n  if (typeof globalObject?.console?.log === 'function') {\r\n    consoleLogger = function (...args: unknown[]) {\r\n      console.log.apply(console, args);\r\n    };\r\n\r\n    errorLogger = console.warn\r\n      ? function (...args: unknown[]) {\r\n          console.warn.apply(console, args);\r\n        }\r\n      : consoleLogger;\r\n  } else {\r\n    // otherwise we should fallback to noop for log functions\r\n    consoleLogger = errorLogger = function () {};\r\n  }\r\n\r\n  return [consoleLogger, errorLogger].map(getHandler) as [Function, Function];\r\n};\r\n\r\nclass Logger {\r\n  private static logLevel: LogLevels = LogLevels.Error; // default logLevel\r\n  private static logHandler: Function;\r\n  private static logErrorHandler: Function;\r\n\r\n  // public constants\r\n  static readonly LOG_NONE: LogLevels = LogLevels.None;\r\n  static readonly LOG_ERROR: LogLevels = LogLevels.Error;\r\n  static readonly LOG_MAJOR: LogLevels = LogLevels.Major;\r\n  static readonly LOG_MINOR: LogLevels = LogLevels.Minor;\r\n  static readonly LOG_MICRO: LogLevels = LogLevels.Micro;\r\n  // aliases\r\n  static readonly LOG_DEFAULT: LogLevels = LogLevels.Error;\r\n  static readonly LOG_DEBUG: LogLevels = LogLevels.Micro;\r\n\r\n  constructor() {\r\n    Logger.logLevel = Logger.LOG_DEFAULT;\r\n  }\r\n\r\n  static initLogHandlers() {\r\n    const [logHandler, logErrorHandler] = getDefaultLoggers();\r\n    this.logHandler = logHandler;\r\n    this.logErrorHandler = logErrorHandler;\r\n  }\r\n\r\n  /* public static functions */\r\n  /**\r\n   * In the modular variant of the SDK, the `stripLogs` esbuild plugin strips out all calls to this method (when invoked as `Logger.logAction(...)`) except when called with level `Logger.LOG_ERROR`. If you wish for a log statement to never be stripped, use the {@link logActionNoStrip} method instead.\r\n   *\r\n   * The aforementioned plugin expects `level` to be an expression of the form `Logger.LOG_*`; that is, you can\u2019t dynamically specify the log level.\r\n   */\r\n  static logAction = (level: LogLevels, action: string, message?: string) => {\r\n    this.logActionNoStrip(level, action, message);\r\n  };\r\n\r\n  /**\r\n   * Calls to this method are never stripped by the `stripLogs` esbuild plugin. Use it for log statements that you wish to always be included in the modular variant of the SDK.\r\n   */\r\n  static logActionNoStrip(level: LogLevels, action: string, message?: string) {\r\n    if (Logger.shouldLog(level)) {\r\n      (level === LogLevels.Error ? Logger.logErrorHandler : Logger.logHandler)('Ably: ' + action + ': ' + message);\r\n    }\r\n  }\r\n\r\n  static deprecated = (description: string, msg: string) => {\r\n    Logger.deprecationWarning(`${description} is deprecated and will be removed in a future version. ${msg}`);\r\n  };\r\n\r\n  static renamedClientOption(oldName: string, newName: string) {\r\n    Logger.deprecationWarning(\r\n      `The \\`${oldName}\\` client option has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`,\r\n    );\r\n  }\r\n\r\n  static renamedMethod(className: string, oldName: string, newName: string) {\r\n    Logger.deprecationWarning(\r\n      `\\`${className}\\`\u2019s \\`${oldName}\\` method has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`,\r\n    );\r\n  }\r\n\r\n  static deprecationWarning(message: string) {\r\n    if (Logger.shouldLog(LogLevels.Error)) {\r\n      Logger.logErrorHandler(`Ably: Deprecation warning - ${message}`);\r\n    }\r\n  }\r\n\r\n  /* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent\r\n\t   the object being serialised if the log level will not output the message */\r\n  static shouldLog = (level: LogLevels) => {\r\n    return level <= Logger.logLevel;\r\n  };\r\n\r\n  static setLog = (level: LogLevels | undefined, handler: Function | undefined) => {\r\n    if (level !== undefined) Logger.logLevel = level;\r\n    if (handler !== undefined) Logger.logHandler = Logger.logErrorHandler = handler;\r\n  };\r\n}\r\n\r\nexport default Logger;\r\n", "import Platform from 'common/platform';\nimport ErrorInfo, { PartialErrorInfo } from 'common/lib/types/errorinfo';\nimport { ModularPlugins } from '../client/modularplugins';\nimport { MsgPack } from 'common/types/msgpack';\n\nfunction randomPosn(arrOrStr: Array<unknown> | string) {\n  return Math.floor(Math.random() * arrOrStr.length);\n}\n\n/**\n * Add a set of properties to a target object\n *\n * @param target the target object\n * @param args objects, which enumerable properties are added to target, by reference only\n * @returns target object with added properties\n */\nexport function mixin(\n  target: Record<string, unknown>,\n  ...args: Array<object | undefined | null>\n): Record<string, unknown> {\n  for (let i = 0; i < args.length; i++) {\n    const source = args[i];\n    if (!source) {\n      break;\n    }\n\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = (source as Record<string, unknown>)[key];\n      }\n    }\n  }\n  return target;\n}\n\n/**\n * Creates a copy of enumerable properties of the source object\n *\n * @param src object to copy\n * @returns copy of src\n */\nexport function copy<T = Record<string, unknown>>(src: T | Record<string, unknown> | null | undefined): T {\n  return mixin({}, src as Record<string, unknown>) as T;\n}\n\n/*\n * Ensures that an Array object is always returned\n * returning the original Array of obj is an Array\n * else wrapping the obj in a single element Array\n */\nexport function ensureArray(obj: Record<string, unknown>): unknown[] {\n  if (isNil(obj)) {\n    return [];\n  }\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\n\nexport function isObject(ob: unknown): ob is Record<string, unknown> {\n  return Object.prototype.toString.call(ob) == '[object Object]';\n}\n\n/*\n * Determine whether or not an object contains\n * any enumerable properties.\n * ob: the object\n */\nexport function isEmpty(ob: Record<string, unknown> | unknown[]): boolean {\n  for (const prop in ob) return false;\n  return true;\n}\n\n/**\n * Checks if `value` is `null` or `undefined`.\n *\n * Source: https://github.com/lodash/lodash/blob/main/src/isNil.ts\n */\nexport function isNil(arg: unknown): arg is null | undefined {\n  return arg == null;\n}\n\n/*\n * Perform a simple shallow clone of an object.\n * Result is an object irrespective of whether\n * the input is an object or array. All\n * enumerable properties are copied.\n * ob: the object\n */\nexport function shallowClone(ob: Record<string, unknown>): Record<string, unknown> {\n  const result = new Object() as Record<string, unknown>;\n  for (const prop in ob) result[prop] = ob[prop];\n  return result;\n}\n\n/*\n * Clone an object by creating a new object with the\n * given object as its prototype. Optionally\n * a set of additional own properties can be\n * supplied to be added to the newly created clone.\n * ob:            the object to be cloned\n * ownProperties: optional object with additional\n *                properties to add\n */\nexport function prototypicalClone(\n  ob: Record<string, unknown>,\n  ownProperties: Record<string, unknown>,\n): Record<string, unknown> {\n  class F {}\n  F.prototype = ob;\n  const result = new F() as Record<string, unknown>;\n  if (ownProperties) mixin(result, ownProperties);\n  return result;\n}\n\n/*\n * Declare a constructor to represent a subclass\n * of another constructor\n * If platform has a built-in version we use that from Platform, else we\n * define here (so can make use of other Utils fns)\n * See node.js util.inherits\n */\nexport const inherits = function (ctor: any, superCtor: Function) {\n  if (Platform.Config.inherits) {\n    Platform.Config.inherits(ctor, superCtor);\n    return;\n  }\n  ctor.super_ = superCtor;\n  ctor.prototype = prototypicalClone(superCtor.prototype, { constructor: ctor });\n};\n\n/*\n * Determine whether or not an object has an enumerable\n * property whose value equals a given value.\n * ob:  the object\n * val: the value to find\n */\nexport function containsValue(ob: Record<string, unknown>, val: unknown): boolean {\n  for (const i in ob) {\n    if (ob[i] == val) return true;\n  }\n  return false;\n}\n\nexport function intersect<K extends string, T>(arr: Array<K>, ob: K[] | Partial<Record<K, T>>): K[] {\n  return Array.isArray(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);\n}\n\nexport function arrIntersect<T>(arr1: Array<T>, arr2: Array<T>): Array<T> {\n  const result = [];\n  for (let i = 0; i < arr1.length; i++) {\n    const member = arr1[i];\n    if (arr2.indexOf(member) != -1) result.push(member);\n  }\n  return result;\n}\n\nexport function arrIntersectOb<K extends string>(arr: Array<K>, ob: Partial<Record<K, unknown>>): K[] {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const member = arr[i];\n    if (member in ob) result.push(member);\n  }\n  return result;\n}\n\nexport function arrSubtract<T>(arr1: Array<T>, arr2: Array<T>): Array<T> {\n  const result = [];\n  for (let i = 0; i < arr1.length; i++) {\n    const element = arr1[i];\n    if (arr2.indexOf(element) == -1) result.push(element);\n  }\n  return result;\n}\n\nexport function arrDeleteValue<T>(arr: Array<T>, val: T): boolean {\n  const idx = arr.indexOf(val);\n  const res = idx != -1;\n  if (res) arr.splice(idx, 1);\n  return res;\n}\n\nexport function arrWithoutValue<T>(arr: Array<T>, val: T): Array<T> {\n  const newArr = arr.slice();\n  arrDeleteValue(newArr, val);\n  return newArr;\n}\n\n/*\n * Construct an array of the keys of the enumerable\n * properties of a given object, optionally limited\n * to only the own properties.\n * ob:      the object\n * ownOnly: boolean, get own properties only\n */\nexport function keysArray(ob: Record<string, unknown>, ownOnly?: boolean): Array<string> {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop)) continue;\n    result.push(prop);\n  }\n  return result;\n}\n\n/*\n * Construct an array of the values of the enumerable\n * properties of a given object, optionally limited\n * to only the own properties.\n * ob:      the object\n * ownOnly: boolean, get own properties only\n */\nexport function valuesArray<T>(ob: Record<string, T>, ownOnly?: boolean): T[] {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop)) continue;\n    result.push(ob[prop]);\n  }\n  return result;\n}\n\nexport function forInOwnNonNullProperties(ob: Record<string, unknown>, fn: (prop: string) => void): void {\n  for (const prop in ob) {\n    if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {\n      fn(prop);\n    }\n  }\n}\n\nexport function allSame(arr: Array<Record<string, unknown>>, prop: string): boolean {\n  if (arr.length === 0) {\n    return true;\n  }\n  const first = arr[0][prop];\n  return arr.every(function (item) {\n    return item[prop] === first;\n  });\n}\n\nexport enum Format {\n  msgpack = 'msgpack',\n  json = 'json',\n}\n\nexport function arrPopRandomElement<T>(arr: Array<T>): T {\n  return arr.splice(randomPosn(arr), 1)[0];\n}\n\nexport function toQueryString(params?: Record<string, string> | null): string {\n  const parts = [];\n  if (params) {\n    for (const key in params) parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));\n  }\n  return parts.length ? '?' + parts.join('&') : '';\n}\n\nexport function parseQueryString(query: string): Record<string, string> {\n  let match;\n  const search = /([^?&=]+)=?([^&]*)/g;\n  const result: Record<string, string> = {};\n\n  while ((match = search.exec(query))) result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);\n\n  return result;\n}\n\nexport function isErrorInfoOrPartialErrorInfo(err: unknown): err is ErrorInfo | PartialErrorInfo {\n  return typeof err == 'object' && err !== null && (err instanceof ErrorInfo || err instanceof PartialErrorInfo);\n}\n\nexport function inspectError(err: unknown): string {\n  if (\n    err instanceof Error ||\n    (err as ErrorInfo)?.constructor?.name === 'ErrorInfo' ||\n    (err as PartialErrorInfo)?.constructor?.name === 'PartialErrorInfo'\n  )\n    return (err as Error).toString();\n  return Platform.Config.inspect(err);\n}\n\nexport function inspectBody(body: unknown): string {\n  if (Platform.BufferUtils.isBuffer(body)) {\n    return (body as any).toString();\n  } else if (typeof body === 'string') {\n    return body;\n  } else {\n    return Platform.Config.inspect(body);\n  }\n}\n\n/* Data is assumed to be either a string or a buffer. */\nexport function dataSizeBytes(data: string | Buffer): number {\n  if (Platform.BufferUtils.isBuffer(data)) {\n    return Platform.BufferUtils.byteLength(data);\n  }\n  if (typeof data === 'string') {\n    return Platform.Config.stringByteSize(data);\n  }\n  throw new Error('Expected input of Utils.dataSizeBytes to be a buffer or string, but was: ' + typeof data);\n}\n\nexport function cheapRandStr(): string {\n  return String(Math.random()).substr(2);\n}\n\n/* Takes param the minimum number of bytes of entropy the string must\n * include, not the length of the string. String length produced is not\n * guaranteed. */\nexport const randomString = async (numBytes: number): Promise<string> => {\n  const buffer = await Platform.Config.getRandomArrayBuffer(numBytes);\n  return Platform.BufferUtils.base64Encode(buffer);\n};\n\n/* Pick n elements at random without replacement from an array */\nexport function arrChooseN<T>(arr: Array<T>, n: number): Array<T> {\n  const numItems = Math.min(n, arr.length),\n    mutableArr = arr.slice(),\n    result: Array<T> = [];\n  for (let i = 0; i < numItems; i++) {\n    result.push(arrPopRandomElement(mutableArr));\n  }\n  return result;\n}\n\n/**\n * Uses a callback to communicate the result of a `Promise`. The first argument passed to the callback will be either an error (when the promise is rejected) or `null` (when the promise is fulfilled). In the case where the promise is fulfilled, the resulting value will be passed to the callback as a second argument.\n */\nexport function whenPromiseSettles<T, E = unknown>(\n  promise: Promise<T>,\n  callback?: (err: E | null, result?: T) => void,\n) {\n  promise\n    .then((result) => {\n      callback?.(null, result);\n    })\n    .catch((err: unknown) => {\n      // We make no guarantees about the type of the error that gets passed to the callback. Issue https://github.com/ably/ably-js/issues/1617 will think about how to correctly handle error types.\n      callback?.(err as E);\n    });\n}\n\nexport function decodeBody<T>(body: unknown, MsgPack: MsgPack | null, format?: Format | null): T {\n  if (format == 'msgpack') {\n    if (!MsgPack) {\n      throwMissingPluginError('MsgPack');\n    }\n    return MsgPack.decode(body as Buffer);\n  }\n\n  return JSON.parse(String(body));\n}\n\nexport function encodeBody(body: unknown, MsgPack: MsgPack | null, format?: Format): string | Buffer {\n  if (format == 'msgpack') {\n    if (!MsgPack) {\n      throwMissingPluginError('MsgPack');\n    }\n    return MsgPack.encode(body, true) as Buffer;\n  }\n\n  return JSON.stringify(body);\n}\n\nexport function allToLowerCase(arr: Array<string>): Array<string> {\n  return arr.map(function (element) {\n    return element && element.toLowerCase();\n  });\n}\n\nexport function allToUpperCase(arr: Array<string>): Array<string> {\n  return arr.map(function (element) {\n    return element && element.toUpperCase();\n  });\n}\n\nexport function getBackoffCoefficient(count: number) {\n  return Math.min((count + 2) / 3, 2);\n}\n\nexport function getJitterCoefficient() {\n  return 1 - Math.random() * 0.2;\n}\n\n/**\n *\n * @param initialTimeout initial timeout value\n * @param retryAttempt integer indicating retryAttempt\n * @returns RetryTimeout value for given timeout and retryAttempt.\n * If x is the value generated then,\n * Upper bound = min((retryAttempt + 2) / 3, 2) * initialTimeout,\n * Lower bound = 0.8 * Upper bound,\n * Lower bound < x < Upper bound\n */\nexport function getRetryTime(initialTimeout: number, retryAttempt: number) {\n  return initialTimeout * getBackoffCoefficient(retryAttempt) * getJitterCoefficient();\n}\n\nexport function getGlobalObject() {\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  return self;\n}\n\nexport function shallowEquals(source: Record<string, unknown>, target: Record<string, unknown>) {\n  return (\n    Object.keys(source).every((key) => source[key] === target[key]) &&\n    Object.keys(target).every((key) => target[key] === source[key])\n  );\n}\n\nexport function matchDerivedChannel(name: string) {\n  /**\n   * This regex check is to retain existing channel params if any e.g [?rewind=1]foo to\n   * [filter=xyz?rewind=1]foo. This is to keep channel compatibility around use of\n   * channel params that work with derived channels.\n   *\n   * This eslint unsafe regex warning is triggered because the RegExp uses nested quantifiers,\n   * but it does not create any situation where the regex engine has to\n   * explore a large number of possible matches so it\u2019s safe to ignore\n   */\n  const regex = /^(\\[([^?]*)(?:(.*))\\])?(.+)$/; // eslint-disable-line\n  const match = name.match(regex);\n  if (!match || !match.length || match.length < 5) {\n    throw new ErrorInfo('regex match failed', 400, 40010);\n  }\n  // Fail if there is already a channel qualifier, eg [meta]foo should fail instead of just overriding with [filter=xyz]foo\n  if (match![2]) {\n    throw new ErrorInfo(`cannot use a derived option with a ${match[2]} channel`, 400, 40010);\n  }\n  // Return match values to be added to derive channel quantifier.\n  return {\n    qualifierParam: match[3] || '',\n    channelName: match[4],\n  };\n}\n\nexport function toBase64(str: string) {\n  const bufferUtils = Platform.BufferUtils;\n  const textBuffer = bufferUtils.utf8Encode(str);\n  return bufferUtils.base64Encode(textBuffer);\n}\n\nexport function arrEquals(a: any[], b: any[]) {\n  return (\n    a.length === b.length &&\n    a.every(function (val, i) {\n      return val === b[i];\n    })\n  );\n}\n\nexport function createMissingPluginError(pluginName: keyof ModularPlugins): ErrorInfo {\n  return new ErrorInfo(`${pluginName} plugin not provided`, 40019, 400);\n}\n\nexport function throwMissingPluginError(pluginName: keyof ModularPlugins): never {\n  throw createMissingPluginError(pluginName);\n}\n", "import Platform from 'common/platform';\r\nimport * as Utils from '../util/utils';\r\nimport * as API from '../../../../ably';\r\n\r\nexport interface IPartialErrorInfo extends Error {\r\n  code: number | null;\r\n  statusCode?: number;\r\n  cause?: string | Error | ErrorInfo;\r\n  href?: string;\r\n}\r\n\r\nfunction toString(err: ErrorInfo | PartialErrorInfo) {\r\n  let result = '[' + err.constructor.name;\r\n  if (err.message) result += ': ' + err.message;\r\n  if (err.statusCode) result += '; statusCode=' + err.statusCode;\r\n  if (err.code) result += '; code=' + err.code;\r\n  if (err.cause) result += '; cause=' + Utils.inspectError(err.cause);\r\n  if (err.href && !(err.message && err.message.indexOf('help.ably.io') > -1)) result += '; see ' + err.href + ' ';\r\n  result += ']';\r\n  return result;\r\n}\r\n\r\nexport interface IConvertibleToErrorInfo {\r\n  message: string;\r\n  code: number;\r\n  statusCode: number;\r\n}\r\n\r\nexport default class ErrorInfo extends Error implements IPartialErrorInfo, API.ErrorInfo {\r\n  code: number;\r\n  statusCode: number;\r\n  cause?: string | Error | ErrorInfo;\r\n  href?: string;\r\n\r\n  constructor(message: string, code: number, statusCode: number, cause?: string | Error | ErrorInfo) {\r\n    super(message);\r\n    if (typeof Object.setPrototypeOf !== 'undefined') {\r\n      Object.setPrototypeOf(this, ErrorInfo.prototype);\r\n    }\r\n    this.code = code;\r\n    this.statusCode = statusCode;\r\n    this.cause = cause;\r\n  }\r\n\r\n  toString(): string {\r\n    return toString(this);\r\n  }\r\n\r\n  static fromValues(values: IConvertibleToErrorInfo): ErrorInfo {\r\n    const { message, code, statusCode } = values;\r\n    if (typeof message !== 'string' || typeof code !== 'number' || typeof statusCode !== 'number') {\r\n      throw new Error('ErrorInfo.fromValues(): invalid values: ' + Platform.Config.inspect(values));\r\n    }\r\n    const result = Object.assign(new ErrorInfo(message, code, statusCode), values);\r\n    if (result.code && !result.href) {\r\n      result.href = 'https://help.ably.io/error/' + result.code;\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\nexport class PartialErrorInfo extends Error implements IPartialErrorInfo {\r\n  code: number | null;\r\n  statusCode?: number;\r\n  cause?: string | Error | ErrorInfo;\r\n  href?: string;\r\n\r\n  constructor(message: string, code: number | null, statusCode?: number, cause?: string | Error | ErrorInfo) {\r\n    super(message);\r\n    if (typeof Object.setPrototypeOf !== 'undefined') {\r\n      Object.setPrototypeOf(this, PartialErrorInfo.prototype);\r\n    }\r\n    this.code = code;\r\n    this.statusCode = statusCode;\r\n    this.cause = cause;\r\n  }\r\n\r\n  toString(): string {\r\n    return toString(this);\r\n  }\r\n}\r\n", "{\r\n  \"name\": \"ably\",\r\n  \"description\": \"Realtime client library for Ably, the realtime messaging service\",\r\n  \"version\": \"2.0.4\",\r\n  \"license\": \"Apache-2.0\",\r\n  \"bugs\": {\r\n    \"url\": \"https://github.com/ably/ably-js/issues\",\r\n    \"email\": \"support@ably.com\"\r\n  },\r\n  \"react-native\": \"./build/ably-reactnative.js\",\r\n  \"exports\": {\r\n    \".\": {\r\n      \"types\": \"./ably.d.ts\",\r\n      \"node\": \"./build/ably-node.js\",\r\n      \"react-native\": \"./build/ably-reactnative.js\",\r\n      \"default\": \"./build/ably.js\"\r\n    },\r\n    \"./modular\": {\r\n      \"types\": \"./modular.d.ts\",\r\n      \"import\": \"./build/modular/index.mjs\"\r\n    },\r\n    \"./react\": {\r\n      \"require\": \"./react/cjs/index.js\",\r\n      \"import\": \"./react/mjs/index.js\"\r\n    }\r\n  },\r\n  \"typings\": \"./ably.d.ts\",\r\n  \"files\": [\r\n    \"build/**\",\r\n    \"ably.d.ts\",\r\n    \"modular.d.ts\",\r\n    \"resources/**\",\r\n    \"src/**\",\r\n    \"react/**\"\r\n  ],\r\n  \"dependencies\": {\r\n    \"@ably/msgpack-js\": \"^0.4.0\",\r\n    \"fastestsmallesttextencoderdecoder\": \"^1.0.22\",\r\n    \"got\": \"^11.8.5\",\r\n    \"ws\": \"^8.14.2\"\r\n  },\r\n  \"peerDependencies\": {\r\n    \"react\": \">=16.8.0\",\r\n    \"react-dom\": \">=16.8.0\"\r\n  },\r\n  \"peerDependenciesMeta\": {\r\n    \"react\": {\r\n      \"optional\": true\r\n    },\r\n    \"react-dom\": {\r\n      \"optional\": true\r\n    }\r\n  },\r\n  \"devDependencies\": {\r\n    \"@ably/vcdiff-decoder\": \"1.0.6\",\r\n    \"@arethetypeswrong/cli\": \"^0.13.1\",\r\n    \"@babel/generator\": \"^7.23.6\",\r\n    \"@babel/parser\": \"^7.23.6\",\r\n    \"@babel/traverse\": \"^7.23.7\",\r\n    \"@testing-library/react\": \"^13.3.0\",\r\n    \"@types/cli-table\": \"^0.3.4\",\r\n    \"@types/jmespath\": \"^0.15.2\",\r\n    \"@types/node\": \"^18.0.0\",\r\n    \"@types/request\": \"^2.48.7\",\r\n    \"@types/ws\": \"^8.2.0\",\r\n    \"@typescript-eslint/eslint-plugin\": \"^5.59.6\",\r\n    \"@typescript-eslint/parser\": \"^5.59.6\",\r\n    \"@vitejs/plugin-react\": \"^1.3.2\",\r\n    \"async\": \"ably-forks/async#requirejs\",\r\n    \"aws-sdk\": \"^2.1413.0\",\r\n    \"chai\": \"^4.2.0\",\r\n    \"cli-table\": \"^0.3.11\",\r\n    \"cors\": \"^2.8.5\",\r\n    \"esbuild\": \"^0.18.10\",\r\n    \"esbuild-plugin-umd-wrapper\": \"ably-forks/esbuild-plugin-umd-wrapper#1.0.7-optional-amd-named-module\",\r\n    \"esbuild-runner\": \"^2.2.2\",\r\n    \"eslint\": \"^7.13.0\",\r\n    \"eslint-plugin-import\": \"^2.28.0\",\r\n    \"eslint-plugin-jsdoc\": \"^40.0.0\",\r\n    \"eslint-plugin-react\": \"^7.32.2\",\r\n    \"eslint-plugin-react-hooks\": \"^4.6.0\",\r\n    \"eslint-plugin-security\": \"^1.4.0\",\r\n    \"express\": \"^4.17.1\",\r\n    \"glob\": \"~4.4\",\r\n    \"grunt\": \"^1.6.1\",\r\n    \"grunt-cli\": \"~1.2.0\",\r\n    \"grunt-shell\": \"~1.1\",\r\n    \"grunt-webpack\": \"^5.0.0\",\r\n    \"hexy\": \"~0.2\",\r\n    \"jmespath\": \"^0.16.0\",\r\n    \"jsdom\": \"^20.0.0\",\r\n    \"minimist\": \"^1.2.5\",\r\n    \"mocha\": \"^8.1.3\",\r\n    \"mocha-junit-reporter\": \"^2.2.1\",\r\n    \"path-browserify\": \"^1.0.1\",\r\n    \"playwright\": \"^1.39.0\",\r\n    \"prettier\": \"^2.8.8\",\r\n    \"process\": \"^0.11.10\",\r\n    \"react\": \">=18.1.0\",\r\n    \"react-dom\": \">=18.1.0\",\r\n    \"requirejs\": \"~2.1\",\r\n    \"shelljs\": \"~0.8\",\r\n    \"source-map-explorer\": \"^2.5.2\",\r\n    \"source-map-support\": \"^0.5.21\",\r\n    \"stream-browserify\": \"^3.0.0\",\r\n    \"ts-loader\": \"^9.4.2\",\r\n    \"tsconfig-paths-webpack-plugin\": \"^4.0.1\",\r\n    \"tslib\": \"^2.3.1\",\r\n    \"typedoc\": \"^0.24.7\",\r\n    \"typescript\": \"^4.9.5\",\r\n    \"vite\": \"^4.4.9\",\r\n    \"vitest\": \"^0.18.0\",\r\n    \"webpack\": \"^5.79.0\",\r\n    \"webpack-cli\": \"^5.0.1\"\r\n  },\r\n  \"engines\": {\r\n    \"node\": \">=16\"\r\n  },\r\n  \"repository\": \"ably/ably-js\",\r\n  \"jspm\": {\r\n    \"registry\": \"npm\",\r\n    \"directories\": {\r\n      \"lib\": \"build\"\r\n    },\r\n    \"main\": \"ably\"\r\n  },\r\n  \"scripts\": {\r\n    \"start:react\": \"npx vite serve\",\r\n    \"grunt\": \"grunt\",\r\n    \"test\": \"npm run test:node\",\r\n    \"test:node\": \"npm run build:node && mocha\",\r\n    \"test:node:skip-build\": \"mocha\",\r\n    \"test:webserver\": \"grunt test:webserver\",\r\n    \"test:playwright\": \"node test/support/runPlaywrightTests.js\",\r\n    \"test:react\": \"vitest run\",\r\n    \"test:package\": \"grunt test:package\",\r\n    \"concat\": \"grunt concat\",\r\n    \"build\": \"grunt build:all && npm run build:react\",\r\n    \"build:node\": \"grunt build:node\",\r\n    \"build:browser\": \"grunt build:browser\",\r\n    \"build:react\": \"npm run build:react:mjs && npm run build:react:cjs && cp src/platform/react-hooks/res/package.react.json react/package.json\",\r\n    \"build:react:mjs\": \"tsc --project src/platform/react-hooks/tsconfig.mjs.json && cp src/platform/react-hooks/res/package.mjs.json react/mjs/package.json\",\r\n    \"build:react:cjs\": \"tsc --project src/platform/react-hooks/tsconfig.cjs.json && cp src/platform/react-hooks/res/package.cjs.json react/cjs/package.json\",\r\n    \"requirejs\": \"grunt requirejs\",\r\n    \"lint\": \"eslint .\",\r\n    \"lint:fix\": \"eslint --fix .\",\r\n    \"prepare\": \"npm run build\",\r\n    \"format\": \"prettier --write --ignore-path .gitignore --ignore-path .prettierignore src test ably.d.ts modular.d.ts webpack.config.js Gruntfile.js scripts/*.[jt]s docs/**/*.md grunt\",\r\n    \"format:check\": \"prettier --check --ignore-path .gitignore --ignore-path .prettierignore src test ably.d.ts modular.d.ts webpack.config.js Gruntfile.js scripts/*.[jt]s docs/**/*.md grunt\",\r\n    \"sourcemap\": \"source-map-explorer build/ably.min.js\",\r\n    \"modulereport\": \"tsc --noEmit --esModuleInterop scripts/moduleReport.ts && esr scripts/moduleReport.ts\",\r\n    \"docs\": \"typedoc\"\r\n  }\r\n}\r\n", "import Platform from 'common/platform';\r\nimport * as Utils from './utils';\r\nimport Logger from './logger';\r\nimport ErrorInfo from 'common/lib/types/errorinfo';\r\nimport { version } from '../../../../package.json';\r\nimport ClientOptions, { NormalisedClientOptions } from 'common/types/ClientOptions';\r\nimport IDefaults from '../../types/IDefaults';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport { IUntypedCryptoStatic } from 'common/types/ICryptoStatic';\r\nimport { ChannelOptions } from 'common/types/channel';\r\nimport { ModularPlugins } from '../client/modularplugins';\r\n\r\nlet agent = 'ably-js/' + version;\r\n\r\ntype CompleteDefaults = IDefaults & {\r\n  ENVIRONMENT: string;\r\n  REST_HOST: string;\r\n  REALTIME_HOST: string;\r\n  FALLBACK_HOSTS: string[];\r\n  PORT: number;\r\n  TLS_PORT: number;\r\n  TIMEOUTS: {\r\n    disconnectedRetryTimeout: number;\r\n    suspendedRetryTimeout: number;\r\n    httpRequestTimeout: number;\r\n    httpMaxRetryDuration: number;\r\n    channelRetryTimeout: number;\r\n    fallbackRetryTimeout: number;\r\n    connectionStateTtl: number;\r\n    realtimeRequestTimeout: number;\r\n    recvTimeout: number;\r\n    webSocketConnectTimeout: number;\r\n    webSocketSlowTimeout: number;\r\n  };\r\n  httpMaxRetryCount: number;\r\n  maxMessageSize: number;\r\n  version: string;\r\n  protocolVersion: number;\r\n  agent: string;\r\n  getHost(options: ClientOptions, host?: string | null, ws?: boolean): string;\r\n  getPort(options: ClientOptions, tls?: boolean): number | undefined;\r\n  getHttpScheme(options: ClientOptions): string;\r\n  environmentFallbackHosts(environment: string): string[];\r\n  getFallbackHosts(options: NormalisedClientOptions): string[];\r\n  getHosts(options: NormalisedClientOptions, ws?: boolean): string[];\r\n  checkHost(host: string): void;\r\n  getRealtimeHost(options: ClientOptions, production: boolean, environment: string): string;\r\n  objectifyOptions(\r\n    options: undefined | ClientOptions | string,\r\n    allowKeyOrToken: boolean,\r\n    sourceForErrorMessage: string,\r\n    modularPluginsToInclude?: ModularPlugins,\r\n  ): ClientOptions;\r\n  normaliseOptions(options: ClientOptions, MsgPack: MsgPack | null): NormalisedClientOptions;\r\n  defaultGetHeaders(options: NormalisedClientOptions, headersOptions?: HeadersOptions): Record<string, string>;\r\n  defaultPostHeaders(options: NormalisedClientOptions, headersOptions?: HeadersOptions): Record<string, string>;\r\n};\r\n\r\nconst Defaults = {\r\n  ENVIRONMENT: '',\r\n  REST_HOST: 'rest.ably.io',\r\n  REALTIME_HOST: 'realtime.ably.io',\r\n  FALLBACK_HOSTS: [\r\n    'A.ably-realtime.com',\r\n    'B.ably-realtime.com',\r\n    'C.ably-realtime.com',\r\n    'D.ably-realtime.com',\r\n    'E.ably-realtime.com',\r\n  ],\r\n  PORT: 80,\r\n  TLS_PORT: 443,\r\n  TIMEOUTS: {\r\n    /* Documented as options params: */\r\n    disconnectedRetryTimeout: 15000,\r\n    suspendedRetryTimeout: 30000,\r\n    /* Undocumented, but part of the api and can be used by customers: */\r\n    httpRequestTimeout: 10000,\r\n    httpMaxRetryDuration: 15000,\r\n    channelRetryTimeout: 15000,\r\n    fallbackRetryTimeout: 600000,\r\n    /* For internal / test use only: */\r\n    connectionStateTtl: 120000,\r\n    realtimeRequestTimeout: 10000,\r\n    recvTimeout: 90000,\r\n    webSocketConnectTimeout: 10000,\r\n    webSocketSlowTimeout: 4000,\r\n  },\r\n  httpMaxRetryCount: 3,\r\n  maxMessageSize: 65536,\r\n\r\n  version,\r\n  protocolVersion: 3,\r\n  agent,\r\n  getHost,\r\n  getPort,\r\n  getHttpScheme,\r\n  environmentFallbackHosts,\r\n  getFallbackHosts,\r\n  getHosts,\r\n  checkHost,\r\n  objectifyOptions,\r\n  normaliseOptions,\r\n  defaultGetHeaders,\r\n  defaultPostHeaders,\r\n};\r\n\r\nexport function getHost(options: ClientOptions, host?: string | null, ws?: boolean): string {\r\n  if (ws) host = (host == options.restHost && options.realtimeHost) || host || options.realtimeHost;\r\n  else host = host || options.restHost;\r\n\r\n  return host as string;\r\n}\r\n\r\nexport function getPort(options: ClientOptions, tls?: boolean): number | undefined {\r\n  return tls || options.tls ? options.tlsPort : options.port;\r\n}\r\n\r\nexport function getHttpScheme(options: ClientOptions): string {\r\n  return options.tls ? 'https://' : 'http://';\r\n}\r\n\r\n// construct environment fallback hosts as per RSC15i\r\nexport function environmentFallbackHosts(environment: string): string[] {\r\n  return [\r\n    environment + '-a-fallback.ably-realtime.com',\r\n    environment + '-b-fallback.ably-realtime.com',\r\n    environment + '-c-fallback.ably-realtime.com',\r\n    environment + '-d-fallback.ably-realtime.com',\r\n    environment + '-e-fallback.ably-realtime.com',\r\n  ];\r\n}\r\n\r\nexport function getFallbackHosts(options: NormalisedClientOptions): string[] {\r\n  const fallbackHosts = options.fallbackHosts,\r\n    httpMaxRetryCount =\r\n      typeof options.httpMaxRetryCount !== 'undefined' ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;\r\n\r\n  return fallbackHosts ? Utils.arrChooseN(fallbackHosts, httpMaxRetryCount) : [];\r\n}\r\n\r\nexport function getHosts(options: NormalisedClientOptions, ws?: boolean): string[] {\r\n  const hosts = [options.restHost].concat(getFallbackHosts(options));\r\n  return ws ? hosts.map((host) => getHost(options, host, true)) : hosts;\r\n}\r\n\r\nfunction checkHost(host: string): void {\r\n  if (typeof host !== 'string') {\r\n    throw new ErrorInfo('host must be a string; was a ' + typeof host, 40000, 400);\r\n  }\r\n  if (!host.length) {\r\n    throw new ErrorInfo('host must not be zero-length', 40000, 400);\r\n  }\r\n}\r\n\r\nfunction getRealtimeHost(options: ClientOptions, production: boolean, environment: string): string {\r\n  if (options.realtimeHost) return options.realtimeHost;\r\n  /* prefer setting realtimeHost to restHost as a custom restHost typically indicates\r\n   * a development environment is being used that can't be inferred by the library */\r\n  if (options.restHost) {\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'Defaults.normaliseOptions',\r\n      'restHost is set to \"' +\r\n        options.restHost +\r\n        '\" but realtimeHost is not set, so setting realtimeHost to \"' +\r\n        options.restHost +\r\n        '\" too. If this is not what you want, please set realtimeHost explicitly.',\r\n    );\r\n    return options.restHost;\r\n  }\r\n  return production ? Defaults.REALTIME_HOST : environment + '-' + Defaults.REALTIME_HOST;\r\n}\r\n\r\nfunction getTimeouts(options: ClientOptions) {\r\n  /* Allow values passed in options to override default timeouts */\r\n  const timeouts: Record<string, number> = {};\r\n  for (const prop in Defaults.TIMEOUTS) {\r\n    timeouts[prop] = (options as Record<string, number>)[prop] || (Defaults.TIMEOUTS as Record<string, number>)[prop];\r\n  }\r\n  return timeouts;\r\n}\r\n\r\nexport function getAgentString(options: ClientOptions): string {\r\n  let agentStr = Defaults.agent;\r\n  if (options.agents) {\r\n    for (var agent in options.agents) {\r\n      agentStr += ' ' + agent + '/' + options.agents[agent];\r\n    }\r\n  }\r\n  return agentStr;\r\n}\r\n\r\nexport function objectifyOptions(\r\n  options: undefined | ClientOptions | string,\r\n  allowKeyOrToken: boolean,\r\n  sourceForErrorMessage: string,\r\n  modularPluginsToInclude?: ModularPlugins,\r\n): ClientOptions {\r\n  if (options === undefined) {\r\n    const msg = allowKeyOrToken\r\n      ? `${sourceForErrorMessage} must be initialized with either a client options object, an Ably API key, or an Ably Token`\r\n      : `${sourceForErrorMessage} must be initialized with a client options object`;\r\n    Logger.logAction(Logger.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\r\n    throw new Error(msg);\r\n  }\r\n\r\n  let optionsObj: ClientOptions;\r\n\r\n  if (typeof options === 'string') {\r\n    if (options.indexOf(':') == -1) {\r\n      if (!allowKeyOrToken) {\r\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably Token; you must provide a client options object with a \\`plugins\\` property. (Set this Ably Token as the object\u2019s \\`token\\` property.)`;\r\n        Logger.logAction(Logger.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\r\n        throw new Error(msg);\r\n      }\r\n\r\n      optionsObj = { token: options };\r\n    } else {\r\n      if (!allowKeyOrToken) {\r\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably API key; you must provide a client options object with a \\`plugins\\` property. (Set this Ably API key as the object\u2019s \\`key\\` property.)`;\r\n        Logger.logAction(Logger.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\r\n        throw new Error(msg);\r\n      }\r\n\r\n      optionsObj = { key: options };\r\n    }\r\n  } else {\r\n    optionsObj = options;\r\n  }\r\n\r\n  if (modularPluginsToInclude) {\r\n    optionsObj = { ...optionsObj, plugins: { ...modularPluginsToInclude, ...optionsObj.plugins } };\r\n  }\r\n\r\n  return optionsObj;\r\n}\r\n\r\nexport function normaliseOptions(options: ClientOptions, MsgPack: MsgPack | null): NormalisedClientOptions {\r\n  if (typeof options.recover === 'function' && options.closeOnUnload === true) {\r\n    Logger.logAction(\r\n      Logger.LOG_ERROR,\r\n      'Defaults.normaliseOptions',\r\n      'closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter',\r\n    );\r\n    options.recover = undefined;\r\n  }\r\n\r\n  if (!('closeOnUnload' in options)) {\r\n    /* Have closeOnUnload default to true unless we have any indication that\r\n     * the user may want to recover the connection */\r\n    options.closeOnUnload = !options.recover;\r\n  }\r\n\r\n  if (!('queueMessages' in options)) options.queueMessages = true;\r\n\r\n  /* infer hosts and fallbacks based on the configured environment */\r\n  const environment = (options.environment && String(options.environment).toLowerCase()) || Defaults.ENVIRONMENT;\r\n  const production = !environment || environment === 'production';\r\n\r\n  if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {\r\n    options.fallbackHosts = production ? Defaults.FALLBACK_HOSTS : environmentFallbackHosts(environment);\r\n  }\r\n\r\n  const restHost = options.restHost || (production ? Defaults.REST_HOST : environment + '-' + Defaults.REST_HOST);\r\n  const realtimeHost = getRealtimeHost(options, production, environment);\r\n\r\n  (options.fallbackHosts || []).concat(restHost, realtimeHost).forEach(checkHost);\r\n\r\n  options.port = options.port || Defaults.PORT;\r\n  options.tlsPort = options.tlsPort || Defaults.TLS_PORT;\r\n  if (!('tls' in options)) options.tls = true;\r\n\r\n  const timeouts = getTimeouts(options);\r\n\r\n  if (MsgPack) {\r\n    if ('useBinaryProtocol' in options) {\r\n      options.useBinaryProtocol = Platform.Config.supportsBinary && options.useBinaryProtocol;\r\n    } else {\r\n      options.useBinaryProtocol = Platform.Config.preferBinary;\r\n    }\r\n  } else {\r\n    options.useBinaryProtocol = false;\r\n  }\r\n\r\n  const headers: Record<string, string> = {};\r\n  if (options.clientId) {\r\n    headers['X-Ably-ClientId'] = Platform.BufferUtils.base64Encode(Platform.BufferUtils.utf8Encode(options.clientId));\r\n  }\r\n\r\n  if (!('idempotentRestPublishing' in options)) {\r\n    options.idempotentRestPublishing = true;\r\n  }\r\n\r\n  let connectivityCheckParams = null;\r\n  let connectivityCheckUrl = options.connectivityCheckUrl;\r\n  if (options.connectivityCheckUrl) {\r\n    let [uri, qs] = options.connectivityCheckUrl.split('?');\r\n    connectivityCheckParams = qs ? Utils.parseQueryString(qs) : {};\r\n    if (uri.indexOf('://') === -1) {\r\n      uri = 'https://' + uri;\r\n    }\r\n    connectivityCheckUrl = uri;\r\n  }\r\n\r\n  return {\r\n    ...options,\r\n    realtimeHost,\r\n    restHost,\r\n    maxMessageSize: options.maxMessageSize || Defaults.maxMessageSize,\r\n    timeouts,\r\n    connectivityCheckParams,\r\n    connectivityCheckUrl,\r\n    headers,\r\n  };\r\n}\r\n\r\nexport function normaliseChannelOptions(Crypto: IUntypedCryptoStatic | null, options?: ChannelOptions) {\r\n  const channelOptions = options || {};\r\n  if (channelOptions.cipher) {\r\n    if (!Crypto) Utils.throwMissingPluginError('Crypto');\r\n    const cipher = Crypto.getCipher(channelOptions.cipher);\r\n    channelOptions.cipher = cipher.cipherParams;\r\n    channelOptions.channelCipher = cipher.cipher;\r\n  } else if ('cipher' in channelOptions) {\r\n    /* Don't deactivate an existing cipher unless options\r\n     * has a 'cipher' key that's falsey */\r\n    channelOptions.cipher = undefined;\r\n    channelOptions.channelCipher = null;\r\n  }\r\n  return channelOptions;\r\n}\r\n\r\nconst contentTypes = {\r\n  json: 'application/json',\r\n  xml: 'application/xml',\r\n  html: 'text/html',\r\n  msgpack: 'application/x-msgpack',\r\n};\r\n\r\nexport interface HeadersOptions {\r\n  format?: Utils.Format;\r\n  protocolVersion?: number;\r\n}\r\n\r\nconst defaultHeadersOptions: Required<HeadersOptions> = {\r\n  format: Utils.Format.json,\r\n  protocolVersion: Defaults.protocolVersion,\r\n};\r\n\r\nexport function defaultGetHeaders(\r\n  options: NormalisedClientOptions,\r\n  {\r\n    format = defaultHeadersOptions.format,\r\n    protocolVersion = defaultHeadersOptions.protocolVersion,\r\n  }: HeadersOptions = {},\r\n): Record<string, string> {\r\n  const accept = contentTypes[format];\r\n  return {\r\n    accept: accept,\r\n    'X-Ably-Version': protocolVersion.toString(),\r\n    'Ably-Agent': getAgentString(options),\r\n  };\r\n}\r\n\r\nexport function defaultPostHeaders(\r\n  options: NormalisedClientOptions,\r\n  {\r\n    format = defaultHeadersOptions.format,\r\n    protocolVersion = defaultHeadersOptions.protocolVersion,\r\n  }: HeadersOptions = {},\r\n): Record<string, string> {\r\n  let contentType;\r\n  const accept = (contentType = contentTypes[format]);\r\n\r\n  return {\r\n    accept: accept,\r\n    'content-type': contentType,\r\n    'X-Ably-Version': protocolVersion.toString(),\r\n    'Ably-Agent': getAgentString(options),\r\n  };\r\n}\r\n\r\nexport default Defaults as CompleteDefaults;\r\n\r\nexport function getDefaults(platformDefaults: IDefaults) {\r\n  return Object.assign(Defaults, platformDefaults);\r\n}\r\n", "import { StandardCallback } from 'common/types/utils';\r\nimport ErrorInfo from 'common/lib/types/errorinfo';\r\nimport Logger from './logger';\r\n\r\nexport interface MulticasterInstance<T> extends Function {\r\n  (err?: ErrorInfo | null, result?: T): void;\r\n  push: (fn: StandardCallback<T>) => void;\r\n  /**\r\n   * Creates a promise that will be resolved or rejected when this instance is called.\r\n   */\r\n  createPromise: () => Promise<T>;\r\n  /**\r\n   * Syntatic sugar for when working in a context that uses promises; equivalent to calling as a function with arguments (null, result).\r\n   */\r\n  resolveAll(result: T): void;\r\n  /**\r\n   * Syntatic sugar for when working in a context that uses promises; equivalent to calling as a function with arguments (err).\r\n   */\r\n  rejectAll(err: ErrorInfo): void;\r\n}\r\n\r\nclass Multicaster<T> {\r\n  members: Array<StandardCallback<T>>;\r\n\r\n  // Private constructor; use static Multicaster.create instead\r\n  private constructor(members?: Array<StandardCallback<T> | undefined>) {\r\n    this.members = (members as Array<StandardCallback<T>>) || [];\r\n  }\r\n\r\n  private call(err?: ErrorInfo | null, result?: T): void {\r\n    for (const member of this.members) {\r\n      if (member) {\r\n        try {\r\n          member(err, result);\r\n        } catch (e) {\r\n          Logger.logAction(\r\n            Logger.LOG_ERROR,\r\n            'Multicaster multiple callback handler',\r\n            'Unexpected exception: ' + e + '; stack = ' + (e as Error).stack,\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  push(...args: Array<StandardCallback<T>>): void {\r\n    this.members.push(...args);\r\n  }\r\n\r\n  createPromise(): Promise<T> {\r\n    return new Promise((resolve, reject) => {\r\n      this.push((err, result) => {\r\n        err ? reject(err) : resolve(result!);\r\n      });\r\n    });\r\n  }\r\n\r\n  resolveAll(result: T) {\r\n    this.call(null, result);\r\n  }\r\n\r\n  rejectAll(err: ErrorInfo) {\r\n    this.call(err);\r\n  }\r\n\r\n  static create<T>(members?: Array<StandardCallback<T> | undefined>): MulticasterInstance<T> {\r\n    const instance = new Multicaster(members);\r\n    return Object.assign((err?: ErrorInfo | null, result?: T) => instance.call(err, result), {\r\n      push: (fn: StandardCallback<T>) => instance.push(fn),\r\n      createPromise: () => instance.createPromise(),\r\n      resolveAll: (result: T) => instance.resolveAll(result),\r\n      rejectAll: (err: ErrorInfo) => instance.rejectAll(err),\r\n    });\r\n  }\r\n}\r\n\r\nexport default Multicaster;\r\n", "enum HttpMethods {\n  Get = 'get',\n  Delete = 'delete',\n  Post = 'post',\n  Put = 'put',\n  Patch = 'patch',\n}\n\nexport default HttpMethods;\n", "enum HttpStatusCodes {\n  Success = 200,\n  NoContent = 204,\n  BadRequest = 400,\n  Unauthorized = 401,\n  Forbidden = 403,\n  RequestTimeout = 408,\n  InternalServerError = 500,\n}\n\nexport function isSuccessCode(statusCode: number) {\n  return statusCode >= HttpStatusCodes.Success && statusCode < HttpStatusCodes.BadRequest;\n}\n\nexport default HttpStatusCodes;\n", "import Logger from '../util/logger';\nimport * as Utils from '../util/utils';\nimport Multicaster, { MulticasterInstance } from '../util/multicaster';\nimport ErrorInfo, { IPartialErrorInfo } from '../types/errorinfo';\nimport { RequestResultError, RequestParams, RequestResult } from '../../types/http';\nimport * as API from '../../../../ably';\nimport BaseClient from './baseclient';\nimport BaseRealtime from './baserealtime';\nimport ClientOptions from '../../types/ClientOptions';\nimport HttpMethods from '../../constants/HttpMethods';\nimport HttpStatusCodes from 'common/constants/HttpStatusCodes';\nimport Platform, { Bufferlike } from '../../platform';\nimport Defaults from '../util/defaults';\n\ntype BatchResult<T> = API.BatchResult<T>;\ntype TokenRevocationTargetSpecifier = API.TokenRevocationTargetSpecifier;\ntype TokenRevocationOptions = API.TokenRevocationOptions;\ntype TokenRevocationSuccessResult = API.TokenRevocationSuccessResult;\ntype TokenRevocationFailureResult = API.TokenRevocationFailureResult;\ntype TokenRevocationResult = BatchResult<TokenRevocationSuccessResult | TokenRevocationFailureResult>;\n\nconst MAX_TOKEN_LENGTH = Math.pow(2, 17);\nfunction random() {\n  return ('000000' + Math.floor(Math.random() * 1e16)).slice(-16);\n}\n\nfunction isRealtime(client: BaseClient): client is BaseRealtime {\n  return !!(client as BaseRealtime).connection;\n}\n\n/* A client auth callback may give errors in any number of formats; normalise to an ErrorInfo or PartialErrorInfo */\nfunction normaliseAuthcallbackError(err: any) {\n  if (!Utils.isErrorInfoOrPartialErrorInfo(err)) {\n    return new ErrorInfo(Utils.inspectError(err), err.code || 40170, err.statusCode || 401);\n  }\n  /* network errors will not have an inherent error code */\n  if (!err.code) {\n    if (err.statusCode === 403) {\n      err.code = 40300;\n    } else {\n      err.code = 40170;\n      /* normalise statusCode to 401 per RSA4e */\n      err.statusCode = 401;\n    }\n  }\n  return err;\n}\n\nlet hmac = (text: string, key: string): string => {\n  const bufferUtils = Platform.BufferUtils;\n\n  const textBuffer = bufferUtils.utf8Encode(text);\n  const keyBuffer = bufferUtils.utf8Encode(key);\n\n  const digest = bufferUtils.hmacSha256(textBuffer, keyBuffer);\n\n  return bufferUtils.base64Encode(digest);\n};\n\nfunction c14n(capability?: string | Record<string, Array<string>>) {\n  if (!capability) return '';\n\n  if (typeof capability == 'string') capability = JSON.parse(capability);\n\n  const c14nCapability: Record<string, Array<string>> = Object.create(null);\n  const keys = Utils.keysArray(capability as Record<string, Array<string>>, true);\n  if (!keys) return '';\n  keys.sort();\n  for (let i = 0; i < keys.length; i++) {\n    c14nCapability[keys[i]] = (capability as Record<string, Array<string>>)[keys[i]].sort();\n  }\n  return JSON.stringify(c14nCapability);\n}\n\nfunction logAndValidateTokenAuthMethod(authOptions: AuthOptions) {\n  if (authOptions.authCallback) {\n    Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'using token auth with authCallback');\n  } else if (authOptions.authUrl) {\n    Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'using token auth with authUrl');\n  } else if (authOptions.key) {\n    Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'using token auth with client-side signing');\n  } else if (authOptions.tokenDetails) {\n    Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'using token auth with supplied token only');\n  } else {\n    const msg = 'authOptions must include valid authentication parameters';\n    Logger.logAction(Logger.LOG_ERROR, 'Auth()', msg);\n    throw new Error(msg);\n  }\n}\n\nfunction basicAuthForced(options: ClientOptions) {\n  return 'useTokenAuth' in options && !options.useTokenAuth;\n}\n\n/* RSA4 */\nexport function useTokenAuth(options: ClientOptions) {\n  return (\n    options.useTokenAuth ||\n    (!basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails))\n  );\n}\n\n/* RSA4a */\nfunction noWayToRenew(options: ClientOptions) {\n  return !options.key && !options.authCallback && !options.authUrl;\n}\n\nlet trId = 0;\nfunction getTokenRequestId() {\n  return trId++;\n}\n\n/**\n * Auth options used only for testing.\n */\ntype PrivateAuthOptions = {\n  requestHeaders?: Record<string, string>;\n  suppressMaxLengthCheck?: boolean;\n};\n\ntype AuthOptions = API.AuthOptions & PrivateAuthOptions;\n\nclass Auth {\n  client: BaseClient;\n  tokenParams: API.TokenParams;\n  currentTokenRequestId: number | null;\n  waitingForTokenRequest: MulticasterInstance<API.TokenDetails> | null;\n  // This initialization is always overwritten and only used to prevent a TypeScript compiler error\n  authOptions: AuthOptions = {} as AuthOptions;\n  tokenDetails?: API.TokenDetails | null;\n  method?: string;\n  key?: string;\n  basicKey?: string;\n  clientId?: string | null;\n\n  constructor(client: BaseClient, options: ClientOptions) {\n    this.client = client;\n    this.tokenParams = options.defaultTokenParams || {};\n    /* The id of the current token request if one is in progress, else null */\n    this.currentTokenRequestId = null;\n    this.waitingForTokenRequest = null;\n\n    if (useTokenAuth(options)) {\n      /* Token auth */\n      if (noWayToRenew(options)) {\n        Logger.logAction(\n          Logger.LOG_ERROR,\n          'Auth()',\n          'Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help',\n        );\n      }\n      this._saveTokenOptions(options.defaultTokenParams as API.TokenDetails, options);\n      logAndValidateTokenAuthMethod(this.authOptions);\n    } else {\n      /* Basic auth */\n      if (!options.key) {\n        const msg =\n          'No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)';\n        Logger.logAction(Logger.LOG_ERROR, 'Auth()', msg);\n        throw new ErrorInfo(msg, 40160, 401);\n      }\n      Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'anonymous, using basic auth');\n      this._saveBasicOptions(options);\n    }\n  }\n\n  /**\n   * Instructs the library to get a token immediately and ensures Token Auth\n   * is used for all future requests, storing the tokenParams and authOptions\n   * given as the new defaults for subsequent use.\n   */\n  async authorize(): Promise<API.TokenDetails>;\n\n  /**\n   * Instructs the library to get a token immediately and ensures Token Auth\n   * is used for all future requests, storing the tokenParams and authOptions\n   * given as the new defaults for subsequent use.\n   *\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   *\n   * - ttl:        (optional) the requested life of any new token in ms. If none\n   *               is specified a default of 1 hour is provided. The maximum lifetime\n   *               is 24hours; any request exceeding that lifetime will be rejected\n   *               with an error.\n   *\n   * - capability: (optional) the capability to associate with the access token.\n   *               If none is specified, a token will be requested with all of the\n   *               capabilities of the specified key.\n   *\n   * - clientId:   (optional) a client ID to associate with the token\n   *\n   * - timestamp:  (optional) the time in ms since the epoch. If none is specified,\n   *               the system will be queried for a time value to use.\n   */\n  async authorize(tokenParams: API.TokenParams | null): Promise<API.TokenDetails>;\n\n  /**\n   * Instructs the library to get a token immediately and ensures Token Auth\n   * is used for all future requests, storing the tokenParams and authOptions\n   * given as the new defaults for subsequent use.\n   *\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   *\n   * - ttl:        (optional) the requested life of any new token in ms. If none\n   *               is specified a default of 1 hour is provided. The maximum lifetime\n   *               is 24hours; any request exceeding that lifetime will be rejected\n   *               with an error.\n   *\n   * - capability: (optional) the capability to associate with the access token.\n   *               If none is specified, a token will be requested with all of the\n   *               capabilities of the specified key.\n   *\n   * - clientId:   (optional) a client ID to associate with the token\n   *\n   * - timestamp:  (optional) the time in ms since the epoch. If none is specified,\n   *               the system will be queried for a time value to use.\n   *\n   * @param authOptions\n   * an object containing auth options relevant to token auth:\n   *\n   * - queryTime   (optional) boolean indicating that the Ably system should be\n   *               queried for the current time when none is specified explicitly.\n   *\n   * - tokenDetails: (optional) object: An authenticated TokenDetails object.\n   *\n   * - token:        (optional) string: the `token` property of a tokenDetails object\n   *\n   * - authCallback:  (optional) a JavaScript callback to be called to get auth information.\n   *                  authCallback should be a function of (tokenParams, callback) that calls\n   *                  the callback with (err, result), where result is any of:\n   *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),\n   *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),\n   *                  - a token string\n   *\n   * - authUrl:       (optional) a URL to be used to GET or POST a set of token request\n   *                  params, to obtain a signed token request.\n   *\n   * - authHeaders:   (optional) a set of application-specific headers to be added to any request\n   *                  made to the authUrl.\n   *\n   * - authParams:    (optional) a set of application-specific query params to be added to any\n   *                  request made to the authUrl.\n   *\n   *\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\n   *                  requestToken request\n   */\n  async authorize(tokenParams: API.TokenParams | null, authOptions: AuthOptions | null): Promise<API.TokenDetails>;\n\n  async authorize(\n    tokenParams?: Record<string, any> | null,\n    authOptions?: AuthOptions | null,\n  ): Promise<API.TokenDetails> {\n    /* RSA10a: authorize() call implies token auth. If a key is passed it, we\n     * just check if it doesn't clash and assume we're generating a token from it */\n    if (authOptions && authOptions.key && this.authOptions.key !== authOptions.key) {\n      throw new ErrorInfo('Unable to update auth options with incompatible key', 40102, 401);\n    }\n\n    try {\n      let tokenDetails = await this._forceNewToken(tokenParams ?? null, authOptions ?? null);\n\n      /* RTC8\n       * - When authorize called by an end user and have a realtime connection,\n       * don't call back till new token has taken effect.\n       * - Use this.client.connection as a proxy for (this.client instanceof BaseRealtime),\n       * which doesn't work in node as BaseRealtime isn't part of the vm context for Rest clients */\n      if (isRealtime(this.client)) {\n        return new Promise((resolve, reject) => {\n          (this.client as BaseRealtime).connection.connectionManager.onAuthUpdated(\n            tokenDetails,\n            (err: unknown, tokenDetails?: API.TokenDetails) => (err ? reject(err) : resolve(tokenDetails!)),\n          );\n        });\n      } else {\n        return tokenDetails;\n      }\n    } catch (err) {\n      if ((this.client as BaseRealtime).connection && (err as ErrorInfo).statusCode === HttpStatusCodes.Forbidden) {\n        /* Per RSA4d & RSA4d1, if the auth server explicitly repudiates our right to\n         * stay connecticed by returning a 403, we actively disconnect the connection\n         * even though we may well still have time left in the old token. */\n        (this.client as BaseRealtime).connection.connectionManager.actOnErrorFromAuthorize(err as ErrorInfo);\n      }\n      throw err;\n    }\n  }\n\n  /* For internal use, eg by connectionManager - useful when want to call back\n   * as soon as we have the new token, rather than waiting for it to take\n   * effect on the connection as #authorize does */\n  async _forceNewToken(\n    tokenParams: API.TokenParams | null,\n    authOptions: AuthOptions | null,\n  ): Promise<API.TokenDetails> {\n    /* get rid of current token even if still valid */\n    this.tokenDetails = null;\n\n    /* _save normalises the tokenParams and authOptions and updates the auth\n     * object. All subsequent operations should use the values on `this`,\n     * not the passed in ones. */\n    this._saveTokenOptions(tokenParams, authOptions);\n\n    logAndValidateTokenAuthMethod(this.authOptions);\n\n    try {\n      return this._ensureValidAuthCredentials(true);\n    } finally {\n      /* RSA10g */\n      delete this.tokenParams.timestamp;\n      delete this.authOptions.queryTime;\n    }\n  }\n\n  /**\n   * Request an access token\n   */\n  async requestToken(): Promise<API.TokenDetails>;\n\n  /**\n   * Request an access token\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   * - ttl:          (optional) the requested life of the token in milliseconds. If none is specified\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\n   *                  exceeding that lifetime will be rejected with an error.\n   *\n   * - capability:    (optional) the capability to associate with the access token.\n   *                  If none is specified, a token will be requested with all of the\n   *                  capabilities of the specified key.\n   *\n   * - clientId:      (optional) a client ID to associate with the token; if not\n   *                  specified, a clientId passed in constructing the Rest interface will be used\n   *\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\n   *                  the system will be queried for a time value to use.\n   */\n  async requestToken(tokenParams: API.TokenParams | null): Promise<API.TokenDetails>;\n\n  /**\n   * Request an access token\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   * - ttl:          (optional) the requested life of the token in milliseconds. If none is specified\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\n   *                  exceeding that lifetime will be rejected with an error.\n   *\n   * - capability:    (optional) the capability to associate with the access token.\n   *                  If none is specified, a token will be requested with all of the\n   *                  capabilities of the specified key.\n   *\n   * - clientId:      (optional) a client ID to associate with the token; if not\n   *                  specified, a clientId passed in constructing the Rest interface will be used\n   *\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\n   *                  the system will be queried for a time value to use.\n   *\n   * @param authOptions\n   * an object containing the request options:\n   * - key:           the key to use.\n   *\n   * - authCallback:  (optional) a JavaScript callback to be called to get auth information.\n   *                  authCallback should be a function of (tokenParams, callback) that calls\n   *                  the callback with (err, result), where result is any of:\n   *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),\n   *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),\n   *                  - a token string\n   *\n   * - authUrl:       (optional) a URL to be used to GET or POST a set of token request\n   *                  params, to obtain a signed token request.\n   *\n   * - authHeaders:   (optional) a set of application-specific headers to be added to any request\n   *                  made to the authUrl.\n   *\n   * - authParams:    (optional) a set of application-specific query params to be added to any\n   *                  request made to the authUrl.\n   *\n   * - queryTime      (optional) boolean indicating that the ably system should be\n   *                  queried for the current time when none is specified explicitly\n   *\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\n   *                  requestToken request\n   */\n  async requestToken(tokenParams: API.TokenParams | null, authOptions: AuthOptions): Promise<API.TokenDetails>;\n\n  async requestToken(tokenParams?: API.TokenParams | null, authOptions?: AuthOptions): Promise<API.TokenDetails> {\n    /* RSA8e: if authOptions passed in, they're used instead of stored, don't merge them */\n    const resolvedAuthOptions = authOptions || this.authOptions;\n    const resolvedTokenParams = tokenParams || Utils.copy(this.tokenParams);\n\n    /* first set up whatever callback will be used to get signed\n     * token requests */\n    let tokenRequestCallback: (\n        data: API.TokenParams,\n        callback: (\n          error: API.ErrorInfo | RequestResultError | string | null,\n          tokenRequestOrDetails: API.TokenDetails | API.TokenRequest | string | null,\n          contentType?: string,\n        ) => void,\n      ) => void,\n      client = this.client;\n\n    if (resolvedAuthOptions.authCallback) {\n      Logger.logAction(Logger.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authCallback');\n      tokenRequestCallback = resolvedAuthOptions.authCallback;\n    } else if (resolvedAuthOptions.authUrl) {\n      Logger.logAction(Logger.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authUrl');\n      tokenRequestCallback = (params, cb) => {\n        const authHeaders = Utils.mixin(\n          { accept: 'application/json, text/plain' },\n          resolvedAuthOptions.authHeaders,\n        ) as Record<string, string>;\n        const usePost = resolvedAuthOptions.authMethod && resolvedAuthOptions.authMethod.toLowerCase() === 'post';\n        let providedQsParams;\n        /* Combine authParams with any qs params given in the authUrl */\n        const queryIdx = resolvedAuthOptions.authUrl!.indexOf('?');\n        if (queryIdx > -1) {\n          providedQsParams = Utils.parseQueryString(resolvedAuthOptions.authUrl!.slice(queryIdx));\n          resolvedAuthOptions.authUrl = resolvedAuthOptions.authUrl!.slice(0, queryIdx);\n          if (!usePost) {\n            /* In case of conflict, authParams take precedence over qs params in the authUrl */\n            resolvedAuthOptions.authParams = Utils.mixin(\n              providedQsParams,\n              resolvedAuthOptions.authParams,\n            ) as typeof resolvedAuthOptions.authParams;\n          }\n        }\n        /* RSA8c2 */\n        const authParams = Utils.mixin({}, resolvedAuthOptions.authParams || {}, params) as RequestParams;\n        const authUrlRequestCallback = function (result: RequestResult) {\n          let body = (result.body ?? null) as string | Bufferlike | API.TokenDetails | API.TokenRequest | null;\n\n          let contentType: string | null = null;\n          if (result.error) {\n            Logger.logAction(\n              Logger.LOG_MICRO,\n              'Auth.requestToken().tokenRequestCallback',\n              'Received Error: ' + Utils.inspectError(result.error),\n            );\n          } else {\n            const contentTypeHeaderOrHeaders = result.headers!['content-type'] ?? null;\n            if (Array.isArray(contentTypeHeaderOrHeaders)) {\n              // Combine multiple header values into a comma-separated list per https://datatracker.ietf.org/doc/html/rfc9110#section-5.2; see https://github.com/ably/ably-js/issues/1616 for doing this consistently across the codebase.\n              contentType = contentTypeHeaderOrHeaders.join(', ');\n            } else {\n              contentType = contentTypeHeaderOrHeaders;\n            }\n            Logger.logAction(\n              Logger.LOG_MICRO,\n              'Auth.requestToken().tokenRequestCallback',\n              'Received; content-type: ' + contentType + '; body: ' + Utils.inspectBody(body),\n            );\n          }\n          if (result.error) {\n            cb(result.error, null);\n            return;\n          }\n          if (result.unpacked) {\n            cb(null, body as Exclude<typeof body, Bufferlike>);\n            return;\n          }\n          if (Platform.BufferUtils.isBuffer(body)) body = body.toString();\n          if (!contentType) {\n            cb(new ErrorInfo('authUrl response is missing a content-type header', 40170, 401), null);\n            return;\n          }\n          const json = contentType.indexOf('application/json') > -1,\n            text = contentType.indexOf('text/plain') > -1 || contentType.indexOf('application/jwt') > -1;\n          if (!json && !text) {\n            cb(\n              new ErrorInfo(\n                'authUrl responded with unacceptable content-type ' +\n                  contentType +\n                  ', should be either text/plain, application/jwt or application/json',\n                40170,\n                401,\n              ),\n              null,\n            );\n            return;\n          }\n          if (json) {\n            if ((body as string).length > MAX_TOKEN_LENGTH) {\n              cb(new ErrorInfo('authUrl response exceeded max permitted length', 40170, 401), null);\n              return;\n            }\n            try {\n              body = JSON.parse(body as string);\n            } catch (e) {\n              cb(\n                new ErrorInfo(\n                  'Unexpected error processing authURL response; err = ' + (e as Error).message,\n                  40170,\n                  401,\n                ),\n                null,\n              );\n              return;\n            }\n          }\n          cb(null, body as Exclude<typeof body, Bufferlike>, contentType);\n        };\n        Logger.logAction(\n          Logger.LOG_MICRO,\n          'Auth.requestToken().tokenRequestCallback',\n          'Requesting token from ' +\n            resolvedAuthOptions.authUrl +\n            '; Params: ' +\n            JSON.stringify(authParams) +\n            '; method: ' +\n            (usePost ? 'POST' : 'GET'),\n        );\n        if (usePost) {\n          /* send body form-encoded */\n          const headers = authHeaders || {};\n          headers['content-type'] = 'application/x-www-form-urlencoded';\n          const body = Utils.toQueryString(authParams).slice(1); /* slice is to remove the initial '?' */\n          Utils.whenPromiseSettles(\n            this.client.http.doUri(\n              HttpMethods.Post,\n              resolvedAuthOptions.authUrl!,\n              headers,\n              body,\n              providedQsParams as Record<string, string>,\n            ),\n            (err: any, result) =>\n              err\n                ? authUrlRequestCallback(err) // doUri isn\u2019t meant to throw an error, but handle any just in case\n                : authUrlRequestCallback(result!),\n          );\n        } else {\n          Utils.whenPromiseSettles(\n            this.client.http.doUri(HttpMethods.Get, resolvedAuthOptions.authUrl!, authHeaders || {}, null, authParams),\n            (err: any, result) =>\n              err\n                ? authUrlRequestCallback(err) // doUri isn\u2019t meant to throw an error, but handle any just in case\n                : authUrlRequestCallback(result!),\n          );\n        }\n      };\n    } else if (resolvedAuthOptions.key) {\n      Logger.logAction(Logger.LOG_MINOR, 'Auth.requestToken()', 'using token auth with client-side signing');\n      tokenRequestCallback = (params, cb) => {\n        Utils.whenPromiseSettles(this.createTokenRequest(params, resolvedAuthOptions), (err, result) =>\n          cb(err as string | ErrorInfo | null, result ?? null),\n        );\n      };\n    } else {\n      const msg =\n        'Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)';\n      Logger.logAction(\n        Logger.LOG_ERROR,\n        'Auth()',\n        'library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help',\n      );\n      throw new ErrorInfo(msg, 40171, 403);\n    }\n\n    /* normalise token params */\n    if ('capability' in (resolvedTokenParams as Record<string, any>))\n      (resolvedTokenParams as Record<string, any>).capability = c14n(\n        (resolvedTokenParams as Record<string, any>).capability,\n      );\n\n    const tokenRequest = (\n      signedTokenParams: Record<string, any>,\n      tokenCb: (err: RequestResultError | null, tokenResponse?: API.TokenDetails | string, unpacked?: boolean) => void,\n    ) => {\n      const keyName = signedTokenParams.keyName,\n        path = '/keys/' + keyName + '/requestToken',\n        tokenUri = function (host: string) {\n          return client.baseUri(host) + path;\n        };\n\n      const requestHeaders = Defaults.defaultPostHeaders(this.client.options);\n      if (resolvedAuthOptions.requestHeaders) Utils.mixin(requestHeaders, resolvedAuthOptions.requestHeaders);\n      Logger.logAction(\n        Logger.LOG_MICRO,\n        'Auth.requestToken().requestToken',\n        'Sending POST to ' + path + '; Token params: ' + JSON.stringify(signedTokenParams),\n      );\n      Utils.whenPromiseSettles(\n        this.client.http.do(HttpMethods.Post, tokenUri, requestHeaders, JSON.stringify(signedTokenParams), null),\n        (err: any, result) =>\n          err\n            ? tokenCb(err) // doUri isn\u2019t meant to throw an error, but handle any just in case\n            : tokenCb(result!.error, result!.body as API.TokenDetails | string | undefined, result!.unpacked),\n      );\n    };\n\n    return new Promise((resolve, reject) => {\n      let tokenRequestCallbackTimeoutExpired = false,\n        timeoutLength = this.client.options.timeouts.realtimeRequestTimeout,\n        tokenRequestCallbackTimeout = setTimeout(function () {\n          tokenRequestCallbackTimeoutExpired = true;\n          const msg = 'Token request callback timed out after ' + timeoutLength / 1000 + ' seconds';\n          Logger.logAction(Logger.LOG_ERROR, 'Auth.requestToken()', msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n        }, timeoutLength);\n\n      tokenRequestCallback!(resolvedTokenParams, function (err, tokenRequestOrDetails, contentType) {\n        if (tokenRequestCallbackTimeoutExpired) return;\n        clearTimeout(tokenRequestCallbackTimeout);\n\n        if (err) {\n          Logger.logAction(\n            Logger.LOG_ERROR,\n            'Auth.requestToken()',\n            'token request signing call returned error; err = ' + Utils.inspectError(err),\n          );\n          reject(normaliseAuthcallbackError(err));\n          return;\n        }\n        /* the response from the callback might be a token string, a signed request or a token details */\n        if (typeof tokenRequestOrDetails === 'string') {\n          if (tokenRequestOrDetails.length === 0) {\n            reject(new ErrorInfo('Token string is empty', 40170, 401));\n          } else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {\n            reject(\n              new ErrorInfo(\n                'Token string exceeded max permitted length (was ' + tokenRequestOrDetails.length + ' bytes)',\n                40170,\n                401,\n              ),\n            );\n          } else if (tokenRequestOrDetails === 'undefined' || tokenRequestOrDetails === 'null') {\n            /* common failure mode with poorly-implemented authCallbacks */\n            reject(new ErrorInfo('Token string was literal null/undefined', 40170, 401));\n          } else if (\n            tokenRequestOrDetails[0] === '{' &&\n            !(contentType && contentType.indexOf('application/jwt') > -1)\n          ) {\n            reject(\n              new ErrorInfo(\n                \"Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details\",\n                40170,\n                401,\n              ),\n            );\n          } else {\n            resolve({ token: tokenRequestOrDetails } as API.TokenDetails);\n          }\n          return;\n        }\n        if (typeof tokenRequestOrDetails !== 'object' || tokenRequestOrDetails === null) {\n          const msg =\n            'Expected token request callback to call back with a token string or token request/details object, but got a ' +\n            typeof tokenRequestOrDetails;\n          Logger.logAction(Logger.LOG_ERROR, 'Auth.requestToken()', msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n          return;\n        }\n        const objectSize = JSON.stringify(tokenRequestOrDetails).length;\n        if (objectSize > MAX_TOKEN_LENGTH && !resolvedAuthOptions.suppressMaxLengthCheck) {\n          reject(\n            new ErrorInfo(\n              'Token request/details object exceeded max permitted stringified size (was ' + objectSize + ' bytes)',\n              40170,\n              401,\n            ),\n          );\n          return;\n        }\n        if ('issued' in tokenRequestOrDetails) {\n          /* a tokenDetails object */\n          resolve(tokenRequestOrDetails);\n          return;\n        }\n        if (!('keyName' in tokenRequestOrDetails)) {\n          const msg =\n            'Expected token request callback to call back with a token string, token request object, or token details object';\n          Logger.logAction(Logger.LOG_ERROR, 'Auth.requestToken()', msg);\n          reject(new ErrorInfo(msg, 40170, 401));\n          return;\n        }\n        /* it's a token request, so make the request */\n        tokenRequest(tokenRequestOrDetails, function (err, tokenResponse, unpacked) {\n          if (err) {\n            Logger.logAction(\n              Logger.LOG_ERROR,\n              'Auth.requestToken()',\n              'token request API call returned error; err = ' + Utils.inspectError(err),\n            );\n            reject(normaliseAuthcallbackError(err));\n            return;\n          }\n          if (!unpacked) tokenResponse = JSON.parse(tokenResponse as string);\n          Logger.logAction(Logger.LOG_MINOR, 'Auth.getToken()', 'token received');\n          resolve(tokenResponse as API.TokenDetails);\n        });\n      });\n    });\n  }\n\n  /**\n   * Create and sign a token request based on the given options.\n   * NOTE this can only be used when the key value is available locally.\n   * Otherwise, signed token requests must be obtained from the key\n   * owner (either using the token request callback or url).\n   *\n   * @param authOptions\n   * an object containing the request options:\n   * - key:           the key to use. If not specified, a key passed in constructing\n   *                  the Rest interface will be used\n   *\n   * - queryTime      (optional) boolean indicating that the ably system should be\n   *                  queried for the current time when none is specified explicitly\n   *\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\n   *                  requestToken request\n   *\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   * - ttl:       (optional) the requested life of the token in ms. If none is specified\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\n   *                  exceeding that lifetime will be rejected with an error.\n   *\n   * - capability:    (optional) the capability to associate with the access token.\n   *                  If none is specified, a token will be requested with all of the\n   *                  capabilities of the specified key.\n   *\n   * - clientId:      (optional) a client ID to associate with the token; if not\n   *                  specified, a clientId passed in constructing the Rest interface will be used\n   *\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\n   *                  the system will be queried for a time value to use.\n   */\n  async createTokenRequest(tokenParams: API.TokenParams | null, authOptions: any): Promise<API.TokenRequest> {\n    /* RSA9h: if authOptions passed in, they're used instead of stored, don't merge them */\n    authOptions = authOptions || this.authOptions;\n    tokenParams = tokenParams || Utils.copy<API.TokenParams>(this.tokenParams);\n\n    const key = authOptions.key;\n    if (!key) {\n      throw new ErrorInfo('No key specified', 40101, 403);\n    }\n    const keyParts = key.split(':'),\n      keyName = keyParts[0],\n      keySecret = keyParts[1];\n\n    if (!keySecret) {\n      throw new ErrorInfo('Invalid key specified', 40101, 403);\n    }\n\n    if (tokenParams.clientId === '') {\n      throw new ErrorInfo('clientId can\u2019t be an empty string', 40012, 400);\n    }\n\n    if ('capability' in tokenParams) {\n      tokenParams.capability = c14n(tokenParams.capability);\n    }\n\n    const request: Partial<API.TokenRequest> = Utils.mixin({ keyName: keyName }, tokenParams),\n      clientId = tokenParams.clientId || '',\n      ttl = tokenParams.ttl || '',\n      capability = tokenParams.capability || '';\n\n    if (!request.timestamp) {\n      request.timestamp = await this.getTimestamp(authOptions && authOptions.queryTime);\n    }\n\n    /* nonce */\n    /* NOTE: there is no expectation that the client\n     * specifies the nonce; this is done by the library\n     * However, this can be overridden by the client\n     * simply for testing purposes. */\n    const nonce = request.nonce || (request.nonce = random()),\n      timestamp = request.timestamp;\n\n    const signText =\n      request.keyName + '\\n' + ttl + '\\n' + capability + '\\n' + clientId + '\\n' + timestamp + '\\n' + nonce + '\\n';\n\n    /* mac */\n    /* NOTE: there is no expectation that the client\n     * specifies the mac; this is done by the library\n     * However, this can be overridden by the client\n     * simply for testing purposes. */\n    request.mac = request.mac || hmac(signText, keySecret);\n\n    Logger.logAction(Logger.LOG_MINOR, 'Auth.getTokenRequest()', 'generated signed request');\n\n    return request as API.TokenRequest;\n  }\n\n  /**\n   * Get the auth query params to use for a websocket connection,\n   * based on the current auth parameters\n   */\n  async getAuthParams(): Promise<Record<string, string>> {\n    if (this.method == 'basic') return { key: this.key! };\n    else {\n      let tokenDetails = await this._ensureValidAuthCredentials(false);\n      if (!tokenDetails) {\n        throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');\n      }\n      return { access_token: tokenDetails.token };\n    }\n  }\n\n  /**\n   * Get the authorization header to use for a REST or comet request,\n   * based on the current auth parameters\n   */\n  async getAuthHeaders(): Promise<Record<string, string>> {\n    if (this.method == 'basic') {\n      return { authorization: 'Basic ' + this.basicKey };\n    } else {\n      const tokenDetails = await this._ensureValidAuthCredentials(false);\n      if (!tokenDetails) {\n        throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');\n      }\n      return { authorization: 'Bearer ' + Utils.toBase64(tokenDetails.token) };\n    }\n  }\n\n  /**\n   * Get the current time based on the local clock,\n   * or if the option queryTime is true, return the server time.\n   * The server time offset from the local time is stored so that\n   * only one request to the server to get the time is ever needed\n   */\n  async getTimestamp(queryTime: boolean): Promise<number> {\n    if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {\n      return this.client.time();\n    } else {\n      return this.getTimestampUsingOffset();\n    }\n  }\n\n  getTimestampUsingOffset() {\n    return Date.now() + (this.client.serverTimeOffset || 0);\n  }\n\n  isTimeOffsetSet() {\n    return this.client.serverTimeOffset !== null;\n  }\n\n  _saveBasicOptions(authOptions: AuthOptions) {\n    this.method = 'basic';\n    this.key = authOptions.key;\n    this.basicKey = Utils.toBase64(authOptions.key as string);\n    this.authOptions = authOptions || {};\n    if ('clientId' in authOptions) {\n      this._userSetClientId(authOptions.clientId);\n    }\n  }\n\n  _saveTokenOptions(tokenParams: API.TokenParams | null, authOptions: AuthOptions | null) {\n    this.method = 'token';\n\n    if (tokenParams) {\n      /* We temporarily persist tokenParams.timestamp in case a new token needs\n       * to be requested, then null it out in the callback of\n       * _ensureValidAuthCredentials for RSA10g compliance */\n      this.tokenParams = tokenParams;\n    }\n\n    if (authOptions) {\n      /* normalise */\n      if (authOptions.token) {\n        /* options.token may contain a token string or, for convenience, a TokenDetails */\n        authOptions.tokenDetails =\n          typeof authOptions.token === 'string'\n            ? ({ token: authOptions.token } as API.TokenDetails)\n            : authOptions.token;\n      }\n\n      if (authOptions.tokenDetails) {\n        this.tokenDetails = authOptions.tokenDetails;\n      }\n\n      if ('clientId' in authOptions) {\n        this._userSetClientId(authOptions.clientId);\n      }\n\n      this.authOptions = authOptions;\n    }\n  }\n\n  /* @param forceSupersede: force a new token request even if there's one in\n   * progress, making all pending callbacks wait for the new one */\n  async _ensureValidAuthCredentials(forceSupersede: boolean): Promise<API.TokenDetails> {\n    const token = this.tokenDetails;\n\n    if (token) {\n      if (this._tokenClientIdMismatch(token.clientId)) {\n        /* 403 to trigger a permanently failed client - RSA15c */\n        throw new ErrorInfo(\n          'Mismatch between clientId in token (' + token.clientId + ') and current clientId (' + this.clientId + ')',\n          40102,\n          403,\n        );\n      }\n      /* RSA4b1 -- if we have a server time offset set already, we can\n       * automatically remove expired tokens. Else just use the cached token. If it is\n       * expired Ably will tell us and we'll discard it then. */\n      if (!this.isTimeOffsetSet() || !token.expires || token.expires >= this.getTimestampUsingOffset()) {\n        Logger.logAction(Logger.LOG_MINOR, 'Auth.getToken()', 'using cached token; expires = ' + token.expires);\n        return token;\n      }\n      /* expired, so remove and fallthrough to getting a new one */\n      Logger.logAction(Logger.LOG_MINOR, 'Auth.getToken()', 'deleting expired token');\n      this.tokenDetails = null;\n    }\n\n    const promise = (\n      this.waitingForTokenRequest || (this.waitingForTokenRequest = Multicaster.create())\n    ).createPromise();\n    if (this.currentTokenRequestId !== null && !forceSupersede) {\n      return promise;\n    }\n\n    /* Request a new token */\n    const tokenRequestId = (this.currentTokenRequestId = getTokenRequestId());\n\n    let tokenResponse: API.TokenDetails,\n      caughtError: ErrorInfo | null = null;\n    try {\n      tokenResponse = await this.requestToken(this.tokenParams, this.authOptions);\n    } catch (err) {\n      caughtError = err as ErrorInfo;\n    }\n\n    if ((this.currentTokenRequestId as number) > tokenRequestId) {\n      Logger.logAction(\n        Logger.LOG_MINOR,\n        'Auth._ensureValidAuthCredentials()',\n        'Discarding token request response; overtaken by newer one',\n      );\n      return promise;\n    }\n\n    this.currentTokenRequestId = null;\n    const multicaster = this.waitingForTokenRequest;\n    this.waitingForTokenRequest = null;\n    if (caughtError) {\n      multicaster?.rejectAll(caughtError);\n      return promise;\n    }\n    multicaster?.resolveAll((this.tokenDetails = tokenResponse!));\n\n    return promise;\n  }\n\n  /* User-set: check types, '*' is disallowed, throw any errors */\n  _userSetClientId(clientId: string | undefined) {\n    if (!(typeof clientId === 'string' || clientId === null)) {\n      throw new ErrorInfo('clientId must be either a string or null', 40012, 400);\n    } else if (clientId === '*') {\n      throw new ErrorInfo(\n        'Can\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: \"*\"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: \"*\"}, authOptions)',\n        40012,\n        400,\n      );\n    } else {\n      const err = this._uncheckedSetClientId(clientId);\n      if (err) throw err;\n    }\n  }\n\n  /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */\n  _uncheckedSetClientId(clientId: string | undefined) {\n    if (this._tokenClientIdMismatch(clientId)) {\n      /* Should never happen in normal circumstances as realtime should\n       * recognise mismatch and return an error */\n      const msg = 'Unexpected clientId mismatch: client has ' + this.clientId + ', requested ' + clientId;\n      const err = new ErrorInfo(msg, 40102, 401);\n      Logger.logAction(Logger.LOG_ERROR, 'Auth._uncheckedSetClientId()', msg);\n      return err;\n    } else {\n      /* RSA7a4: if options.clientId is provided and is not\n       * null, it overrides defaultTokenParams.clientId */\n      this.clientId = this.tokenParams.clientId = clientId;\n      return null;\n    }\n  }\n\n  _tokenClientIdMismatch(tokenClientId?: string | null): boolean {\n    return !!(\n      this.clientId &&\n      this.clientId !== '*' &&\n      tokenClientId &&\n      tokenClientId !== '*' &&\n      this.clientId !== tokenClientId\n    );\n  }\n\n  static isTokenErr(error: IPartialErrorInfo) {\n    return error.code && error.code >= 40140 && error.code < 40150;\n  }\n\n  revokeTokens(\n    specifiers: TokenRevocationTargetSpecifier[],\n    options?: TokenRevocationOptions,\n  ): Promise<TokenRevocationResult> {\n    return this.client.rest.revokeTokens(specifiers, options);\n  }\n}\n\nexport default Auth;\n", "import Defaults from 'common/lib/util/defaults';\r\nimport Platform from 'common/platform';\r\nimport BaseRealtime from 'common/lib/client/baserealtime';\r\nimport HttpMethods from '../constants/HttpMethods';\r\nimport BaseClient from '../lib/client/baseclient';\r\nimport ErrorInfo, { IPartialErrorInfo } from '../lib/types/errorinfo';\r\nimport Logger from 'common/lib/util/logger';\r\nimport * as Utils from 'common/lib/util/utils';\r\n\r\nexport type PathParameter = string | ((host: string) => string);\r\nexport type ResponseHeaders = Partial<Record<string, string | string[]>>;\r\nexport type RequestResultError = ErrnoException | IPartialErrorInfo;\r\n\r\n/**\r\n * The `body`, `headers`, `unpacked`, and `statusCode` properties of a `RequestResult` may be populated even if its `error` property is non-null.\r\n */\r\nexport type RequestResult = {\r\n  error: RequestResultError | null;\r\n  body?: unknown;\r\n  headers?: ResponseHeaders;\r\n  unpacked?: boolean;\r\n  statusCode?: number;\r\n};\r\n\r\nexport type RequestParams = Record<string, string> | null;\r\nexport type RequestBody =\r\n  | Buffer // only on Node\r\n  | ArrayBuffer // only on web\r\n  | string;\r\n\r\nexport interface IPlatformHttpStatic {\r\n  new (client?: BaseClient): IPlatformHttp;\r\n  methods: Array<HttpMethods>;\r\n  methodsWithBody: Array<HttpMethods>;\r\n  methodsWithoutBody: Array<HttpMethods>;\r\n}\r\n\r\nexport interface IPlatformHttp {\r\n  supportsAuthHeaders: boolean;\r\n  supportsLinkHeaders: boolean;\r\n\r\n  /**\r\n   * This method should not throw any errors; rather, it should communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\r\n   */\r\n  doUri(\r\n    method: HttpMethods,\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    body: RequestBody | null,\r\n    params: RequestParams,\r\n  ): Promise<RequestResult>;\r\n\r\n  checkConnectivity?: () => Promise<boolean>;\r\n\r\n  /**\r\n   * @param error An error from the {@link RequestResult.error} property of a result returned by {@link doUri}.\r\n   */\r\n  shouldFallback(error: RequestResultError): boolean;\r\n}\r\n\r\nexport function paramString(params: Record<string, any> | null) {\r\n  const paramPairs = [];\r\n  if (params) {\r\n    for (const needle in params) {\r\n      paramPairs.push(needle + '=' + params[needle]);\r\n    }\r\n  }\r\n  return paramPairs.join('&');\r\n}\r\n\r\nexport function appendingParams(uri: string, params: Record<string, any> | null) {\r\n  return uri + (params ? '?' : '') + paramString(params);\r\n}\r\n\r\nfunction logResult(result: RequestResult, method: HttpMethods, uri: string, params: Record<string, string> | null) {\r\n  if (result.error) {\r\n    Logger.logActionNoStrip(\r\n      Logger.LOG_MICRO,\r\n      'Http.' + method + '()',\r\n      'Received Error; ' + appendingParams(uri, params) + '; Error: ' + Utils.inspectError(result.error),\r\n    );\r\n  } else {\r\n    Logger.logActionNoStrip(\r\n      Logger.LOG_MICRO,\r\n      'Http.' + method + '()',\r\n      'Received; ' +\r\n        appendingParams(uri, params) +\r\n        '; Headers: ' +\r\n        paramString(result.headers as Record<string, any>) +\r\n        '; StatusCode: ' +\r\n        result.statusCode +\r\n        '; Body' +\r\n        (Platform.BufferUtils.isBuffer(result.body)\r\n          ? ' (Base64): ' + Platform.BufferUtils.base64Encode(result.body)\r\n          : ': ' + result.body),\r\n    );\r\n  }\r\n}\r\n\r\nfunction logRequest(method: HttpMethods, uri: string, body: RequestBody | null, params: RequestParams) {\r\n  if (Logger.shouldLog(Logger.LOG_MICRO)) {\r\n    Logger.logActionNoStrip(\r\n      Logger.LOG_MICRO,\r\n      'Http.' + method + '()',\r\n      'Sending; ' +\r\n        appendingParams(uri, params) +\r\n        '; Body' +\r\n        (Platform.BufferUtils.isBuffer(body) ? ' (Base64): ' + Platform.BufferUtils.base64Encode(body) : ': ' + body),\r\n    );\r\n  }\r\n}\r\n\r\nexport class Http {\r\n  private readonly platformHttp: IPlatformHttp;\r\n  checkConnectivity?: () => Promise<boolean>;\r\n\r\n  constructor(private readonly client?: BaseClient) {\r\n    this.platformHttp = new Platform.Http(client);\r\n\r\n    this.checkConnectivity = this.platformHttp.checkConnectivity\r\n      ? () => this.platformHttp.checkConnectivity!()\r\n      : undefined;\r\n  }\r\n\r\n  get supportsAuthHeaders() {\r\n    return this.platformHttp.supportsAuthHeaders;\r\n  }\r\n\r\n  get supportsLinkHeaders() {\r\n    return this.platformHttp.supportsLinkHeaders;\r\n  }\r\n\r\n  _getHosts(client: BaseClient) {\r\n    /* If we're a connected realtime client, try the endpoint we're connected\r\n     * to first -- but still have fallbacks, being connected is not an absolute\r\n     * guarantee that a datacenter has free capacity to service REST requests. */\r\n    const connection = (client as BaseRealtime).connection,\r\n      connectionHost = connection && connection.connectionManager.host;\r\n\r\n    if (connectionHost) {\r\n      return [connectionHost].concat(Defaults.getFallbackHosts(client.options));\r\n    }\r\n\r\n    return Defaults.getHosts(client.options);\r\n  }\r\n\r\n  /**\r\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\r\n   */\r\n  async do(\r\n    method: HttpMethods,\r\n    path: PathParameter,\r\n    headers: Record<string, string> | null,\r\n    body: RequestBody | null,\r\n    params: RequestParams,\r\n  ): Promise<RequestResult> {\r\n    try {\r\n      /* Unlike for doUri, the presence of `this.client` here is mandatory, as it's used to generate the hosts */\r\n      const client = this.client;\r\n      if (!client) {\r\n        return { error: new ErrorInfo('http.do called without client', 50000, 500) };\r\n      }\r\n\r\n      const uriFromHost =\r\n        typeof path === 'function'\r\n          ? path\r\n          : function (host: string) {\r\n              return client.baseUri(host) + path;\r\n            };\r\n\r\n      const currentFallback = client._currentFallback;\r\n      if (currentFallback) {\r\n        if (currentFallback.validUntil > Date.now()) {\r\n          /* Use stored fallback */\r\n          const result = await this.doUri(method, uriFromHost(currentFallback.host), headers, body, params);\r\n          if (result.error && this.platformHttp.shouldFallback(result.error as ErrnoException)) {\r\n            /* unstore the fallback and start from the top with the default sequence */\r\n            client._currentFallback = null;\r\n            return this.do(method, path, headers, body, params);\r\n          }\r\n          return result;\r\n        } else {\r\n          /* Fallback expired; remove it and fallthrough to normal sequence */\r\n          client._currentFallback = null;\r\n        }\r\n      }\r\n\r\n      const hosts = this._getHosts(client);\r\n\r\n      /* see if we have one or more than one host */\r\n      if (hosts.length === 1) {\r\n        return this.doUri(method, uriFromHost(hosts[0]), headers, body, params);\r\n      }\r\n\r\n      let tryAHostStartedAt: Date | null = null;\r\n      const tryAHost = async (candidateHosts: Array<string>, persistOnSuccess?: boolean): Promise<RequestResult> => {\r\n        const host = candidateHosts.shift();\r\n        tryAHostStartedAt = tryAHostStartedAt ?? new Date();\r\n        const result = await this.doUri(method, uriFromHost(host as string), headers, body, params);\r\n        if (result.error && this.platformHttp.shouldFallback(result.error as ErrnoException) && candidateHosts.length) {\r\n          // TO3l6\r\n          const elapsedTime = Date.now() - tryAHostStartedAt.getTime();\r\n          if (elapsedTime > client.options.timeouts.httpMaxRetryDuration) {\r\n            return {\r\n              error: new ErrorInfo(\r\n                `Timeout for trying fallback hosts retries. Total elapsed time exceeded the ${client.options.timeouts.httpMaxRetryDuration}ms limit`,\r\n                50003,\r\n                500,\r\n              ),\r\n            };\r\n          }\r\n\r\n          return tryAHost(candidateHosts, true);\r\n        }\r\n        if (persistOnSuccess) {\r\n          /* RSC15f */\r\n          client._currentFallback = {\r\n            host: host as string,\r\n            validUntil: Date.now() + client.options.timeouts.fallbackRetryTimeout,\r\n          };\r\n        }\r\n        return result;\r\n      };\r\n      return tryAHost(hosts);\r\n    } catch (err) {\r\n      // Handle any unexpected error, to ensure we always meet our contract of not throwing any errors\r\n      return { error: new ErrorInfo(`Unexpected error in Http.do: ${Utils.inspectError(err)}`, 500, 50000) };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\r\n   */\r\n  async doUri(\r\n    method: HttpMethods,\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    body: RequestBody | null,\r\n    params: RequestParams,\r\n  ): Promise<RequestResult> {\r\n    try {\r\n      logRequest(method, uri, body, params);\r\n\r\n      const result = await this.platformHttp.doUri(method, uri, headers, body, params);\r\n\r\n      if (Logger.shouldLog(Logger.LOG_MICRO)) {\r\n        logResult(result, method, uri, params);\r\n      }\r\n\r\n      return result;\r\n    } catch (err) {\r\n      // Handle any unexpected error, to ensure we always meet our contract of not throwing any errors\r\n      return { error: new ErrorInfo(`Unexpected error in Http.doUri: ${Utils.inspectError(err)}`, 500, 50000) };\r\n    }\r\n  }\r\n}\r\n\r\nexport interface ErrnoException extends Error {\r\n  errno?: number;\r\n  code?: string;\r\n  path?: string;\r\n  syscall?: string;\r\n  stack?: string;\r\n  statusCode: number;\r\n}\r\n", "import Logger, { LoggerOptions } from '../util/logger';\r\nimport Defaults from '../util/defaults';\r\nimport Auth from './auth';\r\nimport { HttpPaginatedResponse, PaginatedResult } from './paginatedresource';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport Stats from '../types/stats';\r\nimport { Http, RequestParams } from '../../types/http';\r\nimport ClientOptions, { NormalisedClientOptions } from '../../types/ClientOptions';\r\nimport * as API from '../../../../ably';\r\n\r\nimport Platform from '../../platform';\r\nimport { Rest } from './rest';\r\nimport { IUntypedCryptoStatic } from 'common/types/ICryptoStatic';\r\nimport { throwMissingPluginError } from '../util/utils';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport { HTTPRequestImplementations } from 'platform/web/lib/http/http';\r\nimport { FilteredSubscriptions } from './filteredsubscriptions';\r\n\r\ntype BatchResult<T> = API.BatchResult<T>;\r\ntype BatchPublishSpec = API.BatchPublishSpec;\r\ntype BatchPublishSuccessResult = API.BatchPublishSuccessResult;\r\ntype BatchPublishFailureResult = API.BatchPublishFailureResult;\r\ntype BatchPublishResult = BatchResult<BatchPublishSuccessResult | BatchPublishFailureResult>;\r\ntype BatchPresenceSuccessResult = API.BatchPresenceSuccessResult;\r\ntype BatchPresenceFailureResult = API.BatchPresenceFailureResult;\r\ntype BatchPresenceResult = BatchResult<BatchPresenceSuccessResult | BatchPresenceFailureResult>;\r\n\r\n/**\r\n `BaseClient` acts as the base class for all of the client classes exported by the SDK. It is an implementation detail and this class is not advertised publicly.\r\n */\r\nclass BaseClient {\r\n  options: NormalisedClientOptions;\r\n  _currentFallback: null | {\r\n    host: string;\r\n    validUntil: number;\r\n  };\r\n  serverTimeOffset: number | null;\r\n  http: Http;\r\n  auth: Auth;\r\n\r\n  private readonly _rest: Rest | null;\r\n  readonly _Crypto: IUntypedCryptoStatic | null;\r\n  readonly _MsgPack: MsgPack | null;\r\n  // Extra HTTP request implementations available to this client, in addition to those in web\u2019s Http.bundledRequestImplementations\r\n  readonly _additionalHTTPRequestImplementations: HTTPRequestImplementations | null;\r\n  private readonly __FilteredSubscriptions: typeof FilteredSubscriptions | null;\r\n\r\n  constructor(options: ClientOptions) {\r\n    this._additionalHTTPRequestImplementations = options.plugins ?? null;\r\n\r\n    Logger.setLog(options.logLevel, options.logHandler);\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'BaseClient()',\r\n      'initialized with clientOptions ' + Platform.Config.inspect(options),\r\n    );\r\n\r\n    this._MsgPack = options.plugins?.MsgPack ?? null;\r\n    const normalOptions = (this.options = Defaults.normaliseOptions(options, this._MsgPack));\r\n\r\n    /* process options */\r\n    if (normalOptions.key) {\r\n      const keyMatch = normalOptions.key.match(/^([^:\\s]+):([^:.\\s]+)$/);\r\n      if (!keyMatch) {\r\n        const msg = 'invalid key parameter';\r\n        Logger.logAction(Logger.LOG_ERROR, 'BaseClient()', msg);\r\n        throw new ErrorInfo(msg, 40400, 404);\r\n      }\r\n      normalOptions.keyName = keyMatch[1];\r\n      normalOptions.keySecret = keyMatch[2];\r\n    }\r\n\r\n    if ('clientId' in normalOptions) {\r\n      if (!(typeof normalOptions.clientId === 'string' || normalOptions.clientId === null))\r\n        throw new ErrorInfo('clientId must be either a string or null', 40012, 400);\r\n      else if (normalOptions.clientId === '*')\r\n        throw new ErrorInfo(\r\n          'Can\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: \"*\"}})',\r\n          40012,\r\n          400,\r\n        );\r\n    }\r\n\r\n    Logger.logAction(Logger.LOG_MINOR, 'BaseClient()', 'started; version = ' + Defaults.version);\r\n\r\n    this._currentFallback = null;\r\n\r\n    this.serverTimeOffset = null;\r\n    this.http = new Http(this);\r\n    this.auth = new Auth(this, normalOptions);\r\n\r\n    this._rest = options.plugins?.Rest ? new options.plugins.Rest(this) : null;\r\n    this._Crypto = options.plugins?.Crypto ?? null;\r\n    this.__FilteredSubscriptions = options.plugins?.MessageInteractions ?? null;\r\n  }\r\n\r\n  get rest(): Rest {\r\n    if (!this._rest) {\r\n      throwMissingPluginError('Rest');\r\n    }\r\n    return this._rest;\r\n  }\r\n\r\n  get _FilteredSubscriptions(): typeof FilteredSubscriptions {\r\n    if (!this.__FilteredSubscriptions) {\r\n      throwMissingPluginError('MessageInteractions');\r\n    }\r\n    return this.__FilteredSubscriptions;\r\n  }\r\n\r\n  get channels() {\r\n    return this.rest.channels;\r\n  }\r\n\r\n  get push() {\r\n    return this.rest.push;\r\n  }\r\n\r\n  baseUri(host: string) {\r\n    return Defaults.getHttpScheme(this.options) + host + ':' + Defaults.getPort(this.options, false);\r\n  }\r\n\r\n  async stats(params: RequestParams): Promise<PaginatedResult<Stats>> {\r\n    return this.rest.stats(params);\r\n  }\r\n\r\n  async time(params?: RequestParams): Promise<number> {\r\n    return this.rest.time(params);\r\n  }\r\n\r\n  async request(\r\n    method: string,\r\n    path: string,\r\n    version: number,\r\n    params: RequestParams,\r\n    body: unknown,\r\n    customHeaders: Record<string, string>,\r\n  ): Promise<HttpPaginatedResponse<unknown>> {\r\n    return this.rest.request(method, path, version, params, body, customHeaders);\r\n  }\r\n\r\n  batchPublish<T extends BatchPublishSpec | BatchPublishSpec[]>(\r\n    specOrSpecs: T,\r\n  ): Promise<T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[]> {\r\n    return this.rest.batchPublish(specOrSpecs);\r\n  }\r\n\r\n  batchPresence(channels: string[]): Promise<BatchPresenceResult> {\r\n    return this.rest.batchPresence(channels);\r\n  }\r\n\r\n  setLog(logOptions: LoggerOptions): void {\r\n    Logger.setLog(logOptions.level, logOptions.handler);\r\n  }\r\n\r\n  static Platform = Platform;\r\n}\r\n\r\nexport default BaseClient;\r\n", "import { MsgPack } from 'common/types/msgpack';\r\nimport * as Utils from '../util/utils';\r\nimport ErrorInfo, { IConvertibleToErrorInfo } from './errorinfo';\r\n\r\nenum DeviceFormFactor {\r\n  Phone = 'phone',\r\n  Tablet = 'tablet',\r\n  Desktop = 'desktop',\r\n  TV = 'tv',\r\n  Watch = 'watch',\r\n  Car = 'car',\r\n  Embedded = 'embedded',\r\n  Other = 'other',\r\n}\r\n\r\nenum DevicePlatform {\r\n  Android = 'android',\r\n  IOS = 'ios',\r\n  Browser = 'browser',\r\n}\r\n\r\ntype DevicePushState = 'ACTIVE' | 'FAILING' | 'FAILED';\r\n\r\ntype DevicePushDetails = {\r\n  error?: ErrorInfo;\r\n  recipient?: string;\r\n  state?: DevicePushState;\r\n  metadata?: string;\r\n};\r\n\r\nclass DeviceDetails {\r\n  id?: string;\r\n  clientId?: string;\r\n  deviceSecret?: string;\r\n  formFactor?: DeviceFormFactor;\r\n  platform?: DevicePlatform;\r\n  push?: DevicePushDetails;\r\n  metadata?: string;\r\n  deviceIdentityToken?: string;\r\n\r\n  toJSON(): DeviceDetails {\r\n    return {\r\n      id: this.id,\r\n      deviceSecret: this.deviceSecret,\r\n      platform: this.platform,\r\n      formFactor: this.formFactor,\r\n      clientId: this.clientId,\r\n      metadata: this.metadata,\r\n      deviceIdentityToken: this.deviceIdentityToken,\r\n      push: {\r\n        recipient: this.push?.recipient,\r\n        state: this.push?.state,\r\n        error: this.push?.error,\r\n      },\r\n    } as DeviceDetails;\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[DeviceDetails';\r\n    if (this.id) result += '; id=' + this.id;\r\n    if (this.platform) result += '; platform=' + this.platform;\r\n    if (this.formFactor) result += '; formFactor=' + this.formFactor;\r\n    if (this.clientId) result += '; clientId=' + this.clientId;\r\n    if (this.metadata) result += '; metadata=' + this.metadata;\r\n    if (this.deviceIdentityToken) result += '; deviceIdentityToken=' + JSON.stringify(this.deviceIdentityToken);\r\n    if (this.push?.recipient) result += '; push.recipient=' + JSON.stringify(this.push.recipient);\r\n    if (this.push?.state) result += '; push.state=' + this.push.state;\r\n    if (this.push?.error) result += '; push.error=' + JSON.stringify(this.push.error);\r\n    if (this.push?.metadata) result += '; push.metadata=' + this.push.metadata;\r\n    result += ']';\r\n    return result;\r\n  }\r\n\r\n  static toRequestBody(body: unknown, MsgPack: MsgPack | null, format?: Utils.Format) {\r\n    return Utils.encodeBody(body, MsgPack, format);\r\n  }\r\n\r\n  static fromResponseBody(\r\n    body: Array<Record<string, unknown>> | Record<string, unknown>,\r\n    MsgPack: MsgPack | null,\r\n    format?: Utils.Format,\r\n  ): DeviceDetails | DeviceDetails[] {\r\n    if (format) {\r\n      body = Utils.decodeBody(body, MsgPack, format);\r\n    }\r\n\r\n    if (Array.isArray(body)) {\r\n      return DeviceDetails.fromValuesArray(body);\r\n    } else {\r\n      return DeviceDetails.fromValues(body);\r\n    }\r\n  }\r\n\r\n  static fromValues(values: Record<string, unknown>): DeviceDetails {\r\n    values.error = values.error && ErrorInfo.fromValues(values.error as IConvertibleToErrorInfo);\r\n    return Object.assign(new DeviceDetails(), values);\r\n  }\r\n\r\n  static fromValuesArray(values: Array<Record<string, unknown>>): DeviceDetails[] {\r\n    const count = values.length,\r\n      result = new Array(count);\r\n    for (let i = 0; i < count; i++) result[i] = DeviceDetails.fromValues(values[i]);\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default DeviceDetails;\r\n", "import Platform from '../../platform';\r\nimport * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport Auth from './auth';\r\nimport HttpMethods from '../../constants/HttpMethods';\r\nimport ErrorInfo, { IPartialErrorInfo, PartialErrorInfo } from '../types/errorinfo';\r\nimport BaseClient from './baseclient';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport { RequestBody, ResponseHeaders, appendingParams as urlFromPathAndParams, paramString } from 'common/types/http';\r\nimport httpStatusCodes from '../../constants/HttpStatusCodes';\r\n\r\nasync function withAuthDetails<T>(\r\n  client: BaseClient,\r\n  headers: ResponseHeaders | undefined,\r\n  params: Record<string, any>,\r\n  opCallback: Function,\r\n): Promise<ResourceResult<T>> {\r\n  if (client.http.supportsAuthHeaders) {\r\n    const authHeaders = await client.auth.getAuthHeaders();\r\n    return opCallback(Utils.mixin(authHeaders!, headers), params);\r\n  } else {\r\n    const authParams = await client.auth.getAuthParams();\r\n    return opCallback(headers, Utils.mixin(authParams!, params));\r\n  }\r\n}\r\n\r\nfunction unenvelope<T>(\r\n  result: ResourceResult<T>,\r\n  MsgPack: MsgPack | null,\r\n  format: Utils.Format | null,\r\n): ResourceResult<T> {\r\n  if (result.err && !result.body) {\r\n    return { err: result.err };\r\n  }\r\n\r\n  if (result.statusCode === httpStatusCodes.NoContent) {\r\n    return { ...result, body: [] as any, unpacked: true };\r\n  }\r\n\r\n  let body = result.body;\r\n\r\n  if (!result.unpacked) {\r\n    try {\r\n      body = Utils.decodeBody(body, MsgPack, format);\r\n    } catch (e) {\r\n      if (Utils.isErrorInfoOrPartialErrorInfo(e)) {\r\n        return { err: e };\r\n      } else {\r\n        return { err: new PartialErrorInfo(Utils.inspectError(e), null) };\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!body) {\r\n    return { err: new PartialErrorInfo('unenvelope(): Response body is missing', null) };\r\n  }\r\n\r\n  const { statusCode: wrappedStatusCode, response, headers: wrappedHeaders } = body as Record<string, any>;\r\n\r\n  if (wrappedStatusCode === undefined) {\r\n    /* Envelope already unwrapped by the transport */\r\n    return { ...result, body, unpacked: true };\r\n  }\r\n\r\n  if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {\r\n    /* handle wrapped errors */\r\n    let wrappedErr = (response && response.error) || result.err;\r\n    if (!wrappedErr) {\r\n      wrappedErr = new Error('Error in unenveloping ' + body);\r\n      wrappedErr.statusCode = wrappedStatusCode;\r\n    }\r\n    return { err: wrappedErr, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\r\n  }\r\n\r\n  return { err: result.err, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\r\n}\r\n\r\nfunction logResult<T>(result: ResourceResult<T>, method: HttpMethods, path: string, params: Record<string, string>) {\r\n  if (result.err) {\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'Resource.' + method + '()',\r\n      'Received Error; ' + urlFromPathAndParams(path, params) + '; Error: ' + Utils.inspectError(result.err),\r\n    );\r\n  } else {\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'Resource.' + method + '()',\r\n      'Received; ' +\r\n        urlFromPathAndParams(path, params) +\r\n        '; Headers: ' +\r\n        paramString(result.headers as Record<string, any>) +\r\n        '; StatusCode: ' +\r\n        result.statusCode +\r\n        '; Body: ' +\r\n        (Platform.BufferUtils.isBuffer(result.body)\r\n          ? ' (Base64): ' + Platform.BufferUtils.base64Encode(result.body)\r\n          : ': ' + Platform.Config.inspect(result.body)),\r\n    );\r\n  }\r\n}\r\n\r\nexport interface ResourceResponse<T> {\r\n  body?: T;\r\n  headers?: ResponseHeaders;\r\n  unpacked?: boolean;\r\n  statusCode?: number;\r\n}\r\n\r\nexport interface ResourceResult<T> extends ResourceResponse<T> {\r\n  /**\r\n   * Any error returned by the underlying HTTP client.\r\n   */\r\n  err: IPartialErrorInfo | null;\r\n}\r\n\r\nclass Resource {\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async get<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async get<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async get<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Get, client, path, null, headers, params, envelope, throwError ?? false);\r\n  }\r\n\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async delete<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async delete<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async delete<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Delete, client, path, null, headers, params, envelope, throwError);\r\n  }\r\n\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async post<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async post<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async post<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Post, client, path, body, headers, params, envelope, throwError);\r\n  }\r\n\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async patch<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async patch<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async patch<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Patch, client, path, body, headers, params, envelope, throwError);\r\n  }\r\n\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async put<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async put<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async put<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Put, client, path, body, headers, params, envelope, throwError);\r\n  }\r\n\r\n  static async do<T>(\r\n    method: HttpMethods,\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    if (envelope) {\r\n      (params = params || {})['envelope'] = envelope;\r\n    }\r\n\r\n    async function doRequest(\r\n      this: any,\r\n      headers: Record<string, string>,\r\n      params: Record<string, any>,\r\n    ): Promise<ResourceResult<T>> {\r\n      if (Logger.shouldLog(Logger.LOG_MICRO)) {\r\n        let decodedBody = body;\r\n        if (headers['content-type']?.indexOf('msgpack') > 0) {\r\n          try {\r\n            if (!client._MsgPack) {\r\n              Utils.throwMissingPluginError('MsgPack');\r\n            }\r\n            decodedBody = client._MsgPack.decode(body as Buffer);\r\n          } catch (decodeErr) {\r\n            Logger.logAction(\r\n              Logger.LOG_MICRO,\r\n              'Resource.' + method + '()',\r\n              'Sending MsgPack Decoding Error: ' + Utils.inspectError(decodeErr),\r\n            );\r\n          }\r\n        }\r\n        Logger.logAction(\r\n          Logger.LOG_MICRO,\r\n          'Resource.' + method + '()',\r\n          'Sending; ' + urlFromPathAndParams(path, params) + '; Body: ' + decodedBody,\r\n        );\r\n      }\r\n\r\n      const httpResult = await client.http.do(method, path, headers, body, params);\r\n\r\n      if (httpResult.error && Auth.isTokenErr(httpResult.error as ErrorInfo)) {\r\n        /* token has expired, so get a new one */\r\n        await client.auth.authorize(null, null);\r\n        /* retry ... */\r\n        return withAuthDetails(client, headers, params, doRequest);\r\n      }\r\n\r\n      return {\r\n        err: httpResult.error as ErrorInfo,\r\n        body: httpResult.body as T | undefined,\r\n        headers: httpResult.headers,\r\n        unpacked: httpResult.unpacked,\r\n        statusCode: httpResult.statusCode,\r\n      };\r\n    }\r\n\r\n    let result = await withAuthDetails<T>(client, headers, params, doRequest);\r\n\r\n    if (envelope) {\r\n      result = unenvelope(result, client._MsgPack, envelope);\r\n    }\r\n\r\n    if (Logger.shouldLog(Logger.LOG_MICRO)) {\r\n      logResult(result, method, path, params);\r\n    }\r\n\r\n    if (throwError) {\r\n      if (result.err) {\r\n        throw result.err;\r\n      } else {\r\n        const response: Omit<ResourceResult<T>, 'err'> & Pick<Partial<ResourceResult<T>>, 'err'> = { ...result };\r\n        delete response.err;\r\n        return response;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default Resource;\r\n", "import * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport Resource, { ResourceResult } from './resource';\r\nimport { IPartialErrorInfo } from '../types/errorinfo';\r\nimport BaseClient from './baseclient';\r\nimport { RequestBody, ResponseHeaders } from 'common/types/http';\r\nimport HttpStatusCodes from '../../constants/HttpStatusCodes';\r\n\r\nexport type BodyHandler = (body: unknown, headers: ResponseHeaders, unpacked?: boolean) => Promise<any>;\r\n\r\nfunction getRelParams(linkUrl: string) {\r\n  const urlMatch = linkUrl.match(/^\\.\\/(\\w+)\\?(.*)$/);\r\n  return urlMatch && urlMatch[2] && Utils.parseQueryString(urlMatch[2]);\r\n}\r\n\r\nfunction parseRelLinks(linkHeader: string | Array<string>) {\r\n  if (typeof linkHeader == 'string') linkHeader = linkHeader.split(',');\r\n\r\n  const relParams: Record<string, Record<string, string>> = {};\r\n  for (let i = 0; i < linkHeader.length; i++) {\r\n    const linkMatch = linkHeader[i].match(/^\\s*<(.+)>;\\s*rel=\"(\\w+)\"$/);\r\n    if (linkMatch) {\r\n      const params = getRelParams(linkMatch[1]);\r\n      if (params) relParams[linkMatch[2]] = params;\r\n    }\r\n  }\r\n  return relParams;\r\n}\r\n\r\nfunction returnErrOnly(err: IPartialErrorInfo, body: unknown, useHPR?: boolean) {\r\n  /* If using httpPaginatedResponse, errors from Ably are returned as part of\r\n   * the HPR, only throw `err` for network errors etc. which don't\r\n   * return a body and/or have no ably-originated error code (non-numeric\r\n   * error codes originate from node) */\r\n  return !(useHPR && (body || typeof err.code === 'number'));\r\n}\r\n\r\nclass PaginatedResource {\r\n  client: BaseClient;\r\n  path: string;\r\n  headers: Record<string, string>;\r\n  envelope: Utils.Format | null;\r\n  bodyHandler: BodyHandler;\r\n  useHttpPaginatedResponse: boolean;\r\n\r\n  constructor(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    envelope: Utils.Format | undefined,\r\n    bodyHandler: BodyHandler,\r\n    useHttpPaginatedResponse?: boolean,\r\n  ) {\r\n    this.client = client;\r\n    this.path = path;\r\n    this.headers = headers;\r\n    this.envelope = envelope ?? null;\r\n    this.bodyHandler = bodyHandler;\r\n    this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;\r\n  }\r\n\r\n  async get<T1, T2>(params: Record<string, T2>): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.get<T1>(this.client, this.path, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async delete<T1, T2>(params: Record<string, T2>): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.delete<T1>(this.client, this.path, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async post<T1, T2>(params: Record<string, T2>, body: RequestBody | null): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.post<T1>(this.client, this.path, body, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async put<T1, T2>(params: Record<string, T2>, body: RequestBody | null): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.put<T1>(this.client, this.path, body, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async patch<T1, T2>(params: Record<string, T2>, body: RequestBody | null): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.patch<T1>(this.client, this.path, body, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async handlePage<T>(result: ResourceResult<T>): Promise<PaginatedResult<T>> {\r\n    if (result.err && returnErrOnly(result.err, result.body, this.useHttpPaginatedResponse)) {\r\n      Logger.logAction(\r\n        Logger.LOG_ERROR,\r\n        'PaginatedResource.handlePage()',\r\n        'Unexpected error getting resource: err = ' + Utils.inspectError(result.err),\r\n      );\r\n      throw result.err;\r\n    }\r\n\r\n    let items, linkHeader, relParams;\r\n\r\n    try {\r\n      items =\r\n        result.statusCode == HttpStatusCodes.NoContent\r\n          ? []\r\n          : await this.bodyHandler(result.body, result.headers || {}, result.unpacked);\r\n    } catch (e) {\r\n      /* If we got an error, the failure to parse the body is almost certainly\r\n       * due to that, so throw that in preference over the parse error */\r\n      throw result.err || e;\r\n    }\r\n\r\n    if (result.headers && (linkHeader = result.headers['Link'] || result.headers['link'])) {\r\n      relParams = parseRelLinks(linkHeader);\r\n    }\r\n\r\n    if (this.useHttpPaginatedResponse) {\r\n      return new HttpPaginatedResponse(\r\n        this,\r\n        items,\r\n        result.headers || {},\r\n        result.statusCode as number,\r\n        relParams,\r\n        result.err,\r\n      );\r\n    } else {\r\n      return new PaginatedResult(this, items, relParams);\r\n    }\r\n  }\r\n}\r\n\r\nexport class PaginatedResult<T> {\r\n  resource: PaginatedResource;\r\n  items: T[];\r\n  first?: () => Promise<PaginatedResult<T>>;\r\n  next?: () => Promise<PaginatedResult<T> | null>;\r\n  current?: () => Promise<PaginatedResult<T>>;\r\n  hasNext?: () => boolean;\r\n  isLast?: () => boolean;\r\n\r\n  constructor(resource: PaginatedResource, items: T[], relParams?: Record<string, any>) {\r\n    this.resource = resource;\r\n    this.items = items;\r\n\r\n    const self = this;\r\n    if (relParams) {\r\n      if ('first' in relParams) {\r\n        this.first = async function () {\r\n          return self.get(relParams.first);\r\n        };\r\n      }\r\n      if ('current' in relParams) {\r\n        this.current = async function () {\r\n          return self.get(relParams.current);\r\n        };\r\n      }\r\n      this.next = async function () {\r\n        if ('next' in relParams) {\r\n          return self.get(relParams.next);\r\n        } else {\r\n          return null;\r\n        }\r\n      };\r\n\r\n      this.hasNext = function () {\r\n        return 'next' in relParams;\r\n      };\r\n      this.isLast = () => {\r\n        return !this.hasNext?.();\r\n      };\r\n    }\r\n  }\r\n\r\n  /* We assume that only the initial request can be a POST, and that accessing\r\n   * the rest of a multipage set of results can always be done with GET */\r\n  async get(params: any): Promise<PaginatedResult<T>> {\r\n    const res = this.resource;\r\n    const result = await Resource.get<T>(res.client, res.path, res.headers, params, res.envelope, false);\r\n    return res.handlePage(result);\r\n  }\r\n}\r\n\r\nexport class HttpPaginatedResponse<T> extends PaginatedResult<T> {\r\n  statusCode: number;\r\n  success: boolean;\r\n  headers: ResponseHeaders;\r\n  errorCode?: number | null;\r\n  errorMessage?: string | null;\r\n\r\n  constructor(\r\n    resource: PaginatedResource,\r\n    items: T[],\r\n    headers: ResponseHeaders,\r\n    statusCode: number,\r\n    relParams: any,\r\n    err: IPartialErrorInfo | null,\r\n  ) {\r\n    super(resource, items, relParams);\r\n    this.statusCode = statusCode;\r\n    this.success = statusCode < 300 && statusCode >= 200;\r\n    this.headers = headers;\r\n    this.errorCode = err && err.code;\r\n    this.errorMessage = err && err.message;\r\n  }\r\n\r\n  toJSON() {\r\n    return {\r\n      items: this.items,\r\n      statusCode: this.statusCode,\r\n      success: this.success,\r\n      headers: this.headers,\r\n      errorCode: this.errorCode,\r\n      errorMessage: this.errorMessage,\r\n    };\r\n  }\r\n}\r\n\r\nexport default PaginatedResource;\r\n", "import { MsgPack } from 'common/types/msgpack';\r\nimport * as Utils from '../util/utils';\r\n\r\ntype PushChannelSubscriptionObject = {\r\n  channel?: string;\r\n  deviceId?: string;\r\n  clientId?: string;\r\n};\r\n\r\nclass PushChannelSubscription {\r\n  channel?: string;\r\n  deviceId?: string;\r\n  clientId?: string;\r\n\r\n  /**\r\n   * Overload toJSON() to intercept JSON.stringify()\r\n   * @return {*}\r\n   */\r\n  toJSON(): PushChannelSubscriptionObject {\r\n    return {\r\n      channel: this.channel,\r\n      deviceId: this.deviceId,\r\n      clientId: this.clientId,\r\n    };\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[PushChannelSubscription';\r\n    if (this.channel) result += '; channel=' + this.channel;\r\n    if (this.deviceId) result += '; deviceId=' + this.deviceId;\r\n    if (this.clientId) result += '; clientId=' + this.clientId;\r\n    result += ']';\r\n    return result;\r\n  }\r\n\r\n  static toRequestBody = Utils.encodeBody;\r\n\r\n  static fromResponseBody(\r\n    body: Array<Record<string, unknown>> | Record<string, unknown>,\r\n    MsgPack: MsgPack | null,\r\n    format?: Utils.Format,\r\n  ): PushChannelSubscription | PushChannelSubscription[] {\r\n    if (format) {\r\n      body = Utils.decodeBody(body, MsgPack, format) as Record<string, unknown>;\r\n    }\r\n\r\n    if (Array.isArray(body)) {\r\n      return PushChannelSubscription.fromValuesArray(body);\r\n    } else {\r\n      return PushChannelSubscription.fromValues(body);\r\n    }\r\n  }\r\n\r\n  static fromValues(values: Record<string, unknown>): PushChannelSubscription {\r\n    return Object.assign(new PushChannelSubscription(), values);\r\n  }\r\n\r\n  static fromValuesArray(values: Array<Record<string, unknown>>): PushChannelSubscription[] {\r\n    const count = values.length,\r\n      result = new Array(count);\r\n    for (let i = 0; i < count; i++) result[i] = PushChannelSubscription.fromValues(values[i]);\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default PushChannelSubscription;\r\n", "import * as Utils from '../util/utils';\r\nimport DeviceDetails from '../types/devicedetails';\r\nimport Resource from './resource';\r\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport PushChannelSubscription from '../types/pushchannelsubscription';\r\nimport BaseClient from './baseclient';\r\nimport Defaults from '../util/defaults';\r\n\r\nclass Push {\r\n  client: BaseClient;\r\n  admin: Admin;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n    this.admin = new Admin(client);\r\n  }\r\n}\r\n\r\nclass Admin {\r\n  client: BaseClient;\r\n  deviceRegistrations: DeviceRegistrations;\r\n  channelSubscriptions: ChannelSubscriptions;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n    this.deviceRegistrations = new DeviceRegistrations(client);\r\n    this.channelSubscriptions = new ChannelSubscriptions(client);\r\n  }\r\n\r\n  async publish(recipient: any, payload: any): Promise<void> {\r\n    const client = this.client;\r\n    const format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(client.options, { format }),\r\n      params = {};\r\n    const body = Utils.mixin({ recipient: recipient }, payload);\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    const requestBody = Utils.encodeBody(body, client._MsgPack, format);\r\n    await Resource.post(client, '/push/publish', requestBody, headers, params, null, true);\r\n  }\r\n}\r\n\r\nclass DeviceRegistrations {\r\n  client: BaseClient;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n  }\r\n\r\n  async save(device: any): Promise<DeviceDetails> {\r\n    const client = this.client;\r\n    const body = DeviceDetails.fromValues(device);\r\n    const format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(client.options, { format }),\r\n      params = {};\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    const requestBody = Utils.encodeBody(body, client._MsgPack, format);\r\n    const response = await Resource.put(\r\n      client,\r\n      '/push/deviceRegistrations/' + encodeURIComponent(device.id),\r\n      requestBody,\r\n      headers,\r\n      params,\r\n      null,\r\n      true,\r\n    );\r\n\r\n    return DeviceDetails.fromResponseBody(\r\n      response.body as Record<string, unknown>,\r\n      client._MsgPack,\r\n      response.unpacked ? undefined : format,\r\n    ) as DeviceDetails;\r\n  }\r\n\r\n  async get(deviceIdOrDetails: any): Promise<DeviceDetails> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format }),\r\n      deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\r\n\r\n    if (typeof deviceId !== 'string' || !deviceId.length) {\r\n      throw new ErrorInfo(\r\n        'First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails',\r\n        40000,\r\n        400,\r\n      );\r\n    }\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    const response = await Resource.get(\r\n      client,\r\n      '/push/deviceRegistrations/' + encodeURIComponent(deviceId),\r\n      headers,\r\n      {},\r\n      null,\r\n      true,\r\n    );\r\n\r\n    return DeviceDetails.fromResponseBody(\r\n      response.body as Record<string, unknown>,\r\n      client._MsgPack,\r\n      response.unpacked ? undefined : format,\r\n    ) as DeviceDetails;\r\n  }\r\n\r\n  async list(params: any): Promise<PaginatedResult<unknown>> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    return new PaginatedResource(client, '/push/deviceRegistrations', headers, envelope, async function (\r\n      body,\r\n      headers,\r\n      unpacked,\r\n    ) {\r\n      return DeviceDetails.fromResponseBody(\r\n        body as Record<string, unknown>[],\r\n        client._MsgPack,\r\n        unpacked ? undefined : format,\r\n      );\r\n    }).get(params);\r\n  }\r\n\r\n  async remove(deviceIdOrDetails: any): Promise<void> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format }),\r\n      params = {},\r\n      deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\r\n\r\n    if (typeof deviceId !== 'string' || !deviceId.length) {\r\n      throw new ErrorInfo(\r\n        'First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails',\r\n        40000,\r\n        400,\r\n      );\r\n    }\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    await Resource['delete'](\r\n      client,\r\n      '/push/deviceRegistrations/' + encodeURIComponent(deviceId),\r\n      headers,\r\n      params,\r\n      null,\r\n      true,\r\n    );\r\n  }\r\n\r\n  async removeWhere(params: any): Promise<void> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    await Resource['delete'](client, '/push/deviceRegistrations', headers, params, null, true);\r\n  }\r\n}\r\n\r\nclass ChannelSubscriptions {\r\n  client: BaseClient;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n  }\r\n\r\n  async save(subscription: Record<string, unknown>): Promise<PushChannelSubscription> {\r\n    const client = this.client;\r\n    const body = PushChannelSubscription.fromValues(subscription);\r\n    const format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(client.options, { format }),\r\n      params = {};\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    const requestBody = Utils.encodeBody(body, client._MsgPack, format);\r\n    const response = await Resource.post(\r\n      client,\r\n      '/push/channelSubscriptions',\r\n      requestBody,\r\n      headers,\r\n      params,\r\n      null,\r\n      true,\r\n    );\r\n\r\n    return PushChannelSubscription.fromResponseBody(\r\n      response.body as Record<string, any>,\r\n      client._MsgPack,\r\n      response.unpacked ? undefined : format,\r\n    ) as PushChannelSubscription;\r\n  }\r\n\r\n  async list(params: any): Promise<PaginatedResult<unknown>> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    return new PaginatedResource(client, '/push/channelSubscriptions', headers, envelope, async function (\r\n      body,\r\n      headers,\r\n      unpacked,\r\n    ) {\r\n      return PushChannelSubscription.fromResponseBody(\r\n        body as Record<string, unknown>[],\r\n        client._MsgPack,\r\n        unpacked ? undefined : format,\r\n      );\r\n    }).get(params);\r\n  }\r\n\r\n  async removeWhere(params: any): Promise<void> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    await Resource['delete'](client, '/push/channelSubscriptions', headers, params, null, true);\r\n  }\r\n\r\n  /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */\r\n  remove = ChannelSubscriptions.prototype.removeWhere;\r\n\r\n  async listChannels(params: any): Promise<PaginatedResult<unknown>> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    return new PaginatedResource(client, '/push/channels', headers, envelope, async function (body, headers, unpacked) {\r\n      const parsedBody = (\r\n        !unpacked && format ? Utils.decodeBody(body, client._MsgPack, format) : body\r\n      ) as Array<string>;\r\n\r\n      for (let i = 0; i < parsedBody.length; i++) {\r\n        parsedBody[i] = String(parsedBody[i]);\r\n      }\r\n      return parsedBody;\r\n    }).get(params);\r\n  }\r\n}\r\n\r\nexport default Push;\r\n", "import Platform from 'common/platform';\nimport Logger from '../util/logger';\nimport ErrorInfo from './errorinfo';\nimport { ChannelOptions } from '../../types/channel';\nimport PresenceMessage from './presencemessage';\nimport * as Utils from '../util/utils';\nimport { Bufferlike as BrowserBufferlike } from '../../../platform/web/lib/util/bufferutils';\nimport * as API from '../../../../ably';\nimport { IUntypedCryptoStatic } from 'common/types/ICryptoStatic';\nimport { MsgPack } from 'common/types/msgpack';\n\nexport type CipherOptions = {\n  channelCipher: {\n    encrypt: Function;\n    algorithm: 'aes';\n  };\n  cipher?: {\n    channelCipher: {\n      encrypt: Function;\n      algorithm: 'aes';\n    };\n  };\n};\n\nexport type EncodingDecodingContext = {\n  channelOptions: ChannelOptions;\n  plugins: {\n    vcdiff?: {\n      decode: (delta: Uint8Array, source: Uint8Array) => Uint8Array;\n    };\n  };\n  baseEncodedPreviousPayload?: Buffer | BrowserBufferlike;\n};\n\nfunction normaliseContext(context: CipherOptions | EncodingDecodingContext | ChannelOptions): EncodingDecodingContext {\n  if (!context || !(context as EncodingDecodingContext).channelOptions) {\n    return {\n      channelOptions: context as ChannelOptions,\n      plugins: {},\n      baseEncodedPreviousPayload: undefined,\n    };\n  }\n  return context as EncodingDecodingContext;\n}\n\nfunction normalizeCipherOptions(\n  Crypto: IUntypedCryptoStatic | null,\n  options: API.ChannelOptions | null,\n): ChannelOptions {\n  if (options && options.cipher) {\n    if (!Crypto) Utils.throwMissingPluginError('Crypto');\n    const cipher = Crypto.getCipher(options.cipher);\n    return {\n      cipher: cipher.cipherParams,\n      channelCipher: cipher.cipher,\n    };\n  }\n  return options ?? {};\n}\n\nfunction getMessageSize(msg: Message) {\n  let size = 0;\n  if (msg.name) {\n    size += msg.name.length;\n  }\n  if (msg.clientId) {\n    size += msg.clientId.length;\n  }\n  if (msg.extras) {\n    size += JSON.stringify(msg.extras).length;\n  }\n  if (msg.data) {\n    size += Utils.dataSizeBytes(msg.data);\n  }\n  return size;\n}\n\nexport async function fromEncoded(\n  Crypto: IUntypedCryptoStatic | null,\n  encoded: unknown,\n  inputOptions?: API.ChannelOptions,\n): Promise<Message> {\n  const msg = fromValues(encoded);\n  const options = normalizeCipherOptions(Crypto, inputOptions ?? null);\n  /* if decoding fails at any point, catch and return the message decoded to\n   * the fullest extent possible */\n  try {\n    await decode(msg, options);\n  } catch (e) {\n    Logger.logAction(Logger.LOG_ERROR, 'Message.fromEncoded()', (e as Error).toString());\n  }\n  return msg;\n}\n\nexport async function fromEncodedArray(\n  Crypto: IUntypedCryptoStatic | null,\n  encodedArray: Array<unknown>,\n  options?: API.ChannelOptions,\n): Promise<Message[]> {\n  return Promise.all(\n    encodedArray.map(function (encoded) {\n      return fromEncoded(Crypto, encoded, options);\n    }),\n  );\n}\n\nasync function encrypt<T extends Message | PresenceMessage>(msg: T, options: CipherOptions): Promise<T> {\n  let data = msg.data,\n    encoding = msg.encoding,\n    cipher = options.channelCipher;\n\n  encoding = encoding ? encoding + '/' : '';\n  if (!Platform.BufferUtils.isBuffer(data)) {\n    data = Platform.BufferUtils.utf8Encode(String(data));\n    encoding = encoding + 'utf-8/';\n  }\n  const ciphertext = await cipher.encrypt(data);\n  msg.data = ciphertext;\n  msg.encoding = encoding + 'cipher+' + cipher.algorithm;\n  return msg;\n}\n\nexport async function encode<T extends Message | PresenceMessage>(msg: T, options: CipherOptions): Promise<T> {\n  const data = msg.data;\n  const nativeDataType =\n    typeof data == 'string' || Platform.BufferUtils.isBuffer(data) || data === null || data === undefined;\n\n  if (!nativeDataType) {\n    if (Utils.isObject(data) || Array.isArray(data)) {\n      msg.data = JSON.stringify(data);\n      msg.encoding = msg.encoding ? msg.encoding + '/json' : 'json';\n    } else {\n      throw new ErrorInfo('Data type is unsupported', 40013, 400);\n    }\n  }\n\n  if (options != null && options.cipher) {\n    return encrypt(msg, options);\n  } else {\n    return msg;\n  }\n}\n\nexport async function encodeArray(messages: Array<Message>, options: CipherOptions): Promise<Array<Message>> {\n  return Promise.all(messages.map((message) => encode(message, options)));\n}\n\nexport const serialize = Utils.encodeBody;\n\nexport async function decode(\n  message: Message | PresenceMessage,\n  inputContext: CipherOptions | EncodingDecodingContext | ChannelOptions,\n): Promise<void> {\n  const context = normaliseContext(inputContext);\n\n  let lastPayload = message.data;\n  const encoding = message.encoding;\n  if (encoding) {\n    const xforms = encoding.split('/');\n    let lastProcessedEncodingIndex,\n      encodingsToProcess = xforms.length,\n      data = message.data;\n\n    let xform = '';\n    try {\n      while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {\n        // eslint-disable-next-line security/detect-unsafe-regex\n        const match = xforms[--encodingsToProcess].match(/([-\\w]+)(\\+([\\w-]+))?/);\n        if (!match) break;\n        xform = match[1];\n        switch (xform) {\n          case 'base64':\n            data = Platform.BufferUtils.base64Decode(String(data));\n            if (lastProcessedEncodingIndex == xforms.length) {\n              lastPayload = data;\n            }\n            continue;\n          case 'utf-8':\n            data = Platform.BufferUtils.utf8Decode(data);\n            continue;\n          case 'json':\n            data = JSON.parse(data);\n            continue;\n          case 'cipher':\n            if (\n              context.channelOptions != null &&\n              context.channelOptions.cipher &&\n              context.channelOptions.channelCipher\n            ) {\n              const xformAlgorithm = match[3],\n                cipher = context.channelOptions.channelCipher;\n              /* don't attempt to decrypt unless the cipher params are compatible */\n              if (xformAlgorithm != cipher.algorithm) {\n                throw new Error('Unable to decrypt message with given cipher; incompatible cipher params');\n              }\n              data = await cipher.decrypt(data);\n              continue;\n            } else {\n              throw new Error('Unable to decrypt message; not an encrypted channel');\n            }\n          case 'vcdiff':\n            if (!context.plugins || !context.plugins.vcdiff) {\n              throw new ErrorInfo('Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)', 40019, 400);\n            }\n            if (typeof Uint8Array === 'undefined') {\n              throw new ErrorInfo(\n                'Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)',\n                40020,\n                400,\n              );\n            }\n            try {\n              let deltaBase = context.baseEncodedPreviousPayload;\n              if (typeof deltaBase === 'string') {\n                deltaBase = Platform.BufferUtils.utf8Encode(deltaBase);\n              }\n\n              // vcdiff expects Uint8Arrays, can't copy with ArrayBuffers.\n              const deltaBaseBuffer = Platform.BufferUtils.toBuffer(deltaBase as Buffer);\n              data = Platform.BufferUtils.toBuffer(data);\n\n              data = Platform.BufferUtils.arrayBufferViewToBuffer(context.plugins.vcdiff.decode(data, deltaBaseBuffer));\n              lastPayload = data;\n            } catch (e) {\n              throw new ErrorInfo('Vcdiff delta decode failed with ' + e, 40018, 400);\n            }\n            continue;\n          default:\n            throw new Error('Unknown encoding');\n        }\n      }\n    } catch (e) {\n      const err = e as ErrorInfo;\n      throw new ErrorInfo(\n        'Error processing the ' + xform + ' encoding, decoder returned \u2018' + err.message + '\u2019',\n        err.code || 40013,\n        400,\n      );\n    } finally {\n      message.encoding =\n        (lastProcessedEncodingIndex as number) <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join('/');\n      message.data = data;\n    }\n  }\n  context.baseEncodedPreviousPayload = lastPayload;\n}\n\nexport async function fromResponseBody(\n  body: Array<Message>,\n  options: ChannelOptions | EncodingDecodingContext,\n  MsgPack: MsgPack | null,\n  format?: Utils.Format,\n): Promise<Message[]> {\n  if (format) {\n    body = Utils.decodeBody(body, MsgPack, format);\n  }\n\n  for (let i = 0; i < body.length; i++) {\n    const msg = (body[i] = fromValues(body[i]));\n    try {\n      await decode(msg, options);\n    } catch (e) {\n      Logger.logAction(Logger.LOG_ERROR, 'Message.fromResponseBody()', (e as Error).toString());\n    }\n  }\n  return body;\n}\n\nexport function fromValues(values: unknown): Message {\n  return Object.assign(new Message(), values);\n}\n\nexport function fromValuesArray(values: unknown[]): Message[] {\n  const count = values.length,\n    result = new Array(count);\n  for (let i = 0; i < count; i++) result[i] = fromValues(values[i]);\n  return result;\n}\n\n/* This should be called on encode()d (and encrypt()d) Messages (as it\n * assumes the data is a string or buffer) */\nexport function getMessagesSize(messages: Message[]): number {\n  let msg,\n    total = 0;\n  for (let i = 0; i < messages.length; i++) {\n    msg = messages[i];\n    total += msg.size || (msg.size = getMessageSize(msg));\n  }\n  return total;\n}\n\nclass Message {\n  name?: string;\n  id?: string;\n  timestamp?: number;\n  clientId?: string;\n  connectionId?: string;\n  connectionKey?: string;\n  data?: any;\n  encoding?: string | null;\n  extras?: any;\n  size?: number;\n\n  /**\n   * Overload toJSON() to intercept JSON.stringify()\n   * @return {*}\n   */\n  toJSON() {\n    /* encode data to base64 if present and we're returning real JSON;\n     * although msgpack calls toJSON(), we know it is a stringify()\n     * call if it has a non-empty arguments list */\n    let encoding = this.encoding;\n    let data = this.data;\n    if (data && Platform.BufferUtils.isBuffer(data)) {\n      if (arguments.length > 0) {\n        /* stringify call */\n        encoding = encoding ? encoding + '/base64' : 'base64';\n        data = Platform.BufferUtils.base64Encode(data);\n      } else {\n        /* Called by msgpack. toBuffer returns a datatype understandable by\n         * that platform's msgpack implementation (Buffer in node, Uint8Array\n         * in browsers) */\n        data = Platform.BufferUtils.toBuffer(data);\n      }\n    }\n    return {\n      name: this.name,\n      id: this.id,\n      clientId: this.clientId,\n      connectionId: this.connectionId,\n      connectionKey: this.connectionKey,\n      extras: this.extras,\n      encoding,\n      data,\n    };\n  }\n\n  toString(): string {\n    let result = '[Message';\n    if (this.name) result += '; name=' + this.name;\n    if (this.id) result += '; id=' + this.id;\n    if (this.timestamp) result += '; timestamp=' + this.timestamp;\n    if (this.clientId) result += '; clientId=' + this.clientId;\n    if (this.connectionId) result += '; connectionId=' + this.connectionId;\n    if (this.encoding) result += '; encoding=' + this.encoding;\n    if (this.extras) result += '; extras =' + JSON.stringify(this.extras);\n    if (this.data) {\n      if (typeof this.data == 'string') result += '; data=' + this.data;\n      else if (Platform.BufferUtils.isBuffer(this.data))\n        result += '; data (buffer)=' + Platform.BufferUtils.base64Encode(this.data);\n      else result += '; data (json)=' + JSON.stringify(this.data);\n    }\n    if (this.extras) result += '; extras=' + JSON.stringify(this.extras);\n    result += ']';\n    return result;\n  }\n}\n\nexport default Message;\n", "import Logger from '../util/logger';\r\nimport Platform from 'common/platform';\r\nimport { encode as encodeMessage, decode as decodeMessage, getMessagesSize, CipherOptions } from './message';\r\nimport * as Utils from '../util/utils';\r\nimport * as API from '../../../../ably';\r\nimport { MsgPack } from 'common/types/msgpack';\r\n\r\nconst actions = ['absent', 'present', 'enter', 'leave', 'update'];\r\n\r\nfunction toActionValue(actionString: string) {\r\n  return actions.indexOf(actionString);\r\n}\r\n\r\nexport async function fromEncoded(encoded: unknown, options?: API.ChannelOptions): Promise<PresenceMessage> {\r\n  const msg = fromValues(encoded as PresenceMessage | Record<string, unknown>, true);\r\n  /* if decoding fails at any point, catch and return the message decoded to\r\n   * the fullest extent possible */\r\n  try {\r\n    await decode(msg, options ?? {});\r\n  } catch (e) {\r\n    Logger.logAction(Logger.LOG_ERROR, 'PresenceMessage.fromEncoded()', (e as Error).toString());\r\n  }\r\n  return msg;\r\n}\r\n\r\nexport async function fromEncodedArray(\r\n  encodedArray: unknown[],\r\n  options?: API.ChannelOptions,\r\n): Promise<PresenceMessage[]> {\r\n  return Promise.all(\r\n    encodedArray.map(function (encoded) {\r\n      return fromEncoded(encoded, options);\r\n    }),\r\n  );\r\n}\r\n\r\nexport function fromValues(\r\n  values: PresenceMessage | Record<string, unknown>,\r\n  stringifyAction?: boolean,\r\n): PresenceMessage {\r\n  if (stringifyAction) {\r\n    values.action = actions[values.action as number];\r\n  }\r\n  return Object.assign(new PresenceMessage(), values);\r\n}\r\n\r\nexport { encodeMessage as encode };\r\nexport const decode = decodeMessage;\r\n\r\nexport async function fromResponseBody(\r\n  body: Record<string, unknown>[],\r\n  options: CipherOptions,\r\n  MsgPack: MsgPack | null,\r\n  format?: Utils.Format,\r\n): Promise<PresenceMessage[]> {\r\n  const messages: PresenceMessage[] = [];\r\n  if (format) {\r\n    body = Utils.decodeBody(body, MsgPack, format);\r\n  }\r\n\r\n  for (let i = 0; i < body.length; i++) {\r\n    const msg = (messages[i] = fromValues(body[i], true));\r\n    try {\r\n      await decode(msg, options);\r\n    } catch (e) {\r\n      Logger.logAction(Logger.LOG_ERROR, 'PresenceMessage.fromResponseBody()', (e as Error).toString());\r\n    }\r\n  }\r\n  return messages;\r\n}\r\n\r\nexport function fromValuesArray(values: unknown[]): PresenceMessage[] {\r\n  const count = values.length,\r\n    result = new Array(count);\r\n  for (let i = 0; i < count; i++) result[i] = fromValues(values[i] as Record<string, unknown>);\r\n  return result;\r\n}\r\n\r\nexport function fromData(data: unknown): PresenceMessage {\r\n  if (data instanceof PresenceMessage) {\r\n    return data;\r\n  }\r\n  return fromValues({\r\n    data,\r\n  });\r\n}\r\n\r\nexport { getMessagesSize };\r\n\r\nclass PresenceMessage {\r\n  action?: string | number;\r\n  id?: string;\r\n  timestamp?: number;\r\n  clientId?: string;\r\n  connectionId?: string;\r\n  data?: string | Buffer | Uint8Array;\r\n  encoding?: string;\r\n  extras?: any;\r\n  size?: number;\r\n\r\n  /* Returns whether this presenceMessage is synthesized, i.e. was not actually\r\n   * sent by the connection (usually means a leave event sent 15s after a\r\n   * disconnection). This is useful because synthesized messages cannot be\r\n   * compared for newness by id lexicographically - RTP2b1\r\n   */\r\n  isSynthesized(): boolean {\r\n    if (!this.id || !this.connectionId) {\r\n      return true;\r\n    }\r\n    return this.id.substring(this.connectionId.length, 0) !== this.connectionId;\r\n  }\r\n\r\n  /* RTP2b2 */\r\n  parseId(): { connectionId: string; msgSerial: number; index: number } {\r\n    if (!this.id) throw new Error('parseId(): Presence message does not contain an id');\r\n    const parts = this.id.split(':');\r\n    return {\r\n      connectionId: parts[0],\r\n      msgSerial: parseInt(parts[1], 10),\r\n      index: parseInt(parts[2], 10),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Overload toJSON() to intercept JSON.stringify()\r\n   * @return {*}\r\n   */\r\n  toJSON(): {\r\n    id?: string;\r\n    clientId?: string;\r\n    action: number;\r\n    data: string | Buffer | Uint8Array;\r\n    encoding?: string;\r\n    extras?: any;\r\n  } {\r\n    /* encode data to base64 if present and we're returning real JSON;\r\n     * although msgpack calls toJSON(), we know it is a stringify()\r\n     * call if it has a non-empty arguments list */\r\n    let data = this.data as string | Buffer | Uint8Array;\r\n    let encoding = this.encoding;\r\n    if (data && Platform.BufferUtils.isBuffer(data)) {\r\n      if (arguments.length > 0) {\r\n        /* stringify call */\r\n        encoding = encoding ? encoding + '/base64' : 'base64';\r\n        data = Platform.BufferUtils.base64Encode(data);\r\n      } else {\r\n        /* Called by msgpack. toBuffer returns a datatype understandable by\r\n         * that platform's msgpack implementation (Buffer in node, Uint8Array\r\n         * in browsers) */\r\n        data = Platform.BufferUtils.toBuffer(data);\r\n      }\r\n    }\r\n    return {\r\n      id: this.id,\r\n      clientId: this.clientId,\r\n      /* Convert presence action back to an int for sending to Ably */\r\n      action: toActionValue(this.action as string),\r\n      data: data,\r\n      encoding: encoding,\r\n      extras: this.extras,\r\n    };\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[PresenceMessage';\r\n    result += '; action=' + this.action;\r\n    if (this.id) result += '; id=' + this.id;\r\n    if (this.timestamp) result += '; timestamp=' + this.timestamp;\r\n    if (this.clientId) result += '; clientId=' + this.clientId;\r\n    if (this.connectionId) result += '; connectionId=' + this.connectionId;\r\n    if (this.encoding) result += '; encoding=' + this.encoding;\r\n    if (this.data) {\r\n      if (typeof this.data == 'string') result += '; data=' + this.data;\r\n      else if (Platform.BufferUtils.isBuffer(this.data))\r\n        result += '; data (buffer)=' + Platform.BufferUtils.base64Encode(this.data);\r\n      else result += '; data (json)=' + JSON.stringify(this.data);\r\n    }\r\n    if (this.extras) {\r\n      result += '; extras=' + JSON.stringify(this.extras);\r\n    }\r\n    result += ']';\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default PresenceMessage;\r\n", "import * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\r\nimport PresenceMessage, { fromResponseBody as presenceMessageFromResponseBody } from '../types/presencemessage';\r\nimport { CipherOptions } from '../types/message';\r\nimport RestChannel from './restchannel';\r\nimport Defaults from '../util/defaults';\r\n\r\nclass RestPresence {\r\n  channel: RestChannel;\r\n\r\n  constructor(channel: RestChannel) {\r\n    this.channel = channel;\r\n  }\r\n\r\n  async get(params: any): Promise<PaginatedResult<PresenceMessage>> {\r\n    Logger.logAction(Logger.LOG_MICRO, 'RestPresence.get()', 'channel = ' + this.channel.name);\r\n    const client = this.channel.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.channel.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    const options = this.channel.channelOptions;\r\n    return new PaginatedResource(\r\n      client,\r\n      this.channel.client.rest.presenceMixin.basePath(this),\r\n      headers,\r\n      envelope,\r\n      async function (body, headers, unpacked) {\r\n        return await presenceMessageFromResponseBody(\r\n          body as Record<string, unknown>[],\r\n          options as CipherOptions,\r\n          client._MsgPack,\r\n          unpacked ? undefined : format,\r\n        );\r\n      },\r\n    ).get(params);\r\n  }\r\n\r\n  async history(params: any): Promise<PaginatedResult<PresenceMessage>> {\r\n    Logger.logAction(Logger.LOG_MICRO, 'RestPresence.history()', 'channel = ' + this.channel.name);\r\n    return this.channel.client.rest.presenceMixin.history(this, params);\r\n  }\r\n}\r\n\r\nexport default RestPresence;\r\n", "import * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport RestPresence from './restpresence';\r\nimport Message, {\r\n  fromValues as messageFromValues,\r\n  fromValuesArray as messagesFromValuesArray,\r\n  encodeArray as encodeMessagesArray,\r\n  serialize as serializeMessage,\r\n  getMessagesSize,\r\n  CipherOptions,\r\n} from '../types/message';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport { PaginatedResult } from './paginatedresource';\r\nimport Resource from './resource';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport BaseRest from './baseclient';\r\nimport * as API from '../../../../ably';\r\nimport Defaults, { normaliseChannelOptions } from '../util/defaults';\r\nimport { RestHistoryParams } from './restchannelmixin';\r\nimport { RequestBody } from 'common/types/http';\r\n\r\nconst MSG_ID_ENTROPY_BYTES = 9;\r\n\r\nfunction allEmptyIds(messages: Array<Message>) {\r\n  return messages.every(function (message: Message) {\r\n    return !message.id;\r\n  });\r\n}\r\n\r\nclass RestChannel {\r\n  client: BaseRest;\r\n  name: string;\r\n  presence: RestPresence;\r\n  channelOptions: ChannelOptions;\r\n\r\n  constructor(client: BaseRest, name: string, channelOptions?: ChannelOptions) {\r\n    Logger.logAction(Logger.LOG_MINOR, 'RestChannel()', 'started; name = ' + name);\r\n    this.name = name;\r\n    this.client = client;\r\n    this.presence = new RestPresence(this);\r\n    this.channelOptions = normaliseChannelOptions(client._Crypto ?? null, channelOptions);\r\n  }\r\n\r\n  setOptions(options?: ChannelOptions): void {\r\n    this.channelOptions = normaliseChannelOptions(this.client._Crypto ?? null, options);\r\n  }\r\n\r\n  async history(params: RestHistoryParams | null): Promise<PaginatedResult<Message>> {\r\n    Logger.logAction(Logger.LOG_MICRO, 'RestChannel.history()', 'channel = ' + this.name);\r\n    return this.client.rest.channelMixin.history(this, params);\r\n  }\r\n\r\n  async publish(...args: any[]): Promise<void> {\r\n    const first = args[0],\r\n      second = args[1];\r\n    let messages: Array<Message>;\r\n    let params: any;\r\n\r\n    if (typeof first === 'string' || first === null) {\r\n      /* (name, data, ...) */\r\n      messages = [messageFromValues({ name: first, data: second })];\r\n      params = args[2];\r\n    } else if (Utils.isObject(first)) {\r\n      messages = [messageFromValues(first)];\r\n      params = args[1];\r\n    } else if (Array.isArray(first)) {\r\n      messages = messagesFromValuesArray(first);\r\n      params = args[1];\r\n    } else {\r\n      throw new ErrorInfo(\r\n        'The single-argument form of publish() expects a message object or an array of message objects',\r\n        40013,\r\n        400,\r\n      );\r\n    }\r\n\r\n    if (!params) {\r\n      /* No params supplied */\r\n      params = {};\r\n    }\r\n\r\n    const client = this.client,\r\n      options = client.options,\r\n      format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      idempotentRestPublishing = client.options.idempotentRestPublishing,\r\n      headers = Defaults.defaultPostHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, options.headers);\r\n\r\n    if (idempotentRestPublishing && allEmptyIds(messages)) {\r\n      const msgIdBase = await Utils.randomString(MSG_ID_ENTROPY_BYTES);\r\n      messages.forEach(function (message, index) {\r\n        message.id = msgIdBase + ':' + index.toString();\r\n      });\r\n    }\r\n\r\n    await encodeMessagesArray(messages, this.channelOptions as CipherOptions);\r\n\r\n    /* RSL1i */\r\n    const size = getMessagesSize(messages),\r\n      maxMessageSize = options.maxMessageSize;\r\n    if (size > maxMessageSize) {\r\n      throw new ErrorInfo(\r\n        'Maximum size of messages that can be published at once exceeded ( was ' +\r\n          size +\r\n          ' bytes; limit is ' +\r\n          maxMessageSize +\r\n          ' bytes)',\r\n        40009,\r\n        400,\r\n      );\r\n    }\r\n\r\n    await this._publish(serializeMessage(messages, client._MsgPack, format), headers, params);\r\n  }\r\n\r\n  async _publish(requestBody: RequestBody | null, headers: Record<string, string>, params: any): Promise<void> {\r\n    await Resource.post(\r\n      this.client,\r\n      this.client.rest.channelMixin.basePath(this) + '/messages',\r\n      requestBody,\r\n      headers,\r\n      params,\r\n      null,\r\n      true,\r\n    );\r\n  }\r\n\r\n  async status(): Promise<API.ChannelDetails> {\r\n    return this.client.rest.channelMixin.status(this);\r\n  }\r\n}\r\n\r\nexport default RestChannel;\r\n", "type StatsValues = {\r\n  entries?: Partial<Record<string, number>>;\r\n  schema?: string;\r\n  appId?: string;\r\n  inProgress?: never;\r\n  unit?: never;\r\n  intervalId?: never;\r\n};\r\n\r\nclass Stats {\r\n  entries?: Partial<Record<string, number>>;\r\n  schema?: string;\r\n  appId?: string;\r\n  inProgress?: never;\r\n  unit?: never;\r\n  intervalId?: never;\r\n\r\n  constructor(values?: StatsValues) {\r\n    this.entries = (values && values.entries) || undefined;\r\n    this.schema = (values && values.schema) || undefined;\r\n    this.appId = (values && values.appId) || undefined;\r\n    this.inProgress = (values && values.inProgress) || undefined;\r\n    this.unit = (values && values.unit) || undefined;\r\n    this.intervalId = (values && values.intervalId) || undefined;\r\n  }\r\n\r\n  static fromValues(values: StatsValues): Stats {\r\n    return new Stats(values);\r\n  }\r\n}\r\n\r\nexport default Stats;\r\n", "import * as API from '../../../../ably';\r\nimport RestChannel from './restchannel';\r\nimport RealtimeChannel from './realtimechannel';\r\nimport * as Utils from '../util/utils';\r\nimport Message, { fromResponseBody as messageFromResponseBody } from '../types/message';\r\nimport Defaults from '../util/defaults';\r\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\r\nimport Resource from './resource';\r\n\r\nexport interface RestHistoryParams {\r\n  start?: number;\r\n  end?: number;\r\n  direction?: string;\r\n  limit?: number;\r\n}\r\n\r\nexport class RestChannelMixin {\r\n  static basePath(channel: RestChannel | RealtimeChannel) {\r\n    return '/channels/' + encodeURIComponent(channel.name);\r\n  }\r\n\r\n  static history(\r\n    channel: RestChannel | RealtimeChannel,\r\n    params: RestHistoryParams | null,\r\n  ): Promise<PaginatedResult<Message>> {\r\n    const client = channel.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = channel.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    const options = channel.channelOptions;\r\n    return new PaginatedResource(client, this.basePath(channel) + '/messages', headers, envelope, async function (\r\n      body,\r\n      headers,\r\n      unpacked,\r\n    ) {\r\n      return await messageFromResponseBody(body as Message[], options, client._MsgPack, unpacked ? undefined : format);\r\n    }).get(params as Record<string, unknown>);\r\n  }\r\n\r\n  static async status(channel: RestChannel | RealtimeChannel): Promise<API.ChannelDetails> {\r\n    const format = channel.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;\r\n    const headers = Defaults.defaultPostHeaders(channel.client.options, { format });\r\n\r\n    const response = await Resource.get<API.ChannelDetails>(\r\n      channel.client,\r\n      this.basePath(channel),\r\n      headers,\r\n      {},\r\n      format,\r\n      true,\r\n    );\r\n\r\n    return response.body!;\r\n  }\r\n}\r\n", "import RestPresence from './restpresence';\r\nimport RealtimePresence from './realtimepresence';\r\nimport * as Utils from '../util/utils';\r\nimport Defaults from '../util/defaults';\r\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\r\nimport PresenceMessage, { fromResponseBody as presenceMessageFromResponseBody } from '../types/presencemessage';\r\nimport { CipherOptions } from '../types/message';\r\nimport { RestChannelMixin } from './restchannelmixin';\r\n\r\nexport class RestPresenceMixin {\r\n  static basePath(presence: RestPresence | RealtimePresence) {\r\n    return RestChannelMixin.basePath(presence.channel) + '/presence';\r\n  }\r\n\r\n  static async history(\r\n    presence: RestPresence | RealtimePresence,\r\n    params: any,\r\n  ): Promise<PaginatedResult<PresenceMessage>> {\r\n    const client = presence.channel.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = presence.channel.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    const options = presence.channel.channelOptions;\r\n    return new PaginatedResource(client, this.basePath(presence) + '/history', headers, envelope, async function (\r\n      body,\r\n      headers,\r\n      unpacked,\r\n    ) {\r\n      return await presenceMessageFromResponseBody(\r\n        body as Record<string, unknown>[],\r\n        options as CipherOptions,\r\n        client._MsgPack,\r\n        unpacked ? undefined : format,\r\n      );\r\n    }).get(params);\r\n  }\r\n}\r\n", "import * as Utils from '../util/utils';\r\nimport Logger, { LoggerOptions } from '../util/logger';\r\nimport Defaults from '../util/defaults';\r\nimport Push from './push';\r\nimport PaginatedResource, { HttpPaginatedResponse, PaginatedResult } from './paginatedresource';\r\nimport RestChannel from './restchannel';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport Stats from '../types/stats';\r\nimport HttpMethods from '../../constants/HttpMethods';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport { RequestBody, RequestParams } from '../../types/http';\r\nimport * as API from '../../../../ably';\r\nimport Resource from './resource';\r\n\r\nimport Platform from '../../platform';\r\nimport BaseClient from './baseclient';\r\nimport { useTokenAuth } from './auth';\r\nimport { RestChannelMixin } from './restchannelmixin';\r\nimport { RestPresenceMixin } from './restpresencemixin';\r\n\r\ntype BatchResult<T> = API.BatchResult<T>;\r\n\r\ntype BatchPublishSpec = API.BatchPublishSpec;\r\ntype BatchPublishSuccessResult = API.BatchPublishSuccessResult;\r\ntype BatchPublishFailureResult = API.BatchPublishFailureResult;\r\ntype BatchPublishResult = BatchResult<BatchPublishSuccessResult | BatchPublishFailureResult>;\r\ntype BatchPresenceSuccessResult = API.BatchPresenceSuccessResult;\r\ntype BatchPresenceFailureResult = API.BatchPresenceFailureResult;\r\ntype BatchPresenceResult = BatchResult<BatchPresenceSuccessResult | BatchPresenceFailureResult>;\r\n\r\ntype TokenRevocationTargetSpecifier = API.TokenRevocationTargetSpecifier;\r\ntype TokenRevocationOptions = API.TokenRevocationOptions;\r\ntype TokenRevocationSuccessResult = API.TokenRevocationSuccessResult;\r\ntype TokenRevocationFailureResult = API.TokenRevocationFailureResult;\r\ntype TokenRevocationResult = BatchResult<TokenRevocationSuccessResult | TokenRevocationFailureResult>;\r\n\r\nexport class Rest {\r\n  private readonly client: BaseClient;\r\n  readonly channels: Channels;\r\n  readonly push: Push;\r\n\r\n  readonly channelMixin = RestChannelMixin;\r\n  readonly presenceMixin = RestPresenceMixin;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n    this.channels = new Channels(this.client);\r\n    this.push = new Push(this.client);\r\n  }\r\n\r\n  async stats(params: RequestParams): Promise<PaginatedResult<Stats>> {\r\n    const headers = Defaults.defaultGetHeaders(this.client.options),\r\n      format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format;\r\n\r\n    Utils.mixin(headers, this.client.options.headers);\r\n\r\n    return new PaginatedResource(this.client, '/stats', headers, envelope, function (body, headers, unpacked) {\r\n      const statsValues = unpacked ? body : JSON.parse(body as string);\r\n      for (let i = 0; i < statsValues.length; i++) statsValues[i] = Stats.fromValues(statsValues[i]);\r\n      return statsValues;\r\n    }).get(params as Record<string, string>);\r\n  }\r\n\r\n  async time(params?: RequestParams): Promise<number> {\r\n    const headers = Defaults.defaultGetHeaders(this.client.options);\r\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\r\n    const timeUri = (host: string) => {\r\n      return this.client.baseUri(host) + '/time';\r\n    };\r\n\r\n    let { error, body, unpacked } = await this.client.http.do(\r\n      HttpMethods.Get,\r\n      timeUri,\r\n      headers,\r\n      null,\r\n      params as RequestParams,\r\n    );\r\n\r\n    if (error) {\r\n      throw error;\r\n    }\r\n    if (!unpacked) body = JSON.parse(body as string);\r\n    const time = (body as number[])[0];\r\n    if (!time) {\r\n      throw new ErrorInfo('Internal error (unexpected result type from GET /time)', 50000, 500);\r\n    }\r\n    /* calculate time offset only once for this device by adding to the prototype */\r\n    this.client.serverTimeOffset = time - Date.now();\r\n    return time;\r\n  }\r\n\r\n  async request(\r\n    method: string,\r\n    path: string,\r\n    version: number,\r\n    params: RequestParams,\r\n    body: unknown,\r\n    customHeaders: Record<string, string>,\r\n  ): Promise<HttpPaginatedResponse<unknown>> {\r\n    const [encoder, decoder, format] = (() => {\r\n      if (this.client.options.useBinaryProtocol) {\r\n        if (!this.client._MsgPack) {\r\n          Utils.throwMissingPluginError('MsgPack');\r\n        }\r\n        return [this.client._MsgPack.encode, this.client._MsgPack.decode, Utils.Format.msgpack];\r\n      } else {\r\n        return [JSON.stringify, JSON.parse, Utils.Format.json];\r\n      }\r\n    })();\r\n    const envelope = this.client.http.supportsLinkHeaders ? undefined : format;\r\n    params = params || {};\r\n    const _method = method.toLowerCase() as HttpMethods;\r\n    const headers =\r\n      _method == 'get'\r\n        ? Defaults.defaultGetHeaders(this.client.options, { format, protocolVersion: version })\r\n        : Defaults.defaultPostHeaders(this.client.options, { format, protocolVersion: version });\r\n\r\n    if (typeof body !== 'string') {\r\n      body = encoder(body) ?? null;\r\n    }\r\n    Utils.mixin(headers, this.client.options.headers);\r\n    if (customHeaders) {\r\n      Utils.mixin(headers, customHeaders);\r\n    }\r\n    const paginatedResource = new PaginatedResource(\r\n      this.client,\r\n      path,\r\n      headers,\r\n      envelope,\r\n      async function (resbody, headers, unpacked) {\r\n        return Utils.ensureArray(unpacked ? resbody : decoder(resbody as string & Buffer));\r\n      },\r\n      /* useHttpPaginatedResponse: */ true,\r\n    );\r\n\r\n    if (!Platform.Http.methods.includes(_method)) {\r\n      throw new ErrorInfo('Unsupported method ' + _method, 40500, 405);\r\n    }\r\n\r\n    if (Platform.Http.methodsWithBody.includes(_method)) {\r\n      return paginatedResource[_method as HttpMethods.Post](params, body as RequestBody) as Promise<\r\n        HttpPaginatedResponse<unknown>\r\n      >;\r\n    } else {\r\n      return paginatedResource[_method as HttpMethods.Get | HttpMethods.Delete](params) as Promise<\r\n        HttpPaginatedResponse<unknown>\r\n      >;\r\n    }\r\n  }\r\n\r\n  async batchPublish<T extends BatchPublishSpec | BatchPublishSpec[]>(\r\n    specOrSpecs: T,\r\n  ): Promise<T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[]> {\r\n    let requestBodyDTO: BatchPublishSpec[];\r\n    let singleSpecMode: boolean;\r\n    if (Array.isArray(specOrSpecs)) {\r\n      requestBodyDTO = specOrSpecs;\r\n      singleSpecMode = false;\r\n    } else {\r\n      requestBodyDTO = [specOrSpecs];\r\n      singleSpecMode = true;\r\n    }\r\n\r\n    const format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(this.client.options, { format });\r\n\r\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\r\n\r\n    const requestBody = Utils.encodeBody(requestBodyDTO, this.client._MsgPack, format);\r\n\r\n    const response = await Resource.post(this.client, '/messages', requestBody, headers, {}, null, true);\r\n\r\n    const batchResults = (\r\n      response.unpacked ? response.body : Utils.decodeBody(response.body, this.client._MsgPack, format)\r\n    ) as BatchPublishResult[];\r\n\r\n    // I don't love the below type assertions but not sure how to avoid them\r\n    if (singleSpecMode) {\r\n      return batchResults[0] as T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[];\r\n    } else {\r\n      return batchResults as T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[];\r\n    }\r\n  }\r\n\r\n  async batchPresence(channels: string[]): Promise<BatchPresenceResult> {\r\n    const format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(this.client.options, { format });\r\n\r\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\r\n\r\n    const channelsParam = channels.join(',');\r\n\r\n    const response = await Resource.get(this.client, '/presence', headers, { channels: channelsParam }, null, true);\r\n\r\n    return (\r\n      response.unpacked ? response.body : Utils.decodeBody(response.body, this.client._MsgPack, format)\r\n    ) as BatchPresenceResult;\r\n  }\r\n\r\n  async revokeTokens(\r\n    specifiers: TokenRevocationTargetSpecifier[],\r\n    options?: TokenRevocationOptions,\r\n  ): Promise<TokenRevocationResult> {\r\n    if (useTokenAuth(this.client.options)) {\r\n      throw new ErrorInfo('Cannot revoke tokens when using token auth', 40162, 401);\r\n    }\r\n\r\n    const keyName = this.client.options.keyName!;\r\n\r\n    let resolvedOptions = options ?? {};\r\n\r\n    const requestBodyDTO = {\r\n      targets: specifiers.map((specifier) => `${specifier.type}:${specifier.value}`),\r\n      ...resolvedOptions,\r\n    };\r\n\r\n    const format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(this.client.options, { format });\r\n\r\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\r\n\r\n    const requestBody = Utils.encodeBody(requestBodyDTO, this.client._MsgPack, format);\r\n\r\n    const response = await Resource.post(\r\n      this.client,\r\n      `/keys/${keyName}/revokeTokens`,\r\n      requestBody,\r\n      headers,\r\n      {},\r\n      null,\r\n      true,\r\n    );\r\n\r\n    return (\r\n      response.unpacked ? response.body : Utils.decodeBody(response.body, this.client._MsgPack, format)\r\n    ) as TokenRevocationResult;\r\n  }\r\n\r\n  setLog(logOptions: LoggerOptions): void {\r\n    Logger.setLog(logOptions.level, logOptions.handler);\r\n  }\r\n}\r\n\r\nclass Channels {\r\n  client: BaseClient;\r\n  all: Record<string, RestChannel>;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n    this.all = Object.create(null);\r\n  }\r\n\r\n  get(name: string, channelOptions?: ChannelOptions) {\r\n    name = String(name);\r\n    let channel = this.all[name];\r\n    if (!channel) {\r\n      this.all[name] = channel = new RestChannel(this.client, name, channelOptions);\r\n    } else if (channelOptions) {\r\n      channel.setOptions(channelOptions);\r\n    }\r\n\r\n    return channel;\r\n  }\r\n\r\n  /* Included to support certain niche use-cases; most users should ignore this.\r\n   * Please do not use this unless you know what you're doing */\r\n  release(name: string) {\r\n    delete this.all[String(name)];\r\n  }\r\n}\r\n", "import BaseClient from './baseclient';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport { Rest } from './rest';\r\nimport Defaults from '../util/defaults';\r\n\r\n/**\r\n `BaseRest` is an export of the tree-shakable version of the SDK, and acts as the base class for the `DefaultRest` class exported by the non tree-shakable version.\r\n\r\n It always includes the `Rest` plugin.\r\n */\r\nexport class BaseRest extends BaseClient {\r\n  /*\r\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\r\n   *\r\n   * 1. passes a string (which is quite likely if they\u2019re e.g. migrating from the default variant to the modular variant)\r\n   * 2. passes no argument at all\r\n   *\r\n   * tell the compiler that these cases are possible so that it forces us to handle them.\r\n   */\r\n  constructor(options?: ClientOptions | string) {\r\n    super(Defaults.objectifyOptions(options, false, 'BaseRest', { Rest }));\r\n  }\r\n}\r\n", "import { Rest } from './rest';\r\nimport { IUntypedCryptoStatic } from '../../types/ICryptoStatic';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport RealtimePresence from './realtimepresence';\r\nimport XHRRequest from 'platform/web/lib/http/request/xhrrequest';\r\nimport fetchRequest from 'platform/web/lib/http/request/fetchrequest';\r\nimport { FilteredSubscriptions } from './filteredsubscriptions';\r\nimport {\r\n  fromValues as presenceMessageFromValues,\r\n  fromValuesArray as presenceMessagesFromValuesArray,\r\n} from '../types/presencemessage';\r\nimport { TransportCtor } from '../transport/transport';\r\n\r\nexport interface PresenceMessagePlugin {\r\n  presenceMessageFromValues: typeof presenceMessageFromValues;\r\n  presenceMessagesFromValuesArray: typeof presenceMessagesFromValuesArray;\r\n}\r\n\r\nexport type RealtimePresencePlugin = PresenceMessagePlugin & {\r\n  RealtimePresence: typeof RealtimePresence;\r\n};\r\n\r\nexport interface ModularPlugins {\r\n  Rest?: typeof Rest;\r\n  Crypto?: IUntypedCryptoStatic;\r\n  MsgPack?: MsgPack;\r\n  RealtimePresence?: RealtimePresencePlugin;\r\n  WebSocketTransport?: TransportCtor;\r\n  XHRPolling?: TransportCtor;\r\n  XHRRequest?: typeof XHRRequest;\r\n  FetchRequest?: typeof fetchRequest;\r\n  MessageInteractions?: typeof FilteredSubscriptions;\r\n}\r\n\r\nexport const allCommonModularPlugins: ModularPlugins = { Rest };\r\n", "import Message, {\r\n  CipherOptions,\r\n  fromEncoded,\r\n  fromEncodedArray,\r\n  encode,\r\n  decode,\r\n  EncodingDecodingContext,\r\n} from './message';\r\nimport * as API from '../../../../ably';\r\nimport Platform from 'common/platform';\r\nimport PresenceMessage from './presencemessage';\r\nimport { ChannelOptions } from 'common/types/channel';\r\n\r\n/**\r\n `DefaultMessage` is the class returned by `DefaultRest` and `DefaultRealtime`\u2019s `Message` static property. It introduces the static methods described in the `MessageStatic` interface of the public API of the non tree-shakable version of the library.\r\n */\r\nexport class DefaultMessage extends Message {\r\n  static async fromEncoded(encoded: unknown, inputOptions?: API.ChannelOptions): Promise<Message> {\r\n    return fromEncoded(Platform.Crypto, encoded, inputOptions);\r\n  }\r\n\r\n  static async fromEncodedArray(encodedArray: Array<unknown>, options?: API.ChannelOptions): Promise<Message[]> {\r\n    return fromEncodedArray(Platform.Crypto, encodedArray, options);\r\n  }\r\n\r\n  // Used by tests\r\n  static fromValues(values: unknown): Message {\r\n    return Object.assign(new Message(), values);\r\n  }\r\n\r\n  // Used by tests\r\n  static async encode<T extends Message | PresenceMessage>(msg: T, options: CipherOptions): Promise<T> {\r\n    return encode(msg, options);\r\n  }\r\n\r\n  // Used by tests\r\n  static async decode(\r\n    message: Message | PresenceMessage,\r\n    inputContext: CipherOptions | EncodingDecodingContext | ChannelOptions,\r\n  ): Promise<void> {\r\n    return decode(message, inputContext);\r\n  }\r\n}\r\n", "import * as API from '../../../../ably';\r\nimport PresenceMessage, { fromEncoded, fromEncodedArray, fromValues } from './presencemessage';\r\n\r\n/**\r\n `DefaultPresenceMessage` is the class returned by `DefaultRest` and `DefaultRealtime`\u2019s `PresenceMessage` static property. It introduces the static methods described in the `PresenceMessageStatic` interface of the public API of the non tree-shakable version of the library.\r\n */\r\nexport class DefaultPresenceMessage extends PresenceMessage {\r\n  static async fromEncoded(encoded: unknown, inputOptions?: API.ChannelOptions): Promise<PresenceMessage> {\r\n    return fromEncoded(encoded, inputOptions);\r\n  }\r\n\r\n  static async fromEncodedArray(\r\n    encodedArray: Array<unknown>,\r\n    options?: API.ChannelOptions,\r\n  ): Promise<PresenceMessage[]> {\r\n    return fromEncodedArray(encodedArray, options);\r\n  }\r\n\r\n  static fromValues(values: PresenceMessage | Record<string, unknown>, stringifyAction?: boolean): PresenceMessage {\r\n    return fromValues(values, stringifyAction);\r\n  }\r\n}\r\n", "import { BaseRest } from './baserest';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport { allCommonModularPlugins } from './modularplugins';\r\nimport Platform from 'common/platform';\r\nimport { DefaultMessage } from '../types/defaultmessage';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport { DefaultPresenceMessage } from '../types/defaultpresencemessage';\r\nimport { Http } from 'common/types/http';\r\nimport Defaults from '../util/defaults';\r\n\r\n/**\r\n `DefaultRest` is the class that the non tree-shakable version of the SDK exports as `Rest`. It ensures that this version of the SDK includes all of the functionality which is optionally available in the tree-shakable version.\r\n */\r\nexport class DefaultRest extends BaseRest {\r\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\r\n  constructor(options?: ClientOptions | string) {\r\n    const MsgPack = DefaultRest._MsgPack;\r\n    if (!MsgPack) {\r\n      throw new Error('Expected DefaultRest._MsgPack to have been set');\r\n    }\r\n\r\n    super(\r\n      Defaults.objectifyOptions(options, true, 'Rest', {\r\n        ...allCommonModularPlugins,\r\n        Crypto: DefaultRest.Crypto ?? undefined,\r\n        MsgPack: DefaultRest._MsgPack ?? undefined,\r\n      }),\r\n    );\r\n  }\r\n\r\n  private static _Crypto: typeof Platform.Crypto = null;\r\n  static get Crypto() {\r\n    if (this._Crypto === null) {\r\n      throw new Error('Encryption not enabled; use ably.encryption.js instead');\r\n    }\r\n\r\n    return this._Crypto;\r\n  }\r\n  static set Crypto(newValue: typeof Platform.Crypto) {\r\n    this._Crypto = newValue;\r\n  }\r\n\r\n  static Message = DefaultMessage;\r\n  static PresenceMessage = DefaultPresenceMessage;\r\n\r\n  static _MsgPack: MsgPack | null = null;\r\n\r\n  // Used by tests\r\n  static _Http = Http;\r\n}\r\n", "import * as Utils from './utils';\r\nimport Logger from './logger';\r\nimport Platform from 'common/platform';\r\n\r\n/* Call the listener, catch any exceptions and log, but continue operation*/\r\nfunction callListener(eventThis: { event: string }, listener: Function, args: unknown[]) {\r\n  try {\r\n    listener.apply(eventThis, args);\r\n  } catch (e) {\r\n    Logger.logAction(\r\n      Logger.LOG_ERROR,\r\n      'EventEmitter.emit()',\r\n      'Unexpected listener exception: ' + e + '; stack = ' + (e && (e as Error).stack),\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Remove listeners that match listener\r\n * @param targetListeners is an array of listener arrays or event objects with arrays of listeners\r\n * @param listener the listener callback to remove\r\n * @param eventFilter (optional) event name instructing the function to only remove listeners for the specified event\r\n */\r\nfunction removeListener(targetListeners: any, listener: Function, eventFilter?: string) {\r\n  let listeners: Record<string, unknown>;\r\n  let index;\r\n  let eventName;\r\n\r\n  for (let targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {\r\n    listeners = targetListeners[targetListenersIndex];\r\n    if (eventFilter) {\r\n      listeners = listeners[eventFilter] as Record<string, unknown>;\r\n    }\r\n\r\n    if (Array.isArray(listeners)) {\r\n      while ((index = listeners.indexOf(listener)) !== -1) {\r\n        listeners.splice(index, 1);\r\n      }\r\n      /* If events object has an event name key with no listeners then\r\n\t\t\t\t\tremove the key to stop the list growing indefinitely */\r\n      if (eventFilter && listeners.length === 0) {\r\n        delete targetListeners[targetListenersIndex][eventFilter];\r\n      }\r\n    } else if (Utils.isObject(listeners)) {\r\n      /* events */\r\n      for (eventName in listeners) {\r\n        if (Object.prototype.hasOwnProperty.call(listeners, eventName) && Array.isArray(listeners[eventName])) {\r\n          removeListener([listeners], listener, eventName);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass EventEmitter {\r\n  any: Array<Function>;\r\n  events: Record<string, Array<Function>>;\r\n  anyOnce: Array<Function>;\r\n  eventsOnce: Record<string, Array<Function>>;\r\n\r\n  constructor() {\r\n    this.any = [];\r\n    this.events = Object.create(null);\r\n    this.anyOnce = [];\r\n    this.eventsOnce = Object.create(null);\r\n  }\r\n\r\n  /**\r\n   * Add an event listener\r\n   * @param listener the listener to be called\r\n   */\r\n  on(listener: Function): void;\r\n\r\n  /**\r\n   * Add an event listener\r\n   * @param event (optional) the name of the event to listen to\r\n   * @param listener the listener to be called\r\n   */\r\n  on(event: null | string | string[], listener: Function): void;\r\n\r\n  on(...args: unknown[]) {\r\n    if (args.length === 1) {\r\n      const listener = args[0];\r\n      if (typeof listener === 'function') {\r\n        this.any.push(listener);\r\n      } else {\r\n        throw new Error('EventListener.on(): Invalid arguments: ' + Platform.Config.inspect(args));\r\n      }\r\n    }\r\n    if (args.length === 2) {\r\n      const [event, listener] = args;\r\n      if (typeof listener !== 'function') {\r\n        throw new Error('EventListener.on(): Invalid arguments: ' + Platform.Config.inspect(args));\r\n      }\r\n      if (Utils.isNil(event)) {\r\n        this.any.push(listener);\r\n      } else if (Array.isArray(event)) {\r\n        event.forEach((eventName) => {\r\n          this.on(eventName, listener);\r\n        });\r\n      } else {\r\n        if (typeof event !== 'string') {\r\n          throw new Error('EventListener.on(): Invalid arguments: ' + Platform.Config.inspect(args));\r\n        }\r\n        const listeners = this.events[event] || (this.events[event] = []);\r\n        listeners.push(listener);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove one or more event listeners\r\n   * @param listener (optional) the listener to remove. If not\r\n   *        supplied, all listeners are removed.\r\n   */\r\n  off(listener?: Function): void;\r\n\r\n  /**\r\n   * Remove one or more event listeners\r\n   * @param event (optional) the name of the event whose listener\r\n   *        is to be removed. If not supplied, the listener is\r\n   *        treated as an 'any' listener\r\n   * @param listener (optional) the listener to remove. If not\r\n   *        supplied, all listeners are removed.\r\n   */\r\n  off(event: string | string[] | null, listener?: Function | null): void;\r\n\r\n  off(...args: unknown[]) {\r\n    if (args.length == 0 || (Utils.isNil(args[0]) && Utils.isNil(args[1]))) {\r\n      this.any = [];\r\n      this.events = Object.create(null);\r\n      this.anyOnce = [];\r\n      this.eventsOnce = Object.create(null);\r\n      return;\r\n    }\r\n    const [firstArg, secondArg] = args;\r\n    let listener: Function | null = null;\r\n    let event: unknown = null;\r\n    if (args.length === 1 || !secondArg) {\r\n      if (typeof firstArg === 'function') {\r\n        /* we take this to be the listener and treat the event as \"any\" .. */\r\n        listener = firstArg;\r\n      } else {\r\n        event = firstArg;\r\n      }\r\n      /* ... or we take event to be the actual event name and listener to be all */\r\n    } else {\r\n      if (typeof secondArg !== 'function') {\r\n        throw new Error('EventEmitter.off(): invalid arguments:' + Platform.Config.inspect(args));\r\n      }\r\n      [event, listener] = [firstArg, secondArg];\r\n    }\r\n\r\n    if (listener && Utils.isNil(event)) {\r\n      removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);\r\n      return;\r\n    }\r\n\r\n    if (Array.isArray(event)) {\r\n      event.forEach((eventName) => {\r\n        this.off(eventName, listener);\r\n      });\r\n      return;\r\n    }\r\n\r\n    /* \"normal\" case where event is an actual event */\r\n    if (typeof event !== 'string') {\r\n      throw new Error('EventEmitter.off(): invalid arguments:' + Platform.Config.inspect(args));\r\n    }\r\n    if (listener) {\r\n      removeListener([this.events, this.eventsOnce], listener, event);\r\n    } else {\r\n      delete this.events[event];\r\n      delete this.eventsOnce[event];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the array of listeners for a given event; excludes once events\r\n   * @param event (optional) the name of the event, or none for 'any'\r\n   * @return array of events, or null if none\r\n   */\r\n  listeners(event: string) {\r\n    if (event) {\r\n      const listeners = this.events[event] || [];\r\n      if (this.eventsOnce[event]) Array.prototype.push.apply(listeners, this.eventsOnce[event]);\r\n      return listeners.length ? listeners : null;\r\n    }\r\n    return this.any.length ? this.any : null;\r\n  }\r\n\r\n  /**\r\n   * Emit an event\r\n   * @param event the event name\r\n   * @param args the arguments to pass to the listener\r\n   */\r\n  emit(event: string, ...args: unknown[] /* , args... */) {\r\n    const eventThis = { event };\r\n    const listeners: Function[] = [];\r\n\r\n    if (this.anyOnce.length) {\r\n      Array.prototype.push.apply(listeners, this.anyOnce);\r\n      this.anyOnce = [];\r\n    }\r\n    if (this.any.length) {\r\n      Array.prototype.push.apply(listeners, this.any);\r\n    }\r\n    const eventsOnceListeners = this.eventsOnce[event];\r\n    if (eventsOnceListeners) {\r\n      Array.prototype.push.apply(listeners, eventsOnceListeners);\r\n      delete this.eventsOnce[event];\r\n    }\r\n    const eventsListeners = this.events[event];\r\n    if (eventsListeners) {\r\n      Array.prototype.push.apply(listeners, eventsListeners);\r\n    }\r\n\r\n    listeners.forEach(function (listener) {\r\n      callListener(eventThis, listener, args);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Listen for a single occurrence of an event\r\n   * @param event the name of the event to listen to\r\n   */\r\n  once(event: string): Promise<void>;\r\n\r\n  /**\r\n   * Listen for a single occurrence of any event\r\n   * @param listener the listener to be called\r\n   */\r\n  once(listener: Function): void;\r\n\r\n  /**\r\n   * Listen for a single occurrence of an event\r\n   * @param event the name of the event to listen to\r\n   * @param listener the listener to be called\r\n   */\r\n  once(event?: string | string[] | null, listener?: Function): void;\r\n\r\n  once(...args: unknown[]): void | Promise<void> {\r\n    const argCount = args.length;\r\n    if (argCount === 0 || (argCount === 1 && typeof args[0] !== 'function')) {\r\n      const event = args[0];\r\n      return new Promise((resolve) => {\r\n        this.once(event as string | string[] | null, resolve);\r\n      });\r\n    }\r\n\r\n    const [firstArg, secondArg] = args;\r\n    if (args.length === 1 && typeof firstArg === 'function') {\r\n      this.anyOnce.push(firstArg);\r\n    } else if (Utils.isNil(firstArg)) {\r\n      if (typeof secondArg !== 'function') {\r\n        throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\r\n      }\r\n      this.anyOnce.push(secondArg);\r\n    } else if (Array.isArray(firstArg)) {\r\n      const self = this;\r\n      const listenerWrapper = function (this: any) {\r\n        const innerArgs = Array.prototype.slice.call(arguments);\r\n        firstArg.forEach(function (eventName) {\r\n          self.off(eventName, listenerWrapper);\r\n        });\r\n        if (typeof secondArg !== 'function') {\r\n          throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\r\n        }\r\n        secondArg.apply(this, innerArgs);\r\n      };\r\n      firstArg.forEach(function (eventName) {\r\n        self.on(eventName, listenerWrapper);\r\n      });\r\n    } else {\r\n      if (typeof firstArg !== 'string') {\r\n        throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\r\n      }\r\n      const listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);\r\n      if (secondArg) {\r\n        if (typeof secondArg !== 'function') {\r\n          throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\r\n        }\r\n        listeners.push(secondArg);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState\r\n   * @param targetState the name of the state event to listen to\r\n   * @param currentState the name of the current state of this object\r\n   */\r\n  async whenState(targetState: string, currentState: string) {\r\n    if (typeof targetState !== 'string' || typeof currentState !== 'string') {\r\n      throw new Error('whenState requires a valid state String argument');\r\n    }\r\n    if (targetState === currentState) {\r\n      return null;\r\n    } else {\r\n      return this.once(targetState);\r\n    }\r\n  }\r\n}\r\n\r\nexport default EventEmitter;\r\n", "import { MsgPack } from 'common/types/msgpack';\r\nimport * as API from '../../../../ably';\r\nimport { PresenceMessagePlugin } from '../client/modularplugins';\r\nimport * as Utils from '../util/utils';\r\nimport ErrorInfo from './errorinfo';\r\nimport Message, { fromValues as messageFromValues, fromValuesArray as messagesFromValuesArray } from './message';\r\nimport PresenceMessage, {\r\n  fromValues as presenceMessageFromValues,\r\n  fromValuesArray as presenceMessagesFromValuesArray,\r\n} from './presencemessage';\r\n\r\nexport const actions = {\r\n  HEARTBEAT: 0,\r\n  ACK: 1,\r\n  NACK: 2,\r\n  CONNECT: 3,\r\n  CONNECTED: 4,\r\n  DISCONNECT: 5,\r\n  DISCONNECTED: 6,\r\n  CLOSE: 7,\r\n  CLOSED: 8,\r\n  ERROR: 9,\r\n  ATTACH: 10,\r\n  ATTACHED: 11,\r\n  DETACH: 12,\r\n  DETACHED: 13,\r\n  PRESENCE: 14,\r\n  MESSAGE: 15,\r\n  SYNC: 16,\r\n  AUTH: 17,\r\n  ACTIVATE: 18,\r\n};\r\n\r\nexport const ActionName: string[] = [];\r\nObject.keys(actions).forEach(function (name) {\r\n  ActionName[(actions as { [key: string]: number })[name]] = name;\r\n});\r\n\r\nconst flags: { [key: string]: number } = {\r\n  /* Channel attach state flags */\r\n  HAS_PRESENCE: 1 << 0,\r\n  HAS_BACKLOG: 1 << 1,\r\n  RESUMED: 1 << 2,\r\n  TRANSIENT: 1 << 4,\r\n  ATTACH_RESUME: 1 << 5,\r\n  /* Channel mode flags */\r\n  PRESENCE: 1 << 16,\r\n  PUBLISH: 1 << 17,\r\n  SUBSCRIBE: 1 << 18,\r\n  PRESENCE_SUBSCRIBE: 1 << 19,\r\n};\r\nconst flagNames = Object.keys(flags);\r\nflags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;\r\n\r\nfunction toStringArray(array?: any[]): string {\r\n  const result = [];\r\n  if (array) {\r\n    for (let i = 0; i < array.length; i++) {\r\n      result.push(array[i].toString());\r\n    }\r\n  }\r\n  return '[ ' + result.join(', ') + ' ]';\r\n}\r\n\r\nexport const channelModes = ['PRESENCE', 'PUBLISH', 'SUBSCRIBE', 'PRESENCE_SUBSCRIBE'];\r\n\r\nexport const serialize = Utils.encodeBody;\r\n\r\nexport function deserialize(\r\n  serialized: unknown,\r\n  MsgPack: MsgPack | null,\r\n  presenceMessagePlugin: PresenceMessagePlugin | null,\r\n  format?: Utils.Format,\r\n): ProtocolMessage {\r\n  const deserialized = Utils.decodeBody<Record<string, unknown>>(serialized, MsgPack, format);\r\n  return fromDeserialized(deserialized, presenceMessagePlugin);\r\n}\r\n\r\nexport function fromDeserialized(\r\n  deserialized: Record<string, unknown>,\r\n  presenceMessagePlugin: PresenceMessagePlugin | null,\r\n): ProtocolMessage {\r\n  const error = deserialized.error;\r\n  if (error) deserialized.error = ErrorInfo.fromValues(error as ErrorInfo);\r\n  const messages = deserialized.messages as Message[];\r\n  if (messages) for (let i = 0; i < messages.length; i++) messages[i] = messageFromValues(messages[i]);\r\n\r\n  const presence = presenceMessagePlugin ? (deserialized.presence as PresenceMessage[]) : undefined;\r\n  if (presenceMessagePlugin) {\r\n    if (presence && presenceMessagePlugin)\r\n      for (let i = 0; i < presence.length; i++)\r\n        presence[i] = presenceMessagePlugin.presenceMessageFromValues(presence[i], true);\r\n  }\r\n  return Object.assign(new ProtocolMessage(), { ...deserialized, presence });\r\n}\r\n\r\n/**\r\n * Used by the tests.\r\n */\r\nexport function fromDeserializedIncludingDependencies(deserialized: Record<string, unknown>): ProtocolMessage {\r\n  return fromDeserialized(deserialized, { presenceMessageFromValues, presenceMessagesFromValuesArray });\r\n}\r\n\r\nexport function fromValues(values: unknown): ProtocolMessage {\r\n  return Object.assign(new ProtocolMessage(), values);\r\n}\r\n\r\nexport function stringify(msg: any, presenceMessagePlugin: PresenceMessagePlugin | null): string {\r\n  let result = '[ProtocolMessage';\r\n  if (msg.action !== undefined) result += '; action=' + ActionName[msg.action] || msg.action;\r\n\r\n  const simpleAttributes = ['id', 'channel', 'channelSerial', 'connectionId', 'count', 'msgSerial', 'timestamp'];\r\n  let attribute;\r\n  for (let attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {\r\n    attribute = simpleAttributes[attribIndex];\r\n    if (msg[attribute] !== undefined) result += '; ' + attribute + '=' + msg[attribute];\r\n  }\r\n\r\n  if (msg.messages) result += '; messages=' + toStringArray(messagesFromValuesArray(msg.messages));\r\n  if (msg.presence && presenceMessagePlugin)\r\n    result += '; presence=' + toStringArray(presenceMessagePlugin.presenceMessagesFromValuesArray(msg.presence));\r\n  if (msg.error) result += '; error=' + ErrorInfo.fromValues(msg.error).toString();\r\n  if (msg.auth && msg.auth.accessToken) result += '; token=' + msg.auth.accessToken;\r\n  if (msg.flags) result += '; flags=' + flagNames.filter(msg.hasFlag).join(',');\r\n  if (msg.params) {\r\n    let stringifiedParams = '';\r\n    Utils.forInOwnNonNullProperties(msg.params, function (prop: string) {\r\n      if (stringifiedParams.length > 0) {\r\n        stringifiedParams += '; ';\r\n      }\r\n      stringifiedParams += prop + '=' + msg.params[prop];\r\n    });\r\n    if (stringifiedParams.length > 0) {\r\n      result += '; params=[' + stringifiedParams + ']';\r\n    }\r\n  }\r\n  result += ']';\r\n  return result;\r\n}\r\n\r\nclass ProtocolMessage {\r\n  action?: number;\r\n  flags?: number;\r\n  id?: string;\r\n  timestamp?: number;\r\n  count?: number;\r\n  error?: ErrorInfo;\r\n  connectionId?: string;\r\n  channel?: string;\r\n  channelSerial?: string | null;\r\n  msgSerial?: number;\r\n  messages?: Message[];\r\n  // This will be undefined if we skipped decoding this property due to user not requesting presence functionality \u2014 see `fromDeserialized`\r\n  presence?: PresenceMessage[];\r\n  auth?: unknown;\r\n  connectionDetails?: Record<string, unknown>;\r\n\r\n  hasFlag = (flag: string): boolean => {\r\n    return ((this.flags as number) & flags[flag]) > 0;\r\n  };\r\n\r\n  setFlag(flag: API.ChannelMode): number {\r\n    return (this.flags = (this.flags as number) | flags[flag]);\r\n  }\r\n\r\n  getMode(): number | undefined {\r\n    return this.flags && this.flags & flags.MODE_ALL;\r\n  }\r\n\r\n  encodeModesToFlags(modes: API.ChannelMode[]): void {\r\n    modes.forEach((mode) => this.setFlag(mode));\r\n  }\r\n\r\n  decodeModesFromFlags(): string[] | undefined {\r\n    const modes: string[] = [];\r\n    channelModes.forEach((mode) => {\r\n      if (this.hasFlag(mode)) {\r\n        modes.push(mode);\r\n      }\r\n    });\r\n    return modes.length > 0 ? modes : undefined;\r\n  }\r\n}\r\n\r\nexport default ProtocolMessage;\r\n", "import ErrorInfo from '../types/errorinfo';\nimport EventEmitter from '../util/eventemitter';\nimport Logger from '../util/logger';\nimport { PendingMessage } from './protocol';\n\nclass MessageQueue extends EventEmitter {\n  messages: Array<PendingMessage>;\n\n  constructor() {\n    super();\n    this.messages = [];\n  }\n\n  count(): number {\n    return this.messages.length;\n  }\n\n  push(message: PendingMessage): void {\n    this.messages.push(message);\n  }\n\n  shift(): PendingMessage | undefined {\n    return this.messages.shift();\n  }\n\n  last(): PendingMessage {\n    return this.messages[this.messages.length - 1];\n  }\n\n  copyAll(): PendingMessage[] {\n    return this.messages.slice();\n  }\n\n  append(messages: Array<PendingMessage>): void {\n    this.messages.push.apply(this.messages, messages);\n  }\n\n  prepend(messages: Array<PendingMessage>): void {\n    this.messages.unshift.apply(this.messages, messages);\n  }\n\n  completeMessages(serial: number, count: number, err?: ErrorInfo | null): void {\n    Logger.logAction(Logger.LOG_MICRO, 'MessageQueue.completeMessages()', 'serial = ' + serial + '; count = ' + count);\n    err = err || null;\n    const messages = this.messages;\n    if (messages.length === 0) {\n      throw new Error('MessageQueue.completeMessages(): completeMessages called on any empty MessageQueue');\n    }\n    const first = messages[0];\n    if (first) {\n      const startSerial = first.message.msgSerial as number;\n      const endSerial = serial + count; /* the serial of the first message that is *not* the subject of this call */\n      if (endSerial > startSerial) {\n        const completeMessages = messages.splice(0, endSerial - startSerial);\n        for (const message of completeMessages) {\n          (message.callback as Function)(err);\n        }\n      }\n      if (messages.length == 0) this.emit('idle');\n    }\n  }\n\n  completeAllMessages(err: ErrorInfo): void {\n    this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);\n  }\n\n  resetSendAttempted(): void {\n    for (let msg of this.messages) {\n      msg.sendAttempted = false;\n    }\n  }\n\n  clear(): void {\n    Logger.logAction(Logger.LOG_MICRO, 'MessageQueue.clear()', 'clearing ' + this.messages.length + ' messages');\n    this.messages = [];\n    this.emit('idle');\n  }\n}\n\nexport default MessageQueue;\n", "import ProtocolMessage, { actions, stringify as stringifyProtocolMessage } from '../types/protocolmessage';\r\nimport * as Utils from '../util/utils';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport Logger from '../util/logger';\r\nimport MessageQueue from './messagequeue';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport Transport from './transport';\r\nimport { ErrCallback } from '../../types/utils';\r\n\r\nexport class PendingMessage {\r\n  message: ProtocolMessage;\r\n  callback?: ErrCallback;\r\n  merged: boolean;\r\n  sendAttempted: boolean;\r\n  ackRequired: boolean;\r\n\r\n  constructor(message: ProtocolMessage, callback?: ErrCallback) {\r\n    this.message = message;\r\n    this.callback = callback;\r\n    this.merged = false;\r\n    const action = message.action;\r\n    this.sendAttempted = false;\r\n    this.ackRequired = action == actions.MESSAGE || action == actions.PRESENCE;\r\n  }\r\n}\r\n\r\nclass Protocol extends EventEmitter {\r\n  transport: Transport;\r\n  messageQueue: MessageQueue;\r\n\r\n  constructor(transport: Transport) {\r\n    super();\r\n    this.transport = transport;\r\n    this.messageQueue = new MessageQueue();\r\n    transport.on('ack', (serial: number, count: number) => {\r\n      this.onAck(serial, count);\r\n    });\r\n    transport.on('nack', (serial: number, count: number, err: ErrorInfo) => {\r\n      this.onNack(serial, count, err);\r\n    });\r\n  }\r\n\r\n  onAck(serial: number, count: number): void {\r\n    Logger.logAction(Logger.LOG_MICRO, 'Protocol.onAck()', 'serial = ' + serial + '; count = ' + count);\r\n    this.messageQueue.completeMessages(serial, count);\r\n  }\r\n\r\n  onNack(serial: number, count: number, err: ErrorInfo): void {\r\n    Logger.logAction(\r\n      Logger.LOG_ERROR,\r\n      'Protocol.onNack()',\r\n      'serial = ' + serial + '; count = ' + count + '; err = ' + Utils.inspectError(err),\r\n    );\r\n    if (!err) {\r\n      err = new ErrorInfo('Unable to send message; channel not responding', 50001, 500);\r\n    }\r\n    this.messageQueue.completeMessages(serial, count, err);\r\n  }\r\n\r\n  onceIdle(listener: ErrCallback): void {\r\n    const messageQueue = this.messageQueue;\r\n    if (messageQueue.count() === 0) {\r\n      listener();\r\n      return;\r\n    }\r\n    messageQueue.once('idle', listener);\r\n  }\r\n\r\n  send(pendingMessage: PendingMessage): void {\r\n    if (pendingMessage.ackRequired) {\r\n      this.messageQueue.push(pendingMessage);\r\n    }\r\n    if (Logger.shouldLog(Logger.LOG_MICRO)) {\r\n      Logger.logActionNoStrip(\r\n        Logger.LOG_MICRO,\r\n        'Protocol.send()',\r\n        'sending msg; ' +\r\n          stringifyProtocolMessage(pendingMessage.message, this.transport.connectionManager.realtime._RealtimePresence),\r\n      );\r\n    }\r\n    pendingMessage.sendAttempted = true;\r\n    this.transport.send(pendingMessage.message);\r\n  }\r\n\r\n  getTransport(): Transport {\r\n    return this.transport;\r\n  }\r\n\r\n  getPendingMessages(): PendingMessage[] {\r\n    return this.messageQueue.copyAll();\r\n  }\r\n\r\n  clearPendingMessages(): void {\r\n    return this.messageQueue.clear();\r\n  }\r\n\r\n  finish(): void {\r\n    const transport = this.transport;\r\n    this.onceIdle(function () {\r\n      transport.disconnect();\r\n    });\r\n  }\r\n}\r\n\r\nexport default Protocol;\r\n", "import { IPartialErrorInfo } from '../types/errorinfo';\n\nclass ConnectionStateChange {\n  previous?: string;\n  current?: string;\n  retryIn?: number;\n  reason?: IPartialErrorInfo;\n\n  constructor(previous?: string, current?: string, retryIn?: number | null, reason?: IPartialErrorInfo) {\n    this.previous = previous;\n    this.current = current;\n    if (retryIn) this.retryIn = retryIn;\n    if (reason) this.reason = reason;\n  }\n}\n\nexport default ConnectionStateChange;\n", "import ErrorInfo from '../types/errorinfo';\n\nconst ConnectionErrorCodes = {\n  DISCONNECTED: 80003,\n  SUSPENDED: 80002,\n  FAILED: 80000,\n  CLOSING: 80017,\n  CLOSED: 80017,\n  UNKNOWN_CONNECTION_ERR: 50002,\n  UNKNOWN_CHANNEL_ERR: 50001,\n};\n\nconst ConnectionErrors = {\n  disconnected: () =>\n    ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.DISCONNECTED,\n      message: 'Connection to server temporarily unavailable',\n    }),\n  suspended: () =>\n    ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.SUSPENDED,\n      message: 'Connection to server unavailable',\n    }),\n  failed: () =>\n    ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.FAILED,\n      message: 'Connection failed or disconnected by server',\n    }),\n  closing: () =>\n    ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.CLOSING,\n      message: 'Connection closing',\n    }),\n  closed: () =>\n    ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.CLOSED,\n      message: 'Connection closed',\n    }),\n  unknownConnectionErr: () =>\n    ErrorInfo.fromValues({\n      statusCode: 500,\n      code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n      message: 'Internal connection error',\n    }),\n  unknownChannelErr: () =>\n    ErrorInfo.fromValues({\n      statusCode: 500,\n      code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n      message: 'Internal channel error',\n    }),\n};\n\nexport function isRetriable(err: ErrorInfo) {\n  if (!err.statusCode || !err.code || err.statusCode >= 500) {\n    return true;\n  }\n  return Object.values(ConnectionErrorCodes).includes(err.code);\n}\n\nexport default ConnectionErrors;\n", "import ProtocolMessage, {\r\n  actions,\r\n  fromValues as protocolMessageFromValues,\r\n  stringify as stringifyProtocolMessage,\r\n} from '../types/protocolmessage';\r\nimport * as Utils from '../util/utils';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport Logger from '../util/logger';\r\nimport ConnectionErrors from './connectionerrors';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport Auth from '../client/auth';\r\nimport * as API from '../../../../ably';\r\nimport ConnectionManager, { TransportParams } from './connectionmanager';\r\nimport Platform from 'common/platform';\r\nimport TransportName from 'common/constants/TransportName';\r\n\r\nexport type TryConnectCallback = (\r\n  wrappedErr: { error: ErrorInfo; event: string } | null,\r\n  transport?: Transport,\r\n) => void;\r\n\r\nexport interface TransportCtor {\r\n  new (\r\n    connectionManager: ConnectionManager,\r\n    auth: Auth,\r\n    params: TransportParams,\r\n    forceJsonProtocol?: boolean,\r\n  ): Transport;\r\n\r\n  isAvailable(): boolean;\r\n}\r\n\r\nconst closeMessage = protocolMessageFromValues({ action: actions.CLOSE });\r\nconst disconnectMessage = protocolMessageFromValues({ action: actions.DISCONNECT });\r\n\r\n/*\r\n * Transport instances inherit from EventEmitter and emit the following events:\r\n *\r\n * event name       data\r\n * closed           error\r\n * failed           error\r\n * disposed\r\n * connected        null error, connectionSerial, connectionId, connectionDetails\r\n * event            channel message object\r\n */\r\n\r\nabstract class Transport extends EventEmitter {\r\n  connectionManager: ConnectionManager;\r\n  auth: Auth;\r\n  params: TransportParams;\r\n  timeouts: Record<string, number>;\r\n  format?: Utils.Format;\r\n  isConnected: boolean;\r\n  isFinished: boolean;\r\n  isDisposed: boolean;\r\n  maxIdleInterval: number | null;\r\n  idleTimer: NodeJS.Timeout | number | null;\r\n  lastActivity: number | null;\r\n\r\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams, forceJsonProtocol?: boolean) {\r\n    super();\r\n    if (forceJsonProtocol) {\r\n      params.format = undefined;\r\n      params.heartbeats = true;\r\n    }\r\n    this.connectionManager = connectionManager;\r\n    this.auth = auth;\r\n    this.params = params;\r\n    this.timeouts = params.options.timeouts;\r\n    this.format = params.format;\r\n    this.isConnected = false;\r\n    this.isFinished = false;\r\n    this.isDisposed = false;\r\n    this.maxIdleInterval = null;\r\n    this.idleTimer = null;\r\n    this.lastActivity = null;\r\n  }\r\n\r\n  abstract shortName: TransportName;\r\n  abstract send(message: ProtocolMessage): void;\r\n\r\n  connect(): void {}\r\n\r\n  close(): void {\r\n    if (this.isConnected) {\r\n      this.requestClose();\r\n    }\r\n    this.finish('closed', ConnectionErrors.closed());\r\n  }\r\n\r\n  disconnect(err?: Error | ErrorInfo): void {\r\n    /* Used for network/transport issues that need to result in the transport\r\n     * being disconnected, but should not transition the connection to 'failed' */\r\n    if (this.isConnected) {\r\n      this.requestDisconnect();\r\n    }\r\n    this.finish('disconnected', err || ConnectionErrors.disconnected());\r\n  }\r\n\r\n  fail(err: ErrorInfo): void {\r\n    /* Used for client-side-detected fatal connection issues */\r\n    if (this.isConnected) {\r\n      this.requestDisconnect();\r\n    }\r\n    this.finish('failed', err || ConnectionErrors.failed());\r\n  }\r\n\r\n  finish(event: string, err?: Error | ErrorInfo): void {\r\n    if (this.isFinished) {\r\n      return;\r\n    }\r\n\r\n    this.isFinished = true;\r\n    this.isConnected = false;\r\n    this.maxIdleInterval = null;\r\n    clearTimeout(this.idleTimer ?? undefined);\r\n    this.idleTimer = null;\r\n    this.emit(event, err);\r\n    this.dispose();\r\n  }\r\n\r\n  onProtocolMessage(message: ProtocolMessage): void {\r\n    if (Logger.shouldLog(Logger.LOG_MICRO)) {\r\n      Logger.logActionNoStrip(\r\n        Logger.LOG_MICRO,\r\n        'Transport.onProtocolMessage()',\r\n        'received on ' +\r\n          this.shortName +\r\n          ': ' +\r\n          stringifyProtocolMessage(message, this.connectionManager.realtime._RealtimePresence) +\r\n          '; connectionId = ' +\r\n          this.connectionManager.connectionId,\r\n      );\r\n    }\r\n    this.onActivity();\r\n\r\n    switch (message.action) {\r\n      case actions.HEARTBEAT:\r\n        Logger.logActionNoStrip(\r\n          Logger.LOG_MICRO,\r\n          'Transport.onProtocolMessage()',\r\n          this.shortName + ' heartbeat; connectionId = ' + this.connectionManager.connectionId,\r\n        );\r\n        this.emit('heartbeat', message.id);\r\n        break;\r\n      case actions.CONNECTED:\r\n        this.onConnect(message);\r\n        this.emit('connected', message.error, message.connectionId, message.connectionDetails, message);\r\n        break;\r\n      case actions.CLOSED:\r\n        this.onClose(message);\r\n        break;\r\n      case actions.DISCONNECTED:\r\n        this.onDisconnect(message);\r\n        break;\r\n      case actions.ACK:\r\n        this.emit('ack', message.msgSerial, message.count);\r\n        break;\r\n      case actions.NACK:\r\n        this.emit('nack', message.msgSerial, message.count, message.error);\r\n        break;\r\n      case actions.SYNC:\r\n        this.connectionManager.onChannelMessage(message, this);\r\n        break;\r\n      case actions.ACTIVATE:\r\n        // Ignored.\r\n        break;\r\n      case actions.AUTH:\r\n        Utils.whenPromiseSettles(this.auth.authorize(), function (err: ErrorInfo | null) {\r\n          if (err) {\r\n            Logger.logAction(\r\n              Logger.LOG_ERROR,\r\n              'Transport.onProtocolMessage()',\r\n              'Ably requested re-authentication, but unable to obtain a new token: ' + Utils.inspectError(err),\r\n            );\r\n          }\r\n        });\r\n        break;\r\n      case actions.ERROR:\r\n        Logger.logAction(\r\n          Logger.LOG_MINOR,\r\n          'Transport.onProtocolMessage()',\r\n          'received error action; connectionId = ' +\r\n            this.connectionManager.connectionId +\r\n            '; err = ' +\r\n            Platform.Config.inspect(message.error) +\r\n            (message.channel ? ', channel: ' + message.channel : ''),\r\n        );\r\n        if (message.channel === undefined) {\r\n          this.onFatalError(message);\r\n          break;\r\n        }\r\n        /* otherwise it's a channel-specific error, so handle it in the channel */\r\n        this.connectionManager.onChannelMessage(message, this);\r\n        break;\r\n      default:\r\n        /* all other actions are channel-specific */\r\n        this.connectionManager.onChannelMessage(message, this);\r\n    }\r\n  }\r\n\r\n  onConnect(message: ProtocolMessage): void {\r\n    this.isConnected = true;\r\n    if (!message.connectionDetails) {\r\n      throw new Error('Transport.onConnect(): Connect message recieved without connectionDetails');\r\n    }\r\n    const maxPromisedIdle = message.connectionDetails.maxIdleInterval as number;\r\n    if (maxPromisedIdle) {\r\n      this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;\r\n      this.onActivity();\r\n    }\r\n    /* else Realtime declines to guarantee any maximum idle interval - CD2h */\r\n  }\r\n\r\n  onDisconnect(message: ProtocolMessage): void {\r\n    /* Used for when the server has disconnected the client (usually with a\r\n     * DISCONNECTED action) */\r\n    const err = message && message.error;\r\n    Logger.logAction(Logger.LOG_MINOR, 'Transport.onDisconnect()', 'err = ' + Utils.inspectError(err));\r\n    this.finish('disconnected', err);\r\n  }\r\n\r\n  onFatalError(message: ProtocolMessage): void {\r\n    /* On receipt of a fatal connection error, we can assume that the server\r\n     * will close the connection and the transport, and do not need to request\r\n     * a disconnection - RTN15i */\r\n    const err = message && message.error;\r\n    Logger.logAction(Logger.LOG_MINOR, 'Transport.onFatalError()', 'err = ' + Utils.inspectError(err));\r\n    this.finish('failed', err);\r\n  }\r\n\r\n  onClose(message: ProtocolMessage): void {\r\n    const err = message && message.error;\r\n    Logger.logAction(Logger.LOG_MINOR, 'Transport.onClose()', 'err = ' + Utils.inspectError(err));\r\n    this.finish('closed', err);\r\n  }\r\n\r\n  requestClose(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Transport.requestClose()', '');\r\n    this.send(closeMessage);\r\n  }\r\n\r\n  requestDisconnect(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Transport.requestDisconnect()', '');\r\n    this.send(disconnectMessage);\r\n  }\r\n\r\n  ping(id: string): void {\r\n    const msg: Record<string, number | string> = { action: actions.HEARTBEAT };\r\n    if (id) msg.id = id;\r\n    this.send(protocolMessageFromValues(msg));\r\n  }\r\n\r\n  dispose(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Transport.dispose()', '');\r\n    this.isDisposed = true;\r\n    this.off();\r\n  }\r\n\r\n  onActivity(): void {\r\n    if (!this.maxIdleInterval) {\r\n      return;\r\n    }\r\n    this.lastActivity = this.connectionManager.lastActivity = Date.now();\r\n    this.setIdleTimer(this.maxIdleInterval + 100);\r\n  }\r\n\r\n  setIdleTimer(timeout: number): void {\r\n    if (!this.idleTimer) {\r\n      this.idleTimer = setTimeout(() => {\r\n        this.onIdleTimerExpire();\r\n      }, timeout);\r\n    }\r\n  }\r\n\r\n  onIdleTimerExpire(): void {\r\n    if (!this.lastActivity || !this.maxIdleInterval) {\r\n      throw new Error('Transport.onIdleTimerExpire(): lastActivity/maxIdleInterval not set');\r\n    }\r\n    this.idleTimer = null;\r\n    const sinceLast = Date.now() - this.lastActivity;\r\n    const timeRemaining = this.maxIdleInterval - sinceLast;\r\n    if (timeRemaining <= 0) {\r\n      const msg = 'No activity seen from realtime in ' + sinceLast + 'ms; assuming connection has dropped';\r\n      Logger.logAction(Logger.LOG_ERROR, 'Transport.onIdleTimerExpire()', msg);\r\n      this.disconnect(new ErrorInfo(msg, 80003, 408));\r\n    } else {\r\n      this.setIdleTimer(timeRemaining + 100);\r\n    }\r\n  }\r\n\r\n  static tryConnect(\r\n    transportCtor: TransportCtor,\r\n    connectionManager: ConnectionManager,\r\n    auth: Auth,\r\n    transportParams: TransportParams,\r\n    callback: TryConnectCallback,\r\n  ): Transport {\r\n    const transport = new transportCtor(connectionManager, auth, transportParams);\r\n\r\n    let transportAttemptTimer: NodeJS.Timeout | number;\r\n\r\n    const errorCb = function (this: { event: string }, err: ErrorInfo) {\r\n      clearTimeout(transportAttemptTimer);\r\n      callback({ event: this.event, error: err });\r\n    };\r\n\r\n    const realtimeRequestTimeout = connectionManager.options.timeouts.realtimeRequestTimeout;\r\n    transportAttemptTimer = setTimeout(() => {\r\n      transport.off(['preconnect', 'disconnected', 'failed']);\r\n      transport.dispose();\r\n      errorCb.call(\r\n        { event: 'disconnected' },\r\n        new ErrorInfo('Timeout waiting for transport to indicate itself viable', 50000, 500),\r\n      );\r\n    }, realtimeRequestTimeout);\r\n\r\n    transport.on(['failed', 'disconnected'], errorCb);\r\n    transport.on('preconnect', function () {\r\n      Logger.logAction(Logger.LOG_MINOR, 'Transport.tryConnect()', 'viable transport ' + transport);\r\n      clearTimeout(transportAttemptTimer);\r\n      transport.off(['failed', 'disconnected'], errorCb);\r\n      callback(null, transport);\r\n    });\r\n    transport.connect();\r\n    return transport;\r\n  }\r\n\r\n  onAuthUpdated?: (tokenDetails: API.TokenDetails) => void;\r\n\r\n  static isAvailable(): boolean {\r\n    throw new ErrorInfo('isAvailable not implemented for transport', 50000, 500);\r\n  }\r\n}\r\n\r\nexport default Transport;\r\n", "export namespace TransportNames {\r\n  export const WebSocket = 'web_socket' as const;\r\n  export const Comet = 'comet' as const;\r\n  export const XhrPolling = 'xhr_polling' as const;\r\n}\r\n\r\ntype TransportName = typeof TransportNames.WebSocket | typeof TransportNames.Comet | typeof TransportNames.XhrPolling;\r\n\r\nexport default TransportName;\r\n", "import ProtocolMessage, {\r\n  actions,\r\n  stringify as stringifyProtocolMessage,\r\n  fromValues as protocolMessageFromValues,\r\n} from 'common/lib/types/protocolmessage';\r\nimport * as Utils from 'common/lib/util/utils';\r\nimport Protocol, { PendingMessage } from './protocol';\r\nimport Defaults, { getAgentString } from 'common/lib/util/defaults';\r\nimport Platform, { TransportImplementations } from 'common/platform';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport MessageQueue from './messagequeue';\r\nimport Logger from '../util/logger';\r\nimport ConnectionStateChange from 'common/lib/client/connectionstatechange';\r\nimport ConnectionErrors, { isRetriable } from './connectionerrors';\r\nimport ErrorInfo, { IPartialErrorInfo, PartialErrorInfo } from 'common/lib/types/errorinfo';\r\nimport Auth from 'common/lib/client/auth';\r\nimport Message, { getMessagesSize } from 'common/lib/types/message';\r\nimport Multicaster, { MulticasterInstance } from 'common/lib/util/multicaster';\r\nimport Transport, { TransportCtor } from './transport';\r\nimport * as API from '../../../../ably';\r\nimport { ErrCallback } from 'common/types/utils';\r\nimport HttpStatusCodes from 'common/constants/HttpStatusCodes';\r\nimport BaseRealtime from '../client/baserealtime';\r\nimport { NormalisedClientOptions } from 'common/types/ClientOptions';\r\nimport TransportName, { TransportNames } from 'common/constants/TransportName';\r\n\r\nlet globalObject = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : self;\r\n\r\nconst haveWebStorage = () => typeof Platform.WebStorage !== 'undefined' && Platform.WebStorage?.localSupported;\r\nconst haveSessionStorage = () => typeof Platform.WebStorage !== 'undefined' && Platform.WebStorage?.sessionSupported;\r\nconst noop = function () {};\r\nconst transportPreferenceName = 'ably-transport-preference';\r\n\r\nconst sessionRecoveryName = 'ably-connection-recovery';\r\nfunction getSessionRecoverData() {\r\n  return haveSessionStorage() && Platform.WebStorage?.getSession?.(sessionRecoveryName);\r\n}\r\nfunction setSessionRecoverData(value: any) {\r\n  return haveSessionStorage() && Platform.WebStorage?.setSession?.(sessionRecoveryName, value);\r\n}\r\nfunction clearSessionRecoverData() {\r\n  return haveSessionStorage() && Platform.WebStorage?.removeSession?.(sessionRecoveryName);\r\n}\r\n\r\nfunction bundleWith(dest: ProtocolMessage, src: ProtocolMessage, maxSize: number) {\r\n  let action;\r\n  if (dest.channel !== src.channel) {\r\n    /* RTL6d3 */\r\n    return false;\r\n  }\r\n  if ((action = dest.action) !== actions.PRESENCE && action !== actions.MESSAGE) {\r\n    /* RTL6d - can only bundle messages or presence */\r\n    return false;\r\n  }\r\n  if (action !== src.action) {\r\n    /* RTL6d4 */\r\n    return false;\r\n  }\r\n  const kind = action === actions.PRESENCE ? 'presence' : 'messages',\r\n    proposed = (dest as Record<string, any>)[kind].concat((src as Record<string, any>)[kind]),\r\n    size = getMessagesSize(proposed);\r\n  if (size > maxSize) {\r\n    /* RTL6d1 */\r\n    return false;\r\n  }\r\n  if (!Utils.allSame(proposed, 'clientId')) {\r\n    /* RTL6d2 */\r\n    return false;\r\n  }\r\n  if (\r\n    !proposed.every(function (msg: Message) {\r\n      return !msg.id;\r\n    })\r\n  ) {\r\n    /* RTL6d7 */\r\n    return false;\r\n  }\r\n  /* we're good to go! */\r\n  (dest as Record<string, any>)[kind] = proposed;\r\n  return true;\r\n}\r\n\r\ntype RecoveryContext = {\r\n  connectionKey: string;\r\n  msgSerial: number;\r\n  channelSerials: { [name: string]: string };\r\n};\r\n\r\nfunction decodeRecoveryKey(recoveryKey: NormalisedClientOptions['recover']): RecoveryContext | null {\r\n  try {\r\n    return JSON.parse(recoveryKey as string);\r\n  } catch (e) {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport class TransportParams {\r\n  options: NormalisedClientOptions;\r\n  host: string | null;\r\n  mode: string;\r\n  format?: Utils.Format;\r\n  connectionKey?: string;\r\n  stream?: any;\r\n  heartbeats?: boolean;\r\n\r\n  constructor(options: NormalisedClientOptions, host: string | null, mode: string, connectionKey?: string) {\r\n    this.options = options;\r\n    this.host = host;\r\n    this.mode = mode;\r\n    this.connectionKey = connectionKey;\r\n    this.format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;\r\n  }\r\n\r\n  getConnectParams(authParams: Record<string, unknown>): Record<string, string> {\r\n    const params = authParams ? Utils.copy(authParams) : {};\r\n    const options = this.options;\r\n    switch (this.mode) {\r\n      case 'resume':\r\n        params.resume = this.connectionKey as string;\r\n        break;\r\n      case 'recover': {\r\n        const recoveryContext = decodeRecoveryKey(options.recover);\r\n        if (recoveryContext) {\r\n          params.recover = recoveryContext.connectionKey;\r\n        }\r\n        break;\r\n      }\r\n      default:\r\n    }\r\n    if (options.clientId !== undefined) {\r\n      params.clientId = options.clientId;\r\n    }\r\n    if (options.echoMessages === false) {\r\n      params.echo = 'false';\r\n    }\r\n    if (this.format !== undefined) {\r\n      params.format = this.format;\r\n    }\r\n    if (this.stream !== undefined) {\r\n      params.stream = this.stream;\r\n    }\r\n    if (this.heartbeats !== undefined) {\r\n      params.heartbeats = this.heartbeats;\r\n    }\r\n    params.v = Defaults.protocolVersion;\r\n    params.agent = getAgentString(this.options);\r\n    if (options.transportParams !== undefined) {\r\n      Utils.mixin(params, options.transportParams);\r\n    }\r\n    return params as Record<string, string>;\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[mode=' + this.mode;\r\n    if (this.host) {\r\n      result += ',host=' + this.host;\r\n    }\r\n    if (this.connectionKey) {\r\n      result += ',connectionKey=' + this.connectionKey;\r\n    }\r\n    if (this.format) {\r\n      result += ',format=' + this.format;\r\n    }\r\n    result += ']';\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\ntype ConnectionState = {\r\n  state: string;\r\n  terminal?: boolean;\r\n  queueEvents?: boolean;\r\n  sendEvents?: boolean;\r\n  failState?: string;\r\n  retryDelay?: number;\r\n  retryImmediately?: boolean;\r\n  error?: IPartialErrorInfo;\r\n};\r\n\r\nclass ConnectionManager extends EventEmitter {\r\n  supportedTransports: Partial<Record<TransportName, TransportCtor>> = {};\r\n  realtime: BaseRealtime;\r\n  options: NormalisedClientOptions;\r\n  states: Record<string, ConnectionState>;\r\n  state: ConnectionState;\r\n  errorReason: IPartialErrorInfo | string | null;\r\n  queuedMessages: MessageQueue;\r\n  msgSerial: number;\r\n  connectionDetails?: Record<string, any>;\r\n  connectionId?: string;\r\n  connectionKey?: string;\r\n  connectionStateTtl: number;\r\n  maxIdleInterval: number | null;\r\n  transports: TransportName[];\r\n  baseTransport?: TransportName;\r\n  webSocketTransportAvailable?: true;\r\n  transportPreference: string | null;\r\n  httpHosts: string[];\r\n  wsHosts: string[];\r\n  activeProtocol: null | Protocol;\r\n  pendingTransport?: Transport;\r\n  proposedTransport?: Transport;\r\n  host: string | null;\r\n  lastAutoReconnectAttempt: number | null;\r\n  lastActivity: number | null;\r\n  forceFallbackHost: boolean;\r\n  transitionTimer?: number | NodeJS.Timeout | null;\r\n  suspendTimer?: number | NodeJS.Timeout | null;\r\n  retryTimer?: number | NodeJS.Timeout | null;\r\n  disconnectedRetryCount: number = 0;\r\n  pendingChannelMessagesState: {\r\n    // Whether a message is currently being processed\r\n    isProcessing: boolean;\r\n    // The messages remaining to be processed (excluding any message currently being processed)\r\n    queue: { message: ProtocolMessage; transport: Transport }[];\r\n  } = { isProcessing: false, queue: [] };\r\n  webSocketSlowTimer: NodeJS.Timeout | null;\r\n  wsCheckResult: boolean | null;\r\n  webSocketGiveUpTimer: NodeJS.Timeout | null;\r\n  abandonedWebSocket: boolean;\r\n  connectCounter: number;\r\n\r\n  constructor(realtime: BaseRealtime, options: NormalisedClientOptions) {\r\n    super();\r\n    this.realtime = realtime;\r\n    this.initTransports();\r\n    this.options = options;\r\n    const timeouts = options.timeouts;\r\n    /* connectingTimeout: leave webSocketConnectTimeout (~6s) to try the\r\n     * websocket transport, then realtimeRequestTimeout (~10s) to establish\r\n     * the base transport in case that fails */\r\n    const connectingTimeout = timeouts.webSocketConnectTimeout + timeouts.realtimeRequestTimeout;\r\n    this.states = {\r\n      initialized: {\r\n        state: 'initialized',\r\n        terminal: false,\r\n        queueEvents: true,\r\n        sendEvents: false,\r\n        failState: 'disconnected',\r\n      },\r\n      connecting: {\r\n        state: 'connecting',\r\n        terminal: false,\r\n        queueEvents: true,\r\n        sendEvents: false,\r\n        retryDelay: connectingTimeout,\r\n        failState: 'disconnected',\r\n      },\r\n      connected: {\r\n        state: 'connected',\r\n        terminal: false,\r\n        queueEvents: false,\r\n        sendEvents: true,\r\n        failState: 'disconnected',\r\n      },\r\n      disconnected: {\r\n        state: 'disconnected',\r\n        terminal: false,\r\n        queueEvents: true,\r\n        sendEvents: false,\r\n        retryDelay: timeouts.disconnectedRetryTimeout,\r\n        failState: 'disconnected',\r\n      },\r\n      suspended: {\r\n        state: 'suspended',\r\n        terminal: false,\r\n        queueEvents: false,\r\n        sendEvents: false,\r\n        retryDelay: timeouts.suspendedRetryTimeout,\r\n        failState: 'suspended',\r\n      },\r\n      closing: {\r\n        state: 'closing',\r\n        terminal: false,\r\n        queueEvents: false,\r\n        sendEvents: false,\r\n        retryDelay: timeouts.realtimeRequestTimeout,\r\n        failState: 'closed',\r\n      },\r\n      closed: { state: 'closed', terminal: true, queueEvents: false, sendEvents: false, failState: 'closed' },\r\n      failed: { state: 'failed', terminal: true, queueEvents: false, sendEvents: false, failState: 'failed' },\r\n    };\r\n    this.state = this.states.initialized;\r\n    this.errorReason = null;\r\n\r\n    this.queuedMessages = new MessageQueue();\r\n    this.msgSerial = 0;\r\n    this.connectionDetails = undefined;\r\n    this.connectionId = undefined;\r\n    this.connectionKey = undefined;\r\n    this.connectionStateTtl = timeouts.connectionStateTtl;\r\n    this.maxIdleInterval = null;\r\n\r\n    this.transports = Utils.intersect(options.transports || Defaults.defaultTransports, this.supportedTransports);\r\n    this.transportPreference = null;\r\n\r\n    if (this.transports.includes(TransportNames.WebSocket)) {\r\n      this.webSocketTransportAvailable = true;\r\n    }\r\n    if (this.transports.includes(TransportNames.XhrPolling)) {\r\n      this.baseTransport = TransportNames.XhrPolling;\r\n    } else if (this.transports.includes(TransportNames.Comet)) {\r\n      this.baseTransport = TransportNames.Comet;\r\n    }\r\n\r\n    this.httpHosts = Defaults.getHosts(options);\r\n    this.wsHosts = Defaults.getHosts(options, true);\r\n    this.activeProtocol = null;\r\n    this.host = null;\r\n    this.lastAutoReconnectAttempt = null;\r\n    this.lastActivity = null;\r\n    this.forceFallbackHost = false;\r\n    this.connectCounter = 0;\r\n    this.wsCheckResult = null;\r\n    this.webSocketSlowTimer = null;\r\n    this.webSocketGiveUpTimer = null;\r\n    this.abandonedWebSocket = false;\r\n\r\n    Logger.logAction(Logger.LOG_MINOR, 'Realtime.ConnectionManager()', 'started');\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'Realtime.ConnectionManager()',\r\n      'requested transports = [' + (options.transports || Defaults.defaultTransports) + ']',\r\n    );\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'Realtime.ConnectionManager()',\r\n      'available transports = [' + this.transports + ']',\r\n    );\r\n    Logger.logAction(Logger.LOG_MICRO, 'Realtime.ConnectionManager()', 'http hosts = [' + this.httpHosts + ']');\r\n\r\n    if (!this.transports.length) {\r\n      const msg = 'no requested transports available';\r\n      Logger.logAction(Logger.LOG_ERROR, 'realtime.ConnectionManager()', msg);\r\n      throw new Error(msg);\r\n    }\r\n\r\n    const addEventListener = Platform.Config.addEventListener;\r\n    if (addEventListener) {\r\n      /* intercept close event in browser to persist connection id if requested */\r\n      if (haveSessionStorage() && typeof options.recover === 'function') {\r\n        addEventListener('beforeunload', this.persistConnection.bind(this));\r\n      }\r\n\r\n      if (options.closeOnUnload === true) {\r\n        addEventListener('beforeunload', () => {\r\n          Logger.logAction(\r\n            Logger.LOG_MAJOR,\r\n            'Realtime.ConnectionManager()',\r\n            'beforeunload event has triggered the connection to close as closeOnUnload is true',\r\n          );\r\n          this.requestState({ state: 'closing' });\r\n        });\r\n      }\r\n\r\n      /* Listen for online and offline events */\r\n      addEventListener('online', () => {\r\n        if (this.state == this.states.disconnected || this.state == this.states.suspended) {\r\n          Logger.logAction(\r\n            Logger.LOG_MINOR,\r\n            'ConnectionManager caught browser \u2018online\u2019 event',\r\n            'reattempting connection',\r\n          );\r\n          this.requestState({ state: 'connecting' });\r\n        } else if (this.state == this.states.connecting) {\r\n          // RTN20c: if 'online' event recieved while CONNECTING, abandon connection attempt and retry\r\n          this.pendingTransport?.off();\r\n          this.disconnectAllTransports();\r\n\r\n          this.startConnect();\r\n        }\r\n      });\r\n\r\n      addEventListener('offline', () => {\r\n        if (this.state == this.states.connected) {\r\n          Logger.logAction(\r\n            Logger.LOG_MINOR,\r\n            'ConnectionManager caught browser \u2018offline\u2019 event',\r\n            'disconnecting active transport',\r\n          );\r\n          // Not sufficient to just go to the 'disconnected' state, want to\r\n          // force all transports to reattempt the connection. Will immediately\r\n          // retry.\r\n          this.disconnectAllTransports();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /*********************\r\n   * transport management\r\n   *********************/\r\n\r\n  // Used by tests\r\n  static supportedTransports(additionalImplementations: TransportImplementations) {\r\n    const storage: TransportStorage = { supportedTransports: {} };\r\n    this.initTransports(additionalImplementations, storage);\r\n    return storage.supportedTransports;\r\n  }\r\n\r\n  private static initTransports(additionalImplementations: TransportImplementations, storage: TransportStorage) {\r\n    const implementations = { ...Platform.Transports.bundledImplementations, ...additionalImplementations };\r\n\r\n    [TransportNames.WebSocket, ...Platform.Transports.order].forEach((transportName) => {\r\n      const transport = implementations[transportName];\r\n      if (transport && transport.isAvailable()) {\r\n        storage.supportedTransports[transportName] = transport;\r\n      }\r\n    });\r\n  }\r\n\r\n  initTransports() {\r\n    ConnectionManager.initTransports(this.realtime._additionalTransportImplementations, this);\r\n  }\r\n\r\n  createTransportParams(host: string | null, mode: string): TransportParams {\r\n    return new TransportParams(this.options, host, mode, this.connectionKey);\r\n  }\r\n\r\n  getTransportParams(callback: Function): void {\r\n    const decideMode = (modeCb: Function) => {\r\n      if (this.connectionKey) {\r\n        modeCb('resume');\r\n        return;\r\n      }\r\n\r\n      if (typeof this.options.recover === 'string') {\r\n        modeCb('recover');\r\n        return;\r\n      }\r\n\r\n      const recoverFn = this.options.recover,\r\n        lastSessionData = getSessionRecoverData();\r\n      if (lastSessionData && typeof recoverFn === 'function') {\r\n        Logger.logAction(\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager.getTransportParams()',\r\n          'Calling clientOptions-provided recover function with last session data',\r\n        );\r\n        recoverFn(lastSessionData, (shouldRecover?: boolean) => {\r\n          if (shouldRecover) {\r\n            this.options.recover = lastSessionData.recoveryKey;\r\n            modeCb('recover');\r\n          } else {\r\n            modeCb('clean');\r\n          }\r\n        });\r\n        return;\r\n      }\r\n      modeCb('clean');\r\n    };\r\n\r\n    decideMode((mode: string) => {\r\n      const transportParams = this.createTransportParams(null, mode);\r\n      if (mode === 'recover') {\r\n        Logger.logAction(\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager.getTransportParams()',\r\n          'Transport recovery mode = recover; recoveryKey = ' + this.options.recover,\r\n        );\r\n        const recoveryContext = decodeRecoveryKey(this.options.recover);\r\n        if (recoveryContext) {\r\n          this.msgSerial = recoveryContext.msgSerial;\r\n        }\r\n      } else {\r\n        Logger.logAction(\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager.getTransportParams()',\r\n          'Transport params = ' + transportParams.toString(),\r\n        );\r\n      }\r\n      callback(transportParams);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Attempt to connect using a given transport\r\n   * @param transportParams\r\n   * @param candidate, the transport to try\r\n   * @param callback\r\n   */\r\n  tryATransport(transportParams: TransportParams, candidate: TransportName, callback: Function): void {\r\n    Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.tryATransport()', 'trying ' + candidate);\r\n\r\n    this.proposedTransport = Transport.tryConnect(\r\n      this.supportedTransports[candidate]!,\r\n      this,\r\n      this.realtime.auth,\r\n      transportParams,\r\n      (wrappedErr: { error: ErrorInfo; event: string } | null, transport?: Transport) => {\r\n        const state = this.state;\r\n        if (state == this.states.closing || state == this.states.closed || state == this.states.failed) {\r\n          if (transport) {\r\n            Logger.logAction(\r\n              Logger.LOG_MINOR,\r\n              'ConnectionManager.tryATransport()',\r\n              'connection ' + state.state + ' while we were attempting the transport; closing ' + transport,\r\n            );\r\n            transport.close();\r\n          }\r\n          callback(true);\r\n          return;\r\n        }\r\n\r\n        if (wrappedErr) {\r\n          Logger.logAction(\r\n            Logger.LOG_MINOR,\r\n            'ConnectionManager.tryATransport()',\r\n            'transport ' + candidate + ' ' + wrappedErr.event + ', err: ' + wrappedErr.error.toString(),\r\n          );\r\n\r\n          /* Comet transport onconnect token errors can be dealt with here.\r\n           * Websocket ones only happen after the transport claims to be viable,\r\n           * so are dealt with as non-onconnect token errors */\r\n          if (\r\n            Auth.isTokenErr(wrappedErr.error) &&\r\n            !(this.errorReason && Auth.isTokenErr(this.errorReason as ErrorInfo))\r\n          ) {\r\n            this.errorReason = wrappedErr.error;\r\n            /* re-get a token and try again */\r\n            Utils.whenPromiseSettles(this.realtime.auth._forceNewToken(null, null), (err: ErrorInfo | null) => {\r\n              if (err) {\r\n                this.actOnErrorFromAuthorize(err);\r\n                return;\r\n              }\r\n              this.tryATransport(transportParams, candidate, callback);\r\n            });\r\n          } else if (wrappedErr.event === 'failed') {\r\n            /* Error that's fatal to the connection */\r\n            this.notifyState({ state: 'failed', error: wrappedErr.error });\r\n            callback(true);\r\n          } else if (wrappedErr.event === 'disconnected') {\r\n            if (!isRetriable(wrappedErr.error)) {\r\n              /* Error received from the server that does not call for trying a fallback host, eg a rate limit */\r\n              this.notifyState({ state: this.states.connecting.failState as string, error: wrappedErr.error });\r\n              callback(true);\r\n            } else {\r\n              /* Error with that transport only; continue trying other fallback hosts */\r\n              callback(false);\r\n            }\r\n          }\r\n          return;\r\n        }\r\n\r\n        Logger.logAction(\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.tryATransport()',\r\n          'viable transport ' + candidate + '; setting pending',\r\n        );\r\n        this.setTransportPending(transport as Transport, transportParams);\r\n        callback(null, transport);\r\n      },\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Called when a transport is indicated to be viable, and the ConnectionManager\r\n   * expects to activate this transport as soon as it is connected.\r\n   * @param transport\r\n   * @param transportParams\r\n   */\r\n  setTransportPending(transport: Transport, transportParams: TransportParams): void {\r\n    const mode = transportParams.mode;\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.setTransportPending()',\r\n      'transport = ' + transport + '; mode = ' + mode,\r\n    );\r\n\r\n    this.pendingTransport = transport;\r\n\r\n    this.cancelWebSocketSlowTimer();\r\n    this.cancelWebSocketGiveUpTimer();\r\n\r\n    transport.once('connected', (error: ErrorInfo, connectionId: string, connectionDetails: Record<string, any>) => {\r\n      this.activateTransport(error, transport, connectionId, connectionDetails);\r\n\r\n      if (mode === 'recover' && this.options.recover) {\r\n        /* After a successful recovery, we unpersist, as a recovery key cannot\r\n         * be used more than once */\r\n        delete this.options.recover;\r\n        this.unpersistConnection();\r\n      }\r\n    });\r\n\r\n    const self = this;\r\n    transport.on(['disconnected', 'closed', 'failed'], function (this: { event: string }, error: ErrorInfo) {\r\n      self.deactivateTransport(transport, this.event, error);\r\n    });\r\n\r\n    this.emit('transport.pending', transport);\r\n  }\r\n\r\n  /**\r\n   * Called when a transport is connected, and the connectionmanager decides that\r\n   * it will now be the active transport. Returns whether or not it activated\r\n   * the transport (if the connection is closing/closed it will choose not to).\r\n   * @param transport the transport instance\r\n   * @param connectionId the id of the new active connection\r\n   * @param connectionDetails the details of the new active connection\r\n   */\r\n  activateTransport(\r\n    error: ErrorInfo,\r\n    transport: Transport,\r\n    connectionId: string,\r\n    connectionDetails: Record<string, any>,\r\n  ): boolean {\r\n    Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.activateTransport()', 'transport = ' + transport);\r\n    if (error) {\r\n      Logger.logAction(Logger.LOG_ERROR, 'ConnectionManager.activateTransport()', 'error = ' + error);\r\n    }\r\n    if (connectionId) {\r\n      Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionId =  ' + connectionId);\r\n    }\r\n    if (connectionDetails) {\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.activateTransport()',\r\n        'connectionDetails =  ' + JSON.stringify(connectionDetails),\r\n      );\r\n    }\r\n\r\n    this.persistTransportPreference(transport);\r\n\r\n    /* if the connectionmanager moved to the closing/closed state before this\r\n     * connection event, then we won't activate this transport */\r\n    const existingState = this.state,\r\n      connectedState = this.states.connected.state;\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.activateTransport()',\r\n      'current state = ' + existingState.state,\r\n    );\r\n    if (\r\n      existingState.state == this.states.closing.state ||\r\n      existingState.state == this.states.closed.state ||\r\n      existingState.state == this.states.failed.state\r\n    ) {\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.activateTransport()',\r\n        'Disconnecting transport and abandoning',\r\n      );\r\n      transport.disconnect();\r\n      return false;\r\n    }\r\n\r\n    delete this.pendingTransport;\r\n\r\n    /* if the transport is not connected then don't activate it */\r\n    if (!transport.isConnected) {\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.activateTransport()',\r\n        'Declining to activate transport ' + transport + ' since it appears to no longer be connected',\r\n      );\r\n      return false;\r\n    }\r\n\r\n    /* the given transport is connected; this will immediately\r\n     * take over as the active transport */\r\n    const existingActiveProtocol = this.activeProtocol;\r\n    this.activeProtocol = new Protocol(transport);\r\n    this.host = transport.params.host;\r\n\r\n    const connectionKey = connectionDetails.connectionKey;\r\n    if (connectionKey && this.connectionKey != connectionKey) {\r\n      this.setConnection(connectionId, connectionDetails, !!error);\r\n    }\r\n\r\n    /* Rebroadcast any new connectionDetails from the active transport, which\r\n     * can come at any time (eg following a reauth), and emit an RTN24 UPDATE\r\n     * event. (Listener added on nextTick because we're in a transport.on('connected')\r\n     * callback at the moment; if we add it now we'll be adding it to the end\r\n     * of the listeners array and it'll be called immediately) */\r\n    this.onConnectionDetailsUpdate(connectionDetails, transport);\r\n    Platform.Config.nextTick(() => {\r\n      transport.on(\r\n        'connected',\r\n        (connectedErr: ErrorInfo, _connectionId: string, connectionDetails: Record<string, any>) => {\r\n          this.onConnectionDetailsUpdate(connectionDetails, transport);\r\n          this.emit('update', new ConnectionStateChange(connectedState, connectedState, null, connectedErr));\r\n        },\r\n      );\r\n    });\r\n\r\n    /* If previously not connected, notify the state change (including any\r\n     * error). */\r\n    if (existingState.state === this.states.connected.state) {\r\n      if (error) {\r\n        this.errorReason = this.realtime.connection.errorReason = error;\r\n        this.emit('update', new ConnectionStateChange(connectedState, connectedState, null, error));\r\n      }\r\n    } else {\r\n      this.notifyState({ state: 'connected', error: error });\r\n      this.errorReason = this.realtime.connection.errorReason = error || null;\r\n    }\r\n\r\n    /* Send after the connection state update, as Channels hooks into this to\r\n     * resend attaches on a new transport if necessary */\r\n    this.emit('transport.active', transport);\r\n\r\n    /* Gracefully terminate existing protocol */\r\n    if (existingActiveProtocol) {\r\n      if (existingActiveProtocol.messageQueue.count() > 0) {\r\n        /* We could just requeue pending messages on the new transport, but\r\n         * actually this should never happen: transports should only take over\r\n         * from other active transports when upgrading, and upgrading waits for\r\n         * the old transport to be idle. So log an error. */\r\n        Logger.logAction(\r\n          Logger.LOG_ERROR,\r\n          'ConnectionManager.activateTransport()',\r\n          'Previous active protocol (for transport ' +\r\n            existingActiveProtocol.transport.shortName +\r\n            ', new one is ' +\r\n            transport.shortName +\r\n            ') finishing with ' +\r\n            existingActiveProtocol.messageQueue.count() +\r\n            ' messages still pending',\r\n        );\r\n      }\r\n      if (existingActiveProtocol.transport === transport) {\r\n        const msg =\r\n          'Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = ' +\r\n          transport.shortName +\r\n          '; stack = ' +\r\n          new Error().stack;\r\n        Logger.logAction(Logger.LOG_ERROR, 'ConnectionManager.activateTransport()', msg);\r\n      } else {\r\n        existingActiveProtocol.finish();\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Called when a transport is no longer the active transport. This can occur\r\n   * in any transport connection state.\r\n   * @param transport\r\n   */\r\n  deactivateTransport(transport: Transport, state: string, error: ErrorInfo): void {\r\n    const currentProtocol = this.activeProtocol,\r\n      wasActive = currentProtocol && currentProtocol.getTransport() === transport,\r\n      wasPending = transport === this.pendingTransport,\r\n      noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();\r\n\r\n    Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'transport = ' + transport);\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.deactivateTransport()',\r\n      'state = ' +\r\n        state +\r\n        (wasActive ? '; was active' : wasPending ? '; was pending' : '') +\r\n        (noTransportsScheduledForActivation ? '' : '; another transport is scheduled for activation'),\r\n    );\r\n    if (error && error.message)\r\n      Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'reason =  ' + error.message);\r\n\r\n    if (wasActive) {\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.deactivateTransport()',\r\n        'Getting, clearing, and requeuing ' +\r\n          (this.activeProtocol as Protocol).messageQueue.count() +\r\n          ' pending messages',\r\n      );\r\n      this.queuePendingMessages((currentProtocol as Protocol).getPendingMessages());\r\n      /* Clear any messages we requeue to allow the protocol to become idle.*/\r\n      (currentProtocol as Protocol).clearPendingMessages();\r\n      this.activeProtocol = this.host = null;\r\n    }\r\n\r\n    this.emit('transport.inactive', transport);\r\n\r\n    /* this transport state change is a state change for the connectionmanager if\r\n     * - the transport was the active transport and there are no transports\r\n     *   which are connected and scheduled for activation, just waiting for the\r\n     *   active transport to finish what its doing; or\r\n     * - the transport was the active transport and the error was fatal (so\r\n     *   unhealable by another transport); or\r\n     * - there is no active transport, and this is the last remaining\r\n     *   pending transport (so we were in the connecting state)\r\n     */\r\n    if (\r\n      (wasActive && noTransportsScheduledForActivation) ||\r\n      (wasActive && state === 'failed') ||\r\n      state === 'closed' ||\r\n      (currentProtocol === null && wasPending)\r\n    ) {\r\n      /* If we're disconnected with a 5xx we need to try fallback hosts\r\n       * (RTN14d), but (a) due to how the upgrade sequence works, the\r\n       * host/transport selection sequence only cares about getting to\r\n       * `preconnect` (eg establishing a websocket) getting a `disconnected`\r\n       * protocol message afterwards is too late; and (b) host retry only\r\n       * applies to connectBase unless the stored preference transport doesn't\r\n       * work. We solve this by unpersisting the transport preference and\r\n       * setting an instance variable to force fallback hosts to be used (if\r\n       * any) here. Bit of a kludge, but no real better alternatives without\r\n       * rewriting the entire thing */\r\n      if (state === 'disconnected' && error && (error.statusCode as number) > 500 && this.httpHosts.length > 1) {\r\n        this.unpersistTransportPreference();\r\n        this.forceFallbackHost = true;\r\n        /* and try to connect again to try a fallback host without waiting for the usual 15s disconnectedRetryTimeout */\r\n        this.notifyState({ state: state, error: error, retryImmediately: true });\r\n        return;\r\n      }\r\n\r\n      /* TODO remove below line once realtime sends token errors as DISCONNECTEDs */\r\n      const newConnectionState = state === 'failed' && Auth.isTokenErr(error) ? 'disconnected' : state;\r\n      this.notifyState({ state: newConnectionState, error: error });\r\n      return;\r\n    }\r\n  }\r\n\r\n  /* Helper that returns true if there are no transports which are pending,\r\n   * have been connected, and are just waiting for onceNoPending to fire before\r\n   * being activated */\r\n  noTransportsScheduledForActivation(): boolean {\r\n    return !this.pendingTransport || !this.pendingTransport.isConnected;\r\n  }\r\n\r\n  setConnection(connectionId: string, connectionDetails: Record<string, any>, hasConnectionError?: boolean): void {\r\n    /* if connectionKey changes but connectionId stays the same, then just a\r\n     * transport change on the same connection. If connectionId changes, we're\r\n     * on a new connection, with implications for msgSerial and channel state */\r\n    /* If no previous connectionId, don't reset the msgSerial as it may have\r\n     * been set by recover data (unless the recover failed) */\r\n    const prevConnId = this.connectionId,\r\n      connIdChanged = prevConnId && prevConnId !== connectionId,\r\n      recoverFailure = !prevConnId && hasConnectionError;\r\n    if (connIdChanged || recoverFailure) {\r\n      Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.setConnection()', 'Resetting msgSerial');\r\n      this.msgSerial = 0;\r\n      // RTN19a2: In the event of a new connectionId, previous msgSerials are\r\n      // meaningless.\r\n      this.queuedMessages.resetSendAttempted();\r\n    }\r\n    if (this.connectionId !== connectionId) {\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.setConnection()',\r\n        'New connectionId; reattaching any attached channels',\r\n      );\r\n    }\r\n    this.realtime.connection.id = this.connectionId = connectionId;\r\n    this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;\r\n  }\r\n\r\n  clearConnection(): void {\r\n    this.realtime.connection.id = this.connectionId = undefined;\r\n    this.realtime.connection.key = this.connectionKey = undefined;\r\n    this.msgSerial = 0;\r\n    this.unpersistConnection();\r\n  }\r\n\r\n  createRecoveryKey(): string | null {\r\n    // RTN16g2.\r\n    if (!this.connectionKey) {\r\n      return null;\r\n    }\r\n\r\n    return JSON.stringify({\r\n      connectionKey: this.connectionKey,\r\n      msgSerial: this.msgSerial,\r\n      channelSerials: this.realtime.channels.channelSerials(),\r\n    });\r\n  }\r\n\r\n  checkConnectionStateFreshness(): void {\r\n    if (!this.lastActivity || !this.connectionId) {\r\n      return;\r\n    }\r\n\r\n    const sinceLast = Date.now() - this.lastActivity;\r\n    if (sinceLast > this.connectionStateTtl + (this.maxIdleInterval as number)) {\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.checkConnectionStateFreshness()',\r\n        'Last known activity from realtime was ' + sinceLast + 'ms ago; discarding connection state',\r\n      );\r\n      this.clearConnection();\r\n      this.states.connecting.failState = 'suspended';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the connectionmanager wants to persist transport\r\n   * state for later recovery. Only applicable in the browser context.\r\n   */\r\n  persistConnection(): void {\r\n    if (haveSessionStorage()) {\r\n      const recoveryKey = this.createRecoveryKey();\r\n      if (recoveryKey) {\r\n        setSessionRecoverData({\r\n          recoveryKey: recoveryKey,\r\n          disconnectedAt: Date.now(),\r\n          location: globalObject.location,\r\n          clientId: this.realtime.auth.clientId,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the connectionmanager wants to persist transport\r\n   * state for later recovery. Only applicable in the browser context.\r\n   */\r\n  unpersistConnection(): void {\r\n    clearSessionRecoverData();\r\n  }\r\n\r\n  /*********************\r\n   * state management\r\n   *********************/\r\n\r\n  getError(): IPartialErrorInfo | string {\r\n    return this.errorReason || this.getStateError();\r\n  }\r\n\r\n  getStateError(): ErrorInfo {\r\n    return (ConnectionErrors as Record<string, () => ErrorInfo>)[this.state.state]?.();\r\n  }\r\n\r\n  activeState(): boolean | void {\r\n    return this.state.queueEvents || this.state.sendEvents;\r\n  }\r\n\r\n  enactStateChange(stateChange: ConnectionStateChange): void {\r\n    const action = 'Connection state';\r\n    const message = stateChange.current + (stateChange.reason ? '; reason: ' + stateChange.reason : '');\r\n    if (stateChange.current === 'failed') {\r\n      Logger.logAction(Logger.LOG_ERROR, action, message);\r\n    } else {\r\n      Logger.logAction(Logger.LOG_MAJOR, action, message);\r\n    }\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.enactStateChange',\r\n      'setting new state: ' +\r\n        stateChange.current +\r\n        '; reason = ' +\r\n        (stateChange.reason && (stateChange.reason as ErrorInfo).message),\r\n    );\r\n    const newState = (this.state = this.states[stateChange.current as string]);\r\n    if (stateChange.reason) {\r\n      this.errorReason = stateChange.reason;\r\n      // TODO remove this type assertion after fixing https://github.com/ably/ably-js/issues/1405\r\n      this.realtime.connection.errorReason = stateChange.reason as ErrorInfo;\r\n    }\r\n    if (newState.terminal || newState.state === 'suspended') {\r\n      /* suspended is nonterminal, but once in the suspended state, realtime\r\n       * will have discarded our connection state, so futher connection\r\n       * attempts should start from scratch */\r\n      this.clearConnection();\r\n    }\r\n    this.emit('connectionstate', stateChange);\r\n  }\r\n\r\n  /****************************************\r\n   * ConnectionManager connection lifecycle\r\n   ****************************************/\r\n\r\n  startTransitionTimer(transitionState: ConnectionState): void {\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.startTransitionTimer()',\r\n      'transitionState: ' + transitionState.state,\r\n    );\r\n\r\n    if (this.transitionTimer) {\r\n      Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'clearing already-running timer');\r\n      clearTimeout(this.transitionTimer as number);\r\n    }\r\n\r\n    this.transitionTimer = setTimeout(() => {\r\n      if (this.transitionTimer) {\r\n        this.transitionTimer = null;\r\n        Logger.logAction(\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager ' + transitionState.state + ' timer expired',\r\n          'requesting new state: ' + transitionState.failState,\r\n        );\r\n        this.notifyState({ state: transitionState.failState as string });\r\n      }\r\n    }, transitionState.retryDelay);\r\n  }\r\n\r\n  cancelTransitionTimer(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.cancelTransitionTimer()', '');\r\n    if (this.transitionTimer) {\r\n      clearTimeout(this.transitionTimer as number);\r\n      this.transitionTimer = null;\r\n    }\r\n  }\r\n\r\n  startSuspendTimer(): void {\r\n    if (this.suspendTimer) return;\r\n    this.suspendTimer = setTimeout(() => {\r\n      if (this.suspendTimer) {\r\n        this.suspendTimer = null;\r\n        Logger.logAction(\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager suspend timer expired',\r\n          'requesting new state: suspended',\r\n        );\r\n        this.states.connecting.failState = 'suspended';\r\n        this.notifyState({ state: 'suspended' });\r\n      }\r\n    }, this.connectionStateTtl);\r\n  }\r\n\r\n  checkSuspendTimer(state: string): void {\r\n    if (state !== 'disconnected' && state !== 'suspended' && state !== 'connecting') this.cancelSuspendTimer();\r\n  }\r\n\r\n  cancelSuspendTimer(): void {\r\n    this.states.connecting.failState = 'disconnected';\r\n    if (this.suspendTimer) {\r\n      clearTimeout(this.suspendTimer as number);\r\n      this.suspendTimer = null;\r\n    }\r\n  }\r\n\r\n  startRetryTimer(interval: number): void {\r\n    this.retryTimer = setTimeout(() => {\r\n      Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager retry timer expired', 'retrying');\r\n      this.retryTimer = null;\r\n      this.requestState({ state: 'connecting' });\r\n    }, interval);\r\n  }\r\n\r\n  cancelRetryTimer(): void {\r\n    if (this.retryTimer) {\r\n      clearTimeout(this.retryTimer as NodeJS.Timeout);\r\n      this.retryTimer = null;\r\n    }\r\n  }\r\n\r\n  startWebSocketSlowTimer() {\r\n    this.webSocketSlowTimer = setTimeout(() => {\r\n      Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager WebSocket slow timer', 'checking connectivity');\r\n      if (this.wsCheckResult === null) {\r\n        this.checkWsConnectivity()\r\n          .then(() => {\r\n            Logger.logAction(\r\n              Logger.LOG_MINOR,\r\n              'ConnectionManager WebSocket slow timer',\r\n              'ws connectivity check succeeded',\r\n            );\r\n            this.wsCheckResult = true;\r\n          })\r\n          .catch(() => {\r\n            Logger.logAction(\r\n              Logger.LOG_MAJOR,\r\n              'ConnectionManager WebSocket slow timer',\r\n              'ws connectivity check failed',\r\n            );\r\n            this.wsCheckResult = false;\r\n          });\r\n      }\r\n      if (this.realtime.http.checkConnectivity) {\r\n        Utils.whenPromiseSettles(this.realtime.http.checkConnectivity(), (err, connectivity) => {\r\n          if (err || !connectivity) {\r\n            Logger.logAction(\r\n              Logger.LOG_MAJOR,\r\n              'ConnectionManager WebSocket slow timer',\r\n              'http connectivity check failed',\r\n            );\r\n            this.cancelWebSocketGiveUpTimer();\r\n            this.notifyState({\r\n              state: 'disconnected',\r\n              error: new ErrorInfo(\"new ErrorInfo('Unable to connect (network unreachable)'\", 80003, 404),\r\n            });\r\n          } else {\r\n            Logger.logAction(\r\n              Logger.LOG_MINOR,\r\n              'ConnectionManager WebSocket slow timer',\r\n              'http connectivity check succeeded',\r\n            );\r\n          }\r\n        });\r\n      }\r\n    }, this.options.timeouts.webSocketSlowTimeout);\r\n  }\r\n\r\n  cancelWebSocketSlowTimer() {\r\n    if (this.webSocketSlowTimer) {\r\n      clearTimeout(this.webSocketSlowTimer);\r\n      this.webSocketSlowTimer = null;\r\n    }\r\n  }\r\n\r\n  startWebSocketGiveUpTimer(transportParams: TransportParams) {\r\n    this.webSocketGiveUpTimer = setTimeout(() => {\r\n      if (!this.wsCheckResult) {\r\n        Logger.logAction(\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager WebSocket give up timer',\r\n          'websocket connection took more than 10s; ' + (this.baseTransport ? 'trying base transport' : ''),\r\n        );\r\n        if (this.baseTransport) {\r\n          this.abandonedWebSocket = true;\r\n          this.proposedTransport?.dispose();\r\n          this.pendingTransport?.dispose();\r\n          this.connectBase(transportParams, ++this.connectCounter);\r\n        } else {\r\n          // if we don't have a base transport to fallback to, just let the websocket connection attempt time out\r\n          Logger.logAction(\r\n            Logger.LOG_MAJOR,\r\n            'ConnectionManager WebSocket give up timer',\r\n            'websocket connectivity appears to be unavailable but no other transports to try',\r\n          );\r\n        }\r\n      }\r\n    }, this.options.timeouts.webSocketConnectTimeout);\r\n  }\r\n\r\n  cancelWebSocketGiveUpTimer() {\r\n    if (this.webSocketGiveUpTimer) {\r\n      clearTimeout(this.webSocketGiveUpTimer);\r\n      this.webSocketGiveUpTimer = null;\r\n    }\r\n  }\r\n\r\n  notifyState(indicated: ConnectionState): void {\r\n    const state = indicated.state;\r\n\r\n    /* We retry immediately if:\r\n     * - something disconnects us while we're connected, or\r\n     * - a viable (but not yet active) transport fails due to a token error (so\r\n     *   this.errorReason will be set, and startConnect will do a forced\r\n     *   authorize). If this.errorReason is already set (to a token error),\r\n     *   then there has been at least one previous attempt to connect that also\r\n     *   failed for a token error, so by RTN14b we go to DISCONNECTED and wait\r\n     *   before trying again */\r\n    const retryImmediately =\r\n      state === 'disconnected' &&\r\n      (this.state === this.states.connected ||\r\n        indicated.retryImmediately ||\r\n        (this.state === this.states.connecting &&\r\n          indicated.error &&\r\n          Auth.isTokenErr(indicated.error) &&\r\n          !(this.errorReason && Auth.isTokenErr(this.errorReason as ErrorInfo))));\r\n\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.notifyState()',\r\n      'new state: ' + state + (retryImmediately ? '; will retry connection immediately' : ''),\r\n    );\r\n    /* do nothing if we're already in the indicated state */\r\n    if (state == this.state.state) return;\r\n\r\n    /* kill timers (possibly excepting suspend timer depending on the notified\r\n     * state), as these are superseded by this notification */\r\n    this.cancelTransitionTimer();\r\n    this.cancelRetryTimer();\r\n    this.cancelWebSocketSlowTimer();\r\n    this.cancelWebSocketGiveUpTimer();\r\n    this.checkSuspendTimer(indicated.state);\r\n\r\n    if (state === 'suspended' || state === 'connected') {\r\n      this.disconnectedRetryCount = 0;\r\n    }\r\n\r\n    /* do nothing if we're unable to move from the current state */\r\n    if (this.state.terminal) return;\r\n\r\n    /* process new state */\r\n    const newState = this.states[indicated.state];\r\n\r\n    let retryDelay = newState.retryDelay;\r\n    if (newState.state === 'disconnected') {\r\n      this.disconnectedRetryCount++;\r\n      retryDelay = Utils.getRetryTime(newState.retryDelay as number, this.disconnectedRetryCount);\r\n    }\r\n\r\n    const change = new ConnectionStateChange(\r\n      this.state.state,\r\n      newState.state,\r\n      retryDelay,\r\n      indicated.error || (ConnectionErrors as Partial<Record<string, () => ErrorInfo>>)[newState.state]?.(),\r\n    );\r\n\r\n    if (retryImmediately) {\r\n      const autoReconnect = () => {\r\n        if (this.state === this.states.disconnected) {\r\n          this.lastAutoReconnectAttempt = Date.now();\r\n          this.requestState({ state: 'connecting' });\r\n        }\r\n      };\r\n      const sinceLast = this.lastAutoReconnectAttempt && Date.now() - this.lastAutoReconnectAttempt + 1;\r\n      if (sinceLast && sinceLast < 1000) {\r\n        Logger.logAction(\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.notifyState()',\r\n          'Last reconnect attempt was only ' +\r\n            sinceLast +\r\n            'ms ago, waiting another ' +\r\n            (1000 - sinceLast) +\r\n            'ms before trying again',\r\n        );\r\n        setTimeout(autoReconnect, 1000 - sinceLast);\r\n      } else {\r\n        Platform.Config.nextTick(autoReconnect);\r\n      }\r\n    } else if (state === 'disconnected' || state === 'suspended') {\r\n      this.startRetryTimer(retryDelay as number);\r\n    }\r\n\r\n    /* If going into disconnect/suspended (and not retrying immediately), or a\r\n     * terminal state, ensure there are no orphaned transports hanging around. */\r\n    if ((state === 'disconnected' && !retryImmediately) || state === 'suspended' || newState.terminal) {\r\n      /* Wait till the next tick so the connection state change is enacted,\r\n       * so aborting transports doesn't trigger redundant state changes */\r\n      Platform.Config.nextTick(() => {\r\n        this.disconnectAllTransports();\r\n      });\r\n    }\r\n\r\n    if (state == 'connected' && !this.activeProtocol) {\r\n      Logger.logAction(\r\n        Logger.LOG_ERROR,\r\n        'ConnectionManager.notifyState()',\r\n        'Broken invariant: attempted to go into connected state, but there is no active protocol',\r\n      );\r\n    }\r\n\r\n    /* implement the change and notify */\r\n    this.enactStateChange(change);\r\n    if (this.state.sendEvents) {\r\n      this.sendQueuedMessages();\r\n    } else if (!this.state.queueEvents) {\r\n      this.realtime.channels.propogateConnectionInterruption(state, change.reason);\r\n      this.failQueuedMessages(change.reason as ErrorInfo); // RTN7c\r\n    }\r\n  }\r\n\r\n  requestState(request: any): void {\r\n    const state = request.state;\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.requestState()',\r\n      'requested state: ' + state + '; current state: ' + this.state.state,\r\n    );\r\n    if (state == this.state.state) return; /* silently do nothing */\r\n\r\n    /* kill running timers, as this request supersedes them */\r\n    this.cancelWebSocketSlowTimer();\r\n    this.cancelWebSocketGiveUpTimer();\r\n    this.cancelTransitionTimer();\r\n    this.cancelRetryTimer();\r\n    /* for suspend timer check rather than cancel -- eg requesting a connecting\r\n     * state should not reset the suspend timer */\r\n    this.checkSuspendTimer(state);\r\n\r\n    if (state == 'connecting' && this.state.state == 'connected') return;\r\n    if (state == 'closing' && this.state.state == 'closed') return;\r\n\r\n    const newState = this.states[state],\r\n      change = new ConnectionStateChange(\r\n        this.state.state,\r\n        newState.state,\r\n        null,\r\n        request.error || (ConnectionErrors as Partial<Record<string, () => ErrorInfo>>)[newState.state]?.(),\r\n      );\r\n\r\n    this.enactStateChange(change);\r\n\r\n    if (state == 'connecting') {\r\n      Platform.Config.nextTick(() => {\r\n        this.startConnect();\r\n      });\r\n    }\r\n    if (state == 'closing') {\r\n      this.closeImpl();\r\n    }\r\n  }\r\n\r\n  startConnect(): void {\r\n    if (this.state !== this.states.connecting) {\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.startConnect()',\r\n        'Must be in connecting state to connect, but was ' + this.state.state,\r\n      );\r\n      return;\r\n    }\r\n\r\n    const auth = this.realtime.auth;\r\n\r\n    /* The point of the connectCounter mechanism is to ensure that the\r\n     * connection procedure can be cancelled. We want disconnectAllTransports\r\n     * to be able to stop any in-progress connection, even before it gets to\r\n     * the stage of having a pending (or even a proposed) transport that it can\r\n     * dispose() of. So we check that it's still current after any async stage,\r\n     * up until the stage that is synchronous with instantiating a transport */\r\n    const connectCount = ++this.connectCounter;\r\n\r\n    const connect = () => {\r\n      this.checkConnectionStateFreshness();\r\n      this.getTransportParams((transportParams: TransportParams) => {\r\n        if (transportParams.mode === 'recover' && transportParams.options.recover) {\r\n          const recoveryContext = decodeRecoveryKey(transportParams.options.recover);\r\n          if (recoveryContext) {\r\n            this.realtime.channels.recoverChannels(recoveryContext.channelSerials);\r\n          }\r\n        }\r\n\r\n        if (connectCount !== this.connectCounter) {\r\n          return;\r\n        }\r\n        this.connectImpl(transportParams, connectCount);\r\n      });\r\n    };\r\n\r\n    Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.startConnect()', 'starting connection');\r\n    this.startSuspendTimer();\r\n    this.startTransitionTimer(this.states.connecting);\r\n\r\n    if (auth.method === 'basic') {\r\n      connect();\r\n    } else {\r\n      const authCb = (err: ErrorInfo | null) => {\r\n        if (connectCount !== this.connectCounter) {\r\n          return;\r\n        }\r\n        if (err) {\r\n          this.actOnErrorFromAuthorize(err);\r\n        } else {\r\n          connect();\r\n        }\r\n      };\r\n      if (this.errorReason && Auth.isTokenErr(this.errorReason as ErrorInfo)) {\r\n        /* Force a refetch of a new token */\r\n        Utils.whenPromiseSettles(auth._forceNewToken(null, null), authCb);\r\n      } else {\r\n        Utils.whenPromiseSettles(auth._ensureValidAuthCredentials(false), authCb);\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n   * there are, at most, two transports available with which a connection may\r\n   * be attempted: web_socket and/or a base transport (xhr_polling in browsers,\r\n   * comet in nodejs). web_socket is always preferred, and the base transport is\r\n   * only used in case web_socket connectivity appears to be unavailable.\r\n   *\r\n   * connectImpl begins the transport selection process by checking which transports\r\n   * are available, and if there is a cached preference. It then defers to the\r\n   * transport-specific connect methods: connectWs and connectBase.\r\n   *\r\n   * It is also responsible for invalidating the cache in the case that a base\r\n   * transport preference is stored but web socket connectivity is now available.\r\n   *\r\n   * handling of the case where we need to failover from web_socket to the base\r\n   * transport is implemented in the connectWs method.\r\n   */\r\n  connectImpl(transportParams: TransportParams, connectCount: number): void {\r\n    const state = this.state.state;\r\n    if (state !== this.states.connecting.state) {\r\n      /* Only keep trying as long as in the 'connecting' state (or 'connected'\r\n       * for upgrading). Any operation can put us into 'disconnected' to cancel\r\n       * connection attempts and wait before retrying, or 'failed' to fail. */\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.connectImpl()',\r\n        'Must be in connecting state to connect, but was ' + state,\r\n      );\r\n      return;\r\n    }\r\n\r\n    const transportPreference = this.getTransportPreference();\r\n\r\n    // If transport preference is for a non-ws transport but websocket is now available, unpersist the preference for next time\r\n    if (transportPreference && transportPreference === this.baseTransport && this.webSocketTransportAvailable) {\r\n      this.checkWsConnectivity()\r\n        .then(() => {\r\n          this.wsCheckResult = true;\r\n          this.abandonedWebSocket = false;\r\n          this.unpersistTransportPreference();\r\n          if (this.state === this.states.connecting) {\r\n            Logger.logAction(\r\n              Logger.LOG_MINOR,\r\n              'ConnectionManager.connectImpl():',\r\n              'web socket connectivity available, cancelling connection attempt with ' + this.baseTransport,\r\n            );\r\n            this.disconnectAllTransports();\r\n            this.connectWs(transportParams, ++this.connectCounter);\r\n          }\r\n        })\r\n        .catch(noop);\r\n    }\r\n\r\n    if (\r\n      (transportPreference && transportPreference === this.baseTransport) ||\r\n      (this.baseTransport && !this.webSocketTransportAvailable)\r\n    ) {\r\n      this.connectBase(transportParams, connectCount);\r\n    } else {\r\n      this.connectWs(transportParams, connectCount);\r\n    }\r\n  }\r\n\r\n  /*\r\n   * connectWs starts two timers to monitor the success of a web_socket connection attempt:\r\n   * - webSocketSlowTimer: if this timer fires before the connection succeeds,\r\n   *   cm will simultaneously check websocket and http/xhr connectivity. if the http\r\n   *   connectivity check fails, we give up the connection sequence entirely and\r\n   *   transition to disconnected. if the websocket connectivity check fails then\r\n   *   we assume no ws connectivity and failover to base transport. in the case that\r\n   *   the checks succeed, we continue with websocket and wait for it to try fallback hosts\r\n   *   and, if unsuccessful, ultimately transition to disconnected.\r\n   * - webSocketGiveUpTimer: if this timer fires, and the preceding websocket\r\n   *   connectivity check is still pending then we assume that there is an issue\r\n   *   with the transport and fallback to base transport.\r\n   */\r\n  connectWs(transportParams: TransportParams, connectCount: number) {\r\n    Logger.logAction(Logger.LOG_DEBUG, 'ConnectionManager.connectWs()');\r\n    this.startWebSocketSlowTimer();\r\n    this.startWebSocketGiveUpTimer(transportParams);\r\n\r\n    this.tryTransportWithFallbacks('web_socket', transportParams, true, connectCount, () => {\r\n      return this.wsCheckResult !== false && !this.abandonedWebSocket;\r\n    });\r\n  }\r\n\r\n  connectBase(transportParams: TransportParams, connectCount: number) {\r\n    Logger.logAction(Logger.LOG_DEBUG, 'ConnectionManager.connectBase()');\r\n    if (this.baseTransport) {\r\n      this.tryTransportWithFallbacks(this.baseTransport, transportParams, false, connectCount, () => true);\r\n    } else {\r\n      this.notifyState({\r\n        state: 'disconnected',\r\n        error: new ErrorInfo('No transports left to try', 80000, 404),\r\n      });\r\n    }\r\n  }\r\n\r\n  tryTransportWithFallbacks(\r\n    transportName: TransportName,\r\n    transportParams: TransportParams,\r\n    ws: boolean,\r\n    connectCount: number,\r\n    shouldContinue: () => boolean,\r\n  ): void {\r\n    Logger.logAction(Logger.LOG_DEBUG, 'ConnectionManager.tryTransportWithFallbacks()', transportName);\r\n    const giveUp = (err: IPartialErrorInfo) => {\r\n      this.notifyState({ state: this.states.connecting.failState as string, error: err });\r\n    };\r\n\r\n    const candidateHosts = ws ? this.wsHosts.slice() : this.httpHosts.slice();\r\n\r\n    const hostAttemptCb = (fatal: boolean, transport: Transport) => {\r\n      if (connectCount !== this.connectCounter) {\r\n        return;\r\n      }\r\n      if (!shouldContinue()) {\r\n        if (transport) {\r\n          transport.dispose();\r\n        }\r\n        return;\r\n      }\r\n      if (!transport && !fatal) {\r\n        tryFallbackHosts();\r\n      }\r\n    };\r\n\r\n    /* first try to establish a connection with the priority host with http transport */\r\n    const host = candidateHosts.shift();\r\n    if (!host) {\r\n      giveUp(new ErrorInfo('Unable to connect (no available host)', 80003, 404));\r\n      return;\r\n    }\r\n    transportParams.host = host;\r\n\r\n    /* this is what we'll be doing if the attempt for the main host fails */\r\n    const tryFallbackHosts = () => {\r\n      /* if there aren't any fallback hosts, fail */\r\n      if (!candidateHosts.length) {\r\n        giveUp(new ErrorInfo('Unable to connect (and no more fallback hosts to try)', 80003, 404));\r\n        return;\r\n      }\r\n      /* before trying any fallback (or any remaining fallback) we decide if\r\n       * there is a problem with the ably host, or there is a general connectivity\r\n       * problem */\r\n      if (!this.realtime.http.checkConnectivity) {\r\n        giveUp(new PartialErrorInfo('Internal error: Http.checkConnectivity not set', null, 500));\r\n        return;\r\n      }\r\n      Utils.whenPromiseSettles(\r\n        this.realtime.http.checkConnectivity(),\r\n        (err?: ErrorInfo | null, connectivity?: boolean) => {\r\n          if (connectCount !== this.connectCounter) {\r\n            return;\r\n          }\r\n          if (!shouldContinue()) {\r\n            return;\r\n          }\r\n          /* we know err won't happen but handle it here anyway */\r\n          if (err) {\r\n            giveUp(err);\r\n            return;\r\n          }\r\n          if (!connectivity) {\r\n            /* the internet isn't reachable, so don't try the fallback hosts */\r\n            giveUp(new ErrorInfo('Unable to connect (network unreachable)', 80003, 404));\r\n            return;\r\n          }\r\n          /* the network is there, so there's a problem with the main host, or\r\n           * its dns. Try the fallback hosts. We could try them simultaneously but\r\n           * that would potentially cause a huge spike in load on the load balancer */\r\n          transportParams.host = Utils.arrPopRandomElement(candidateHosts);\r\n          this.tryATransport(transportParams, transportName, hostAttemptCb);\r\n        },\r\n      );\r\n    };\r\n\r\n    if (this.forceFallbackHost && candidateHosts.length) {\r\n      this.forceFallbackHost = false;\r\n      tryFallbackHosts();\r\n      return;\r\n    }\r\n\r\n    this.tryATransport(transportParams, transportName, hostAttemptCb);\r\n  }\r\n\r\n  closeImpl(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.closeImpl()', 'closing connection');\r\n    this.cancelSuspendTimer();\r\n    this.startTransitionTimer(this.states.closing);\r\n\r\n    if (this.pendingTransport) {\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.closeImpl()',\r\n        'Closing pending transport: ' + this.pendingTransport,\r\n      );\r\n      this.pendingTransport.close();\r\n    }\r\n\r\n    if (this.activeProtocol) {\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.closeImpl()',\r\n        'Closing active transport: ' + this.activeProtocol.getTransport(),\r\n      );\r\n      this.activeProtocol.getTransport().close();\r\n    }\r\n\r\n    /* If there was an active transport, this will probably be\r\n     * preempted by the notifyState call in deactivateTransport */\r\n    this.notifyState({ state: 'closed' });\r\n  }\r\n\r\n  onAuthUpdated(tokenDetails: API.TokenDetails, callback: Function): void {\r\n    switch (this.state.state) {\r\n      case 'connected': {\r\n        Logger.logAction(\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.onAuthUpdated()',\r\n          'Sending AUTH message on active transport',\r\n        );\r\n\r\n        /* Do any transport-specific new-token action */\r\n        const activeTransport = this.activeProtocol?.getTransport();\r\n        if (activeTransport && activeTransport.onAuthUpdated) {\r\n          activeTransport.onAuthUpdated(tokenDetails);\r\n        }\r\n\r\n        const authMsg = protocolMessageFromValues({\r\n          action: actions.AUTH,\r\n          auth: {\r\n            accessToken: tokenDetails.token,\r\n          },\r\n        });\r\n        this.send(authMsg);\r\n\r\n        /* The answer will come back as either a connectiondetails event\r\n         * (realtime sends a CONNECTED to acknowledge the reauth) or a\r\n         * statechange to failed */\r\n        const successListener = () => {\r\n          this.off(failureListener);\r\n          callback(null, tokenDetails);\r\n        };\r\n        const failureListener = (stateChange: ConnectionStateChange) => {\r\n          if (stateChange.current === 'failed') {\r\n            this.off(successListener);\r\n            this.off(failureListener);\r\n            callback(stateChange.reason || this.getStateError());\r\n          }\r\n        };\r\n        this.once('connectiondetails', successListener);\r\n        this.on('connectionstate', failureListener);\r\n        break;\r\n      }\r\n\r\n      case 'connecting':\r\n        Logger.logAction(\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.onAuthUpdated()',\r\n          'Aborting current connection attempts in order to start again with the new auth details',\r\n        );\r\n        this.disconnectAllTransports();\r\n      /* fallthrough to add statechange listener */\r\n\r\n      default: {\r\n        Logger.logAction(\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.onAuthUpdated()',\r\n          'Connection state is ' + this.state.state + '; waiting until either connected or failed',\r\n        );\r\n        const listener = (stateChange: ConnectionStateChange) => {\r\n          switch (stateChange.current) {\r\n            case 'connected':\r\n              this.off(listener);\r\n              callback(null, tokenDetails);\r\n              break;\r\n            case 'failed':\r\n            case 'closed':\r\n            case 'suspended':\r\n              this.off(listener);\r\n              callback(stateChange.reason || this.getStateError());\r\n              break;\r\n            default:\r\n              /* ignore till we get either connected or failed */\r\n              break;\r\n          }\r\n        };\r\n        this.on('connectionstate', listener);\r\n        if (this.state.state === 'connecting') {\r\n          /* can happen if in the connecting state but no transport was pending\r\n           * yet, so disconnectAllTransports did not trigger a disconnected state */\r\n          this.startConnect();\r\n        } else {\r\n          this.requestState({ state: 'connecting' });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  disconnectAllTransports(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting all transports');\r\n\r\n    /* This will prevent any connection procedure in an async part of one of its early stages from continuing */\r\n    this.connectCounter++;\r\n\r\n    if (this.pendingTransport) {\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.disconnectAllTransports()',\r\n        'Disconnecting pending transport: ' + this.pendingTransport,\r\n      );\r\n      this.pendingTransport.disconnect();\r\n    }\r\n    delete this.pendingTransport;\r\n\r\n    if (this.proposedTransport) {\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.disconnectAllTransports()',\r\n        'Disconnecting proposed transport: ' + this.pendingTransport,\r\n      );\r\n      this.proposedTransport.disconnect();\r\n    }\r\n    delete this.pendingTransport;\r\n\r\n    if (this.activeProtocol) {\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.disconnectAllTransports()',\r\n        'Disconnecting active transport: ' + this.activeProtocol.getTransport(),\r\n      );\r\n      this.activeProtocol.getTransport().disconnect();\r\n    }\r\n    /* No need to notify state disconnected; disconnecting the active transport\r\n     * will have that effect */\r\n  }\r\n\r\n  /******************\r\n   * event queueing\r\n   ******************/\r\n\r\n  send(msg: ProtocolMessage, queueEvent?: boolean, callback?: ErrCallback): void {\r\n    callback = callback || noop;\r\n    const state = this.state;\r\n\r\n    if (state.sendEvents) {\r\n      Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.send()', 'sending event');\r\n      this.sendImpl(new PendingMessage(msg, callback));\r\n      return;\r\n    }\r\n    const shouldQueue = queueEvent && state.queueEvents;\r\n    if (!shouldQueue) {\r\n      const err = 'rejecting event, queueEvent was ' + queueEvent + ', state was ' + state.state;\r\n      Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.send()', err);\r\n      callback(this.errorReason || new ErrorInfo(err, 90000, 400));\r\n      return;\r\n    }\r\n    if (Logger.shouldLog(Logger.LOG_MICRO)) {\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.send()',\r\n        'queueing msg; ' + stringifyProtocolMessage(msg, this.realtime._RealtimePresence),\r\n      );\r\n    }\r\n    this.queue(msg, callback);\r\n  }\r\n\r\n  sendImpl(pendingMessage: PendingMessage): void {\r\n    const msg = pendingMessage.message;\r\n    /* If have already attempted to send this, resend with the same msgSerial,\r\n     * so Ably can dedup if the previous send succeeded */\r\n    if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {\r\n      msg.msgSerial = this.msgSerial++;\r\n    }\r\n    try {\r\n      (this.activeProtocol as Protocol).send(pendingMessage);\r\n    } catch (e) {\r\n      Logger.logAction(\r\n        Logger.LOG_ERROR,\r\n        'ConnectionManager.sendImpl()',\r\n        'Unexpected exception in transport.send(): ' + (e as Error).stack,\r\n      );\r\n    }\r\n  }\r\n\r\n  queue(msg: ProtocolMessage, callback: ErrCallback): void {\r\n    Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.queue()', 'queueing event');\r\n    const lastQueued = this.queuedMessages.last();\r\n    const maxSize = this.options.maxMessageSize;\r\n    /* If have already attempted to send a message, don't merge more messages\r\n     * into it, as if the previous send actually succeeded and realtime ignores\r\n     * the dup, they'll be lost */\r\n    if (lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {\r\n      if (!lastQueued.merged) {\r\n        lastQueued.callback = Multicaster.create([lastQueued.callback]);\r\n        lastQueued.merged = true;\r\n      }\r\n      (lastQueued.callback as MulticasterInstance<void>).push(callback);\r\n    } else {\r\n      this.queuedMessages.push(new PendingMessage(msg, callback));\r\n    }\r\n  }\r\n\r\n  sendQueuedMessages(): void {\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'ConnectionManager.sendQueuedMessages()',\r\n      'sending ' + this.queuedMessages.count() + ' queued messages',\r\n    );\r\n    let pendingMessage;\r\n    while ((pendingMessage = this.queuedMessages.shift())) this.sendImpl(pendingMessage);\r\n  }\r\n\r\n  queuePendingMessages(pendingMessages: Array<PendingMessage>): void {\r\n    if (pendingMessages && pendingMessages.length) {\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.queuePendingMessages()',\r\n        'queueing ' + pendingMessages.length + ' pending messages',\r\n      );\r\n      this.queuedMessages.prepend(pendingMessages);\r\n    }\r\n  }\r\n\r\n  failQueuedMessages(err: ErrorInfo): void {\r\n    const numQueued = this.queuedMessages.count();\r\n    if (numQueued > 0) {\r\n      Logger.logAction(\r\n        Logger.LOG_ERROR,\r\n        'ConnectionManager.failQueuedMessages()',\r\n        'failing ' + numQueued + ' queued messages, err = ' + Utils.inspectError(err),\r\n      );\r\n      this.queuedMessages.completeAllMessages(err);\r\n    }\r\n  }\r\n\r\n  onChannelMessage(message: ProtocolMessage, transport: Transport): void {\r\n    this.pendingChannelMessagesState.queue.push({ message, transport });\r\n\r\n    if (!this.pendingChannelMessagesState.isProcessing) {\r\n      this.processNextPendingChannelMessage();\r\n    }\r\n  }\r\n\r\n  private processNextPendingChannelMessage() {\r\n    if (this.pendingChannelMessagesState.queue.length > 0) {\r\n      this.pendingChannelMessagesState.isProcessing = true;\r\n\r\n      const pendingChannelMessage = this.pendingChannelMessagesState.queue.shift()!;\r\n      this.processChannelMessage(pendingChannelMessage.message)\r\n        .catch((err) => {\r\n          Logger.logAction(\r\n            Logger.LOG_ERROR,\r\n            'ConnectionManager.processNextPendingChannelMessage() received error ',\r\n            err,\r\n          );\r\n        })\r\n        .finally(() => {\r\n          this.pendingChannelMessagesState.isProcessing = false;\r\n          this.processNextPendingChannelMessage();\r\n        });\r\n    }\r\n  }\r\n\r\n  private async processChannelMessage(message: ProtocolMessage) {\r\n    await this.realtime.channels.processChannelMessage(message);\r\n  }\r\n\r\n  ping(transport: Transport | null, callback: Function): void {\r\n    /* if transport is specified, try that */\r\n    if (transport) {\r\n      Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.ping()', 'transport = ' + transport);\r\n\r\n      const onTimeout = function () {\r\n        transport.off('heartbeat', onHeartbeat);\r\n        callback(new ErrorInfo('Timeout waiting for heartbeat response', 50000, 500));\r\n      };\r\n\r\n      const pingStart = Date.now(),\r\n        id = Utils.cheapRandStr();\r\n\r\n      const onHeartbeat = function (responseId: string) {\r\n        if (responseId === id) {\r\n          transport.off('heartbeat', onHeartbeat);\r\n          clearTimeout(timer);\r\n          const responseTime = Date.now() - pingStart;\r\n          callback(null, responseTime);\r\n        }\r\n      };\r\n\r\n      const timer = setTimeout(onTimeout, this.options.timeouts.realtimeRequestTimeout);\r\n\r\n      transport.on('heartbeat', onHeartbeat);\r\n      transport.ping(id);\r\n      return;\r\n    }\r\n\r\n    /* if we're not connected, don't attempt */\r\n    if (this.state.state !== 'connected') {\r\n      callback(new ErrorInfo('Unable to ping service; not connected', 40000, 400));\r\n      return;\r\n    }\r\n\r\n    /* no transport was specified, so use the current (connected) one\r\n     * but ensure that we retry if the transport is superseded before we complete */\r\n    let completed = false;\r\n\r\n    const onPingComplete = (err: Error, responseTime: number) => {\r\n      this.off('transport.active', onTransportActive);\r\n      if (!completed) {\r\n        completed = true;\r\n        callback(err, responseTime);\r\n      }\r\n    };\r\n\r\n    const onTransportActive = () => {\r\n      if (!completed) {\r\n        /* ensure that no callback happens for the currently outstanding operation */\r\n        completed = true;\r\n        /* repeat but picking up the new transport */\r\n        Platform.Config.nextTick(() => {\r\n          this.ping(null, callback);\r\n        });\r\n      }\r\n    };\r\n\r\n    this.on('transport.active', onTransportActive);\r\n    this.ping((this.activeProtocol as Protocol).getTransport(), onPingComplete);\r\n  }\r\n\r\n  abort(error: ErrorInfo): void {\r\n    (this.activeProtocol as Protocol).getTransport().fail(error);\r\n  }\r\n\r\n  getTransportPreference(): TransportName {\r\n    return this.transportPreference || (haveWebStorage() && Platform.WebStorage?.get?.(transportPreferenceName));\r\n  }\r\n\r\n  persistTransportPreference(transport: Transport): void {\r\n    this.transportPreference = transport.shortName;\r\n    if (haveWebStorage()) {\r\n      Platform.WebStorage?.set?.(transportPreferenceName, transport.shortName);\r\n    }\r\n  }\r\n\r\n  unpersistTransportPreference(): void {\r\n    this.transportPreference = null;\r\n    if (haveWebStorage()) {\r\n      Platform.WebStorage?.remove?.(transportPreferenceName);\r\n    }\r\n  }\r\n\r\n  /* This method is only used during connection attempts, so implements RSA4c1, RSA4c2,\r\n   * and RSA4d. It is generally not invoked for serverside-triggered reauths or manual\r\n   * reauths, so RSA4c3 does not apply, except (per per RSA4d1) in the case that the auth\r\n   * server returns 403. */\r\n  actOnErrorFromAuthorize(err: ErrorInfo): void {\r\n    if (err.code === 40171) {\r\n      /* No way to reauth */\r\n      this.notifyState({ state: 'failed', error: err });\r\n    } else if (err.code === 40102) {\r\n      this.notifyState({ state: 'failed', error: err });\r\n    } else if (err.statusCode === HttpStatusCodes.Forbidden) {\r\n      const msg = 'Client configured authentication provider returned 403; failing the connection';\r\n      Logger.logAction(Logger.LOG_ERROR, 'ConnectionManager.actOnErrorFromAuthorize()', msg);\r\n      this.notifyState({ state: 'failed', error: new ErrorInfo(msg, 80019, 403, err) });\r\n    } else {\r\n      const msg = 'Client configured authentication provider request failed';\r\n      Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.actOnErrorFromAuthorize', msg);\r\n      this.notifyState({ state: this.state.failState as string, error: new ErrorInfo(msg, 80019, 401, err) });\r\n    }\r\n  }\r\n\r\n  onConnectionDetailsUpdate(connectionDetails: Record<string, any>, transport: Transport): void {\r\n    if (!connectionDetails) {\r\n      return;\r\n    }\r\n    this.connectionDetails = connectionDetails;\r\n    if (connectionDetails.maxMessageSize) {\r\n      this.options.maxMessageSize = connectionDetails.maxMessageSize;\r\n    }\r\n    const clientId = connectionDetails.clientId;\r\n    if (clientId) {\r\n      const err = this.realtime.auth._uncheckedSetClientId(clientId);\r\n      if (err) {\r\n        Logger.logAction(Logger.LOG_ERROR, 'ConnectionManager.onConnectionDetailsUpdate()', err.message);\r\n        /* Errors setting the clientId are fatal to the connection */\r\n        transport.fail(err);\r\n        return;\r\n      }\r\n    }\r\n    const connectionStateTtl = connectionDetails.connectionStateTtl;\r\n    if (connectionStateTtl) {\r\n      this.connectionStateTtl = connectionStateTtl;\r\n    }\r\n    this.maxIdleInterval = connectionDetails.maxIdleInterval;\r\n    this.emit('connectiondetails', connectionDetails);\r\n  }\r\n\r\n  checkWsConnectivity() {\r\n    const ws = new Platform.Config.WebSocket(Defaults.wsConnectivityUrl);\r\n    return new Promise<void>((resolve, reject) => {\r\n      let finished = false;\r\n      ws.onopen = () => {\r\n        if (!finished) {\r\n          finished = true;\r\n          resolve();\r\n          ws.close();\r\n        }\r\n      };\r\n\r\n      ws.onclose = ws.onerror = () => {\r\n        if (!finished) {\r\n          finished = true;\r\n          reject();\r\n        }\r\n      };\r\n    });\r\n  }\r\n}\r\n\r\nexport default ConnectionManager;\r\n\r\nexport interface TransportStorage {\r\n  supportedTransports: Partial<Record<TransportName, TransportCtor>>;\r\n}\r\n", "import EventEmitter from '../util/eventemitter';\r\nimport ConnectionManager from '../transport/connectionmanager';\r\nimport Logger from '../util/logger';\r\nimport ConnectionStateChange from './connectionstatechange';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport { NormalisedClientOptions } from '../../types/ClientOptions';\r\nimport BaseRealtime from './baserealtime';\r\nimport Platform from 'common/platform';\r\n\r\nclass Connection extends EventEmitter {\r\n  ably: BaseRealtime;\r\n  connectionManager: ConnectionManager;\r\n  state: string;\r\n  key?: string;\r\n  id?: string;\r\n  errorReason: ErrorInfo | null;\r\n\r\n  constructor(ably: BaseRealtime, options: NormalisedClientOptions) {\r\n    super();\r\n    this.ably = ably;\r\n    this.connectionManager = new ConnectionManager(ably, options);\r\n    this.state = this.connectionManager.state.state;\r\n    this.key = undefined;\r\n    this.id = undefined;\r\n    this.errorReason = null;\r\n\r\n    this.connectionManager.on('connectionstate', (stateChange: ConnectionStateChange) => {\r\n      const state = (this.state = stateChange.current as string);\r\n      Platform.Config.nextTick(() => {\r\n        this.emit(state, stateChange);\r\n      });\r\n    });\r\n    this.connectionManager.on('update', (stateChange: ConnectionStateChange) => {\r\n      Platform.Config.nextTick(() => {\r\n        this.emit('update', stateChange);\r\n      });\r\n    });\r\n  }\r\n\r\n  whenState = ((state: string) => {\r\n    return EventEmitter.prototype.whenState.call(this, state, this.state);\r\n  }) as any;\r\n\r\n  connect(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Connection.connect()', '');\r\n    this.connectionManager.requestState({ state: 'connecting' });\r\n  }\r\n\r\n  async ping(): Promise<number> {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Connection.ping()', '');\r\n    return new Promise((resolve, reject) => {\r\n      this.connectionManager.ping(null, (err: unknown, result: number) => (err ? reject(err) : resolve(result)));\r\n    });\r\n  }\r\n\r\n  close(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Connection.close()', 'connectionKey = ' + this.key);\r\n    this.connectionManager.requestState({ state: 'closing' });\r\n  }\r\n\r\n  get recoveryKey(): string | null {\r\n    Logger.deprecationWarning(\r\n      'The `Connection.recoveryKey` attribute has been replaced by the `Connection.createRecoveryKey()` method. Replace your usage of `recoveryKey` with the return value of `createRecoveryKey()`. `recoveryKey` will be removed in a future version.',\r\n    );\r\n    return this.createRecoveryKey();\r\n  }\r\n\r\n  createRecoveryKey(): string | null {\r\n    return this.connectionManager.createRecoveryKey();\r\n  }\r\n}\r\n\r\nexport default Connection;\r\n", "import ErrorInfo from '../types/errorinfo';\r\n\r\nclass ChannelStateChange {\r\n  previous: string;\r\n  current: string;\r\n  resumed?: boolean;\r\n  reason?: string | Error | ErrorInfo;\r\n  hasBacklog?: boolean;\r\n\r\n  constructor(\r\n    previous: string,\r\n    current: string,\r\n    resumed?: boolean,\r\n    hasBacklog?: boolean,\r\n    reason?: string | Error | ErrorInfo | null,\r\n  ) {\r\n    this.previous = previous;\r\n    this.current = current;\r\n    if (current === 'attached') {\r\n      this.resumed = resumed;\r\n      this.hasBacklog = hasBacklog;\r\n    }\r\n    if (reason) this.reason = reason;\r\n  }\r\n}\r\n\r\nexport default ChannelStateChange;\r\n", "import ProtocolMessage, {\r\n  actions,\r\n  channelModes,\r\n  fromValues as protocolMessageFromValues,\r\n} from '../types/protocolmessage';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport RealtimePresence from './realtimepresence';\r\nimport Message, {\r\n  fromValues as messageFromValues,\r\n  fromValuesArray as messagesFromValuesArray,\r\n  encodeArray as encodeMessagesArray,\r\n  decode as decodeMessage,\r\n  getMessagesSize,\r\n  CipherOptions,\r\n  EncodingDecodingContext,\r\n} from '../types/message';\r\nimport ChannelStateChange from './channelstatechange';\r\nimport ErrorInfo, { PartialErrorInfo } from '../types/errorinfo';\r\nimport PresenceMessage, { decode as decodePresenceMessage } from '../types/presencemessage';\r\nimport ConnectionErrors from '../transport/connectionerrors';\r\nimport * as API from '../../../../ably';\r\nimport ConnectionManager from '../transport/connectionmanager';\r\nimport ConnectionStateChange from './connectionstatechange';\r\nimport { ErrCallback, StandardCallback } from '../../types/utils';\r\nimport BaseRealtime from './baserealtime';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport { normaliseChannelOptions } from '../util/defaults';\r\nimport { PaginatedResult } from './paginatedresource';\r\n\r\ninterface RealtimeHistoryParams {\r\n  start?: number;\r\n  end?: number;\r\n  direction?: string;\r\n  limit?: number;\r\n  untilAttach?: boolean;\r\n  from_serial?: string;\r\n}\r\n\r\nconst noop = function () {};\r\n\r\nfunction validateChannelOptions(options?: API.ChannelOptions) {\r\n  if (options && 'params' in options && !Utils.isObject(options.params)) {\r\n    return new ErrorInfo('options.params must be an object', 40000, 400);\r\n  }\r\n  if (options && 'modes' in options) {\r\n    if (!Array.isArray(options.modes)) {\r\n      return new ErrorInfo('options.modes must be an array', 40000, 400);\r\n    }\r\n    for (let i = 0; i < options.modes.length; i++) {\r\n      const currentMode = options.modes[i];\r\n      if (\r\n        !currentMode ||\r\n        typeof currentMode !== 'string' ||\r\n        !channelModes.includes(String.prototype.toUpperCase.call(currentMode))\r\n      ) {\r\n        return new ErrorInfo('Invalid channel mode: ' + currentMode, 40000, 400);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass RealtimeChannel extends EventEmitter {\r\n  name: string;\r\n  channelOptions: ChannelOptions;\r\n  client: BaseRealtime;\r\n  private _presence: RealtimePresence | null;\r\n  get presence(): RealtimePresence {\r\n    if (!this._presence) {\r\n      Utils.throwMissingPluginError('RealtimePresence');\r\n    }\r\n    return this._presence;\r\n  }\r\n  connectionManager: ConnectionManager;\r\n  state: API.ChannelState;\r\n  subscriptions: EventEmitter;\r\n  filteredSubscriptions?: Map<API.messageCallback<Message>, Map<API.MessageFilter, API.messageCallback<Message>[]>>;\r\n  syncChannelSerial?: string | null;\r\n  properties: {\r\n    attachSerial: string | null | undefined;\r\n    channelSerial: string | null | undefined;\r\n  };\r\n  errorReason: ErrorInfo | string | null;\r\n  _requestedFlags: Array<API.ChannelMode> | null;\r\n  _mode?: null | number;\r\n  _attachResume: boolean;\r\n  _decodingContext: EncodingDecodingContext;\r\n  _lastPayload: {\r\n    messageId?: string | null;\r\n    protocolMessageChannelSerial?: string | null;\r\n    decodeFailureRecoveryInProgress: null | boolean;\r\n  };\r\n  _allChannelChanges: EventEmitter;\r\n  params?: Record<string, any>;\r\n  modes: string[] | undefined;\r\n  stateTimer?: number | NodeJS.Timeout | null;\r\n  retryTimer?: number | NodeJS.Timeout | null;\r\n  retryCount: number = 0;\r\n\r\n  constructor(client: BaseRealtime, name: string, options?: API.ChannelOptions) {\r\n    super();\r\n    Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel()', 'started; name = ' + name);\r\n    this.name = name;\r\n    this.channelOptions = normaliseChannelOptions(client._Crypto ?? null, options);\r\n    this.client = client;\r\n    this._presence = client._RealtimePresence ? new client._RealtimePresence.RealtimePresence(this) : null;\r\n    this.connectionManager = client.connection.connectionManager;\r\n    this.state = 'initialized';\r\n    this.subscriptions = new EventEmitter();\r\n    this.syncChannelSerial = undefined;\r\n    this.properties = {\r\n      attachSerial: undefined,\r\n      channelSerial: undefined,\r\n    };\r\n    this.setOptions(options);\r\n    this.errorReason = null;\r\n    this._requestedFlags = null;\r\n    this._mode = null;\r\n    this._attachResume = false;\r\n    this._decodingContext = {\r\n      channelOptions: this.channelOptions,\r\n      plugins: client.options.plugins || {},\r\n      baseEncodedPreviousPayload: undefined,\r\n    };\r\n    this._lastPayload = {\r\n      messageId: null,\r\n      protocolMessageChannelSerial: null,\r\n      decodeFailureRecoveryInProgress: null,\r\n    };\r\n    /* Only differences between this and the public event emitter is that this emits an\r\n     * update event for all ATTACHEDs, whether resumed or not */\r\n    this._allChannelChanges = new EventEmitter();\r\n  }\r\n\r\n  invalidStateError(): ErrorInfo {\r\n    return new ErrorInfo(\r\n      'Channel operation failed as channel state is ' + this.state,\r\n      90001,\r\n      400,\r\n      this.errorReason || undefined,\r\n    );\r\n  }\r\n\r\n  static processListenerArgs(args: unknown[]): any[] {\r\n    /* [event], listener */\r\n    args = Array.prototype.slice.call(args);\r\n    if (typeof args[0] === 'function') {\r\n      args.unshift(null);\r\n    }\r\n    return args;\r\n  }\r\n\r\n  async setOptions(options?: API.ChannelOptions): Promise<void> {\r\n    const previousChannelOptions = this.channelOptions;\r\n    const err = validateChannelOptions(options);\r\n    if (err) {\r\n      throw err;\r\n    }\r\n    this.channelOptions = normaliseChannelOptions(this.client._Crypto ?? null, options);\r\n    if (this._decodingContext) this._decodingContext.channelOptions = this.channelOptions;\r\n    if (this._shouldReattachToSetOptions(options, previousChannelOptions)) {\r\n      /* This does not just do _attach(true, null, callback) because that would put us\r\n       * into the 'attaching' state until we receive the new attached, which is\r\n       * conceptually incorrect: we are still attached, we just have a pending request to\r\n       * change some channel params. Per RTL17 going into the attaching state would mean\r\n       * rejecting messages until we have confirmation that the options have changed,\r\n       * which would unnecessarily lose message continuity. */\r\n      this.attachImpl();\r\n      return new Promise((resolve, reject) => {\r\n        // Ignore 'attaching' -- could be just due to to a resume & reattach, should not\r\n        // call back setOptions until we're definitely attached with the new options (or\r\n        // else in a terminal state)\r\n        this._allChannelChanges.once(\r\n          ['attached', 'update', 'detached', 'failed'],\r\n          function (this: { event: string }, stateChange: ConnectionStateChange) {\r\n            switch (this.event) {\r\n              case 'update':\r\n              case 'attached':\r\n                resolve();\r\n                break;\r\n              default:\r\n                reject(stateChange.reason);\r\n            }\r\n          },\r\n        );\r\n      });\r\n    }\r\n  }\r\n\r\n  _shouldReattachToSetOptions(options: API.ChannelOptions | undefined, prevOptions: API.ChannelOptions) {\r\n    if (!(this.state === 'attached' || this.state === 'attaching')) {\r\n      return false;\r\n    }\r\n    if (options?.params) {\r\n      // Don't check against the `agent` param - it isn't returned in the ATTACHED message\r\n      const requestedParams = omitAgent(options.params);\r\n      const existingParams = omitAgent(prevOptions.params);\r\n\r\n      if (Object.keys(requestedParams).length !== Object.keys(existingParams).length) {\r\n        return true;\r\n      }\r\n\r\n      if (!Utils.shallowEquals(existingParams, requestedParams)) {\r\n        return true;\r\n      }\r\n    }\r\n    if (options?.modes) {\r\n      if (!prevOptions.modes || !Utils.arrEquals(options.modes, prevOptions.modes)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async publish(...args: any[]): Promise<void> {\r\n    let messages = args[0];\r\n    let argCount = args.length;\r\n\r\n    if (!this.connectionManager.activeState()) {\r\n      throw this.connectionManager.getError();\r\n    }\r\n    if (argCount == 1) {\r\n      if (Utils.isObject(messages)) messages = [messageFromValues(messages)];\r\n      else if (Array.isArray(messages)) messages = messagesFromValuesArray(messages);\r\n      else\r\n        throw new ErrorInfo(\r\n          'The single-argument form of publish() expects a message object or an array of message objects',\r\n          40013,\r\n          400,\r\n        );\r\n    } else {\r\n      messages = [messageFromValues({ name: args[0], data: args[1] })];\r\n    }\r\n    const maxMessageSize = this.client.options.maxMessageSize;\r\n    await encodeMessagesArray(messages, this.channelOptions as CipherOptions);\r\n    /* RSL1i */\r\n    const size = getMessagesSize(messages);\r\n    if (size > maxMessageSize) {\r\n      throw new ErrorInfo(\r\n        'Maximum size of messages that can be published at once exceeded ( was ' +\r\n          size +\r\n          ' bytes; limit is ' +\r\n          maxMessageSize +\r\n          ' bytes)',\r\n        40009,\r\n        400,\r\n      );\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      this._publish(messages, (err) => (err ? reject(err) : resolve()));\r\n    });\r\n  }\r\n\r\n  _publish(messages: Array<Message>, callback: ErrCallback) {\r\n    Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.publish()', 'message count = ' + messages.length);\r\n    const state = this.state;\r\n    switch (state) {\r\n      case 'failed':\r\n      case 'suspended':\r\n        callback(ErrorInfo.fromValues(this.invalidStateError()));\r\n        break;\r\n      default: {\r\n        Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.publish()', 'sending message; channel state is ' + state);\r\n        const msg = new ProtocolMessage();\r\n        msg.action = actions.MESSAGE;\r\n        msg.channel = this.name;\r\n        msg.messages = messages;\r\n        this.sendMessage(msg, callback);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  onEvent(messages: Array<any>): void {\r\n    Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.onEvent()', 'received message');\r\n    const subscriptions = this.subscriptions;\r\n    for (let i = 0; i < messages.length; i++) {\r\n      const message = messages[i];\r\n      subscriptions.emit(message.name, message);\r\n    }\r\n  }\r\n\r\n  async attach(): Promise<ChannelStateChange | null> {\r\n    if (this.state === 'attached') {\r\n      return null;\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      this._attach(false, null, (err, result) => (err ? reject(err) : resolve(result!)));\r\n    });\r\n  }\r\n\r\n  _attach(\r\n    forceReattach: boolean,\r\n    attachReason: ErrorInfo | null,\r\n    callback?: StandardCallback<ChannelStateChange>,\r\n  ): void {\r\n    if (!callback) {\r\n      callback = function (err?: ErrorInfo | null) {\r\n        if (err) {\r\n          Logger.logAction(Logger.LOG_ERROR, 'RealtimeChannel._attach()', 'Channel attach failed: ' + err.toString());\r\n        }\r\n      };\r\n    }\r\n\r\n    const connectionManager = this.connectionManager;\r\n    if (!connectionManager.activeState()) {\r\n      callback(connectionManager.getError());\r\n      return;\r\n    }\r\n\r\n    if (this.state !== 'attaching' || forceReattach) {\r\n      this.requestState('attaching', attachReason);\r\n    }\r\n\r\n    this.once(function (this: { event: string }, stateChange: ChannelStateChange) {\r\n      switch (this.event) {\r\n        case 'attached':\r\n          callback?.(null, stateChange);\r\n          break;\r\n        case 'detached':\r\n        case 'suspended':\r\n        case 'failed':\r\n          callback?.(\r\n            stateChange.reason ||\r\n              connectionManager.getError() ||\r\n              new ErrorInfo('Unable to attach; reason unknown; state = ' + this.event, 90000, 500),\r\n          );\r\n          break;\r\n        case 'detaching':\r\n          callback?.(new ErrorInfo('Attach request superseded by a subsequent detach request', 90000, 409));\r\n          break;\r\n      }\r\n    });\r\n  }\r\n\r\n  attachImpl(): void {\r\n    Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.attachImpl()', 'sending ATTACH message');\r\n    const attachMsg = protocolMessageFromValues({\r\n      action: actions.ATTACH,\r\n      channel: this.name,\r\n      params: this.channelOptions.params,\r\n      // RTL4c1: Includes the channel serial to resume from a previous message\r\n      // or attachment.\r\n      channelSerial: this.properties.channelSerial,\r\n    });\r\n    if (this._requestedFlags) {\r\n      attachMsg.encodeModesToFlags(this._requestedFlags);\r\n    } else if (this.channelOptions.modes) {\r\n      attachMsg.encodeModesToFlags(Utils.allToUpperCase(this.channelOptions.modes) as API.ChannelMode[]);\r\n    }\r\n    if (this._attachResume) {\r\n      attachMsg.setFlag('ATTACH_RESUME');\r\n    }\r\n    if (this._lastPayload.decodeFailureRecoveryInProgress) {\r\n      attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;\r\n    }\r\n    this.sendMessage(attachMsg, noop);\r\n  }\r\n\r\n  async detach(): Promise<void> {\r\n    const connectionManager = this.connectionManager;\r\n    if (!connectionManager.activeState()) {\r\n      throw connectionManager.getError();\r\n    }\r\n    switch (this.state) {\r\n      case 'suspended':\r\n        this.notifyState('detached');\r\n        return;\r\n      case 'detached':\r\n        return;\r\n      case 'failed':\r\n        throw new ErrorInfo('Unable to detach; channel state = failed', 90001, 400);\r\n      default:\r\n        this.requestState('detaching');\r\n      // eslint-disable-next-line no-fallthrough\r\n      case 'detaching':\r\n        return new Promise((resolve, reject) => {\r\n          this.once(function (this: { event: string }, stateChange: ChannelStateChange) {\r\n            switch (this.event) {\r\n              case 'detached':\r\n                resolve();\r\n                break;\r\n              case 'attached':\r\n              case 'suspended':\r\n              case 'failed':\r\n                reject(\r\n                  stateChange.reason ||\r\n                    connectionManager.getError() ||\r\n                    new ErrorInfo('Unable to detach; reason unknown; state = ' + this.event, 90000, 500),\r\n                );\r\n                break;\r\n              case 'attaching':\r\n                reject(new ErrorInfo('Detach request superseded by a subsequent attach request', 90000, 409));\r\n                break;\r\n            }\r\n          });\r\n        });\r\n    }\r\n  }\r\n\r\n  detachImpl(callback?: ErrCallback): void {\r\n    Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.detach()', 'sending DETACH message');\r\n    const msg = protocolMessageFromValues({ action: actions.DETACH, channel: this.name });\r\n    this.sendMessage(msg, callback || noop);\r\n  }\r\n\r\n  async subscribe(...args: unknown[] /* [event], listener */): Promise<ChannelStateChange | null> {\r\n    const [event, listener] = RealtimeChannel.processListenerArgs(args);\r\n\r\n    if (this.state === 'failed') {\r\n      throw ErrorInfo.fromValues(this.invalidStateError());\r\n    }\r\n\r\n    // Filtered\r\n    if (event && typeof event === 'object' && !Array.isArray(event)) {\r\n      this.client._FilteredSubscriptions.subscribeFilter(this, event, listener);\r\n    } else {\r\n      this.subscriptions.on(event, listener);\r\n    }\r\n\r\n    return this.attach();\r\n  }\r\n\r\n  unsubscribe(...args: unknown[] /* [event], listener */): void {\r\n    const [event, listener] = RealtimeChannel.processListenerArgs(args);\r\n\r\n    // If we either have a filtered listener, a filter or both we need to do additional processing to find the original function(s)\r\n    if ((typeof event === 'object' && !listener) || this.filteredSubscriptions?.has(listener)) {\r\n      this.client._FilteredSubscriptions\r\n        .getAndDeleteFilteredSubscriptions(this, event, listener)\r\n        .forEach((l) => this.subscriptions.off(l));\r\n      return;\r\n    }\r\n\r\n    this.subscriptions.off(event, listener);\r\n  }\r\n\r\n  sync(): void {\r\n    /* check preconditions */\r\n    switch (this.state) {\r\n      case 'initialized':\r\n      case 'detaching':\r\n      case 'detached':\r\n        throw new PartialErrorInfo('Unable to sync to channel; not attached', 40000);\r\n      default:\r\n    }\r\n    const connectionManager = this.connectionManager;\r\n    if (!connectionManager.activeState()) {\r\n      throw connectionManager.getError();\r\n    }\r\n\r\n    /* send sync request */\r\n    const syncMessage = protocolMessageFromValues({ action: actions.SYNC, channel: this.name });\r\n    if (this.syncChannelSerial) {\r\n      syncMessage.channelSerial = this.syncChannelSerial;\r\n    }\r\n    connectionManager.send(syncMessage);\r\n  }\r\n\r\n  sendMessage(msg: ProtocolMessage, callback?: ErrCallback): void {\r\n    this.connectionManager.send(msg, this.client.options.queueMessages, callback);\r\n  }\r\n\r\n  sendPresence(presence: PresenceMessage | PresenceMessage[], callback?: ErrCallback): void {\r\n    const msg = protocolMessageFromValues({\r\n      action: actions.PRESENCE,\r\n      channel: this.name,\r\n      presence: Array.isArray(presence)\r\n        ? this.client._RealtimePresence!.presenceMessagesFromValuesArray(presence)\r\n        : [this.client._RealtimePresence!.presenceMessageFromValues(presence)],\r\n    });\r\n    this.sendMessage(msg, callback);\r\n  }\r\n\r\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage, in order to synchronise access to the state stored in _decodingContext.\r\n  async processMessage(message: ProtocolMessage): Promise<void> {\r\n    if (\r\n      message.action === actions.ATTACHED ||\r\n      message.action === actions.MESSAGE ||\r\n      message.action === actions.PRESENCE\r\n    ) {\r\n      // RTL15b\r\n      this.setChannelSerial(message.channelSerial);\r\n    }\r\n\r\n    let syncChannelSerial,\r\n      isSync = false;\r\n    switch (message.action) {\r\n      case actions.ATTACHED: {\r\n        this.properties.attachSerial = message.channelSerial;\r\n        this._mode = message.getMode();\r\n        this.params = (message as any).params || {};\r\n        const modesFromFlags = message.decodeModesFromFlags();\r\n        this.modes = (modesFromFlags && Utils.allToLowerCase(modesFromFlags)) || undefined;\r\n        const resumed = message.hasFlag('RESUMED');\r\n        const hasPresence = message.hasFlag('HAS_PRESENCE');\r\n        const hasBacklog = message.hasFlag('HAS_BACKLOG');\r\n        if (this.state === 'attached') {\r\n          if (!resumed) {\r\n            /* On a loss of continuity, the presence set needs to be re-synced */\r\n            if (this._presence) {\r\n              this._presence.onAttached(hasPresence);\r\n            }\r\n          }\r\n          const change = new ChannelStateChange(this.state, this.state, resumed, hasBacklog, message.error);\r\n          this._allChannelChanges.emit('update', change);\r\n          if (!resumed || this.channelOptions.updateOnAttached) {\r\n            this.emit('update', change);\r\n          }\r\n        } else if (this.state === 'detaching') {\r\n          /* RTL5i: re-send DETACH and remain in the 'detaching' state */\r\n          this.checkPendingState();\r\n        } else {\r\n          this.notifyState('attached', message.error, resumed, hasPresence, hasBacklog);\r\n        }\r\n        break;\r\n      }\r\n\r\n      case actions.DETACHED: {\r\n        const detachErr = message.error\r\n          ? ErrorInfo.fromValues(message.error)\r\n          : new ErrorInfo('Channel detached', 90001, 404);\r\n        if (this.state === 'detaching') {\r\n          this.notifyState('detached', detachErr);\r\n        } else if (this.state === 'attaching') {\r\n          /* Only retry immediately if we were previously attached. If we were\r\n           * attaching, go into suspended, fail messages, and wait a few seconds\r\n           * before retrying */\r\n          this.notifyState('suspended', detachErr);\r\n        } else {\r\n          this.requestState('attaching', detachErr);\r\n        }\r\n        break;\r\n      }\r\n\r\n      case actions.SYNC:\r\n        /* syncs can have channelSerials, but might not if the sync is one page long */\r\n        isSync = true;\r\n        syncChannelSerial = this.syncChannelSerial = message.channelSerial;\r\n        /* syncs can happen on channels with no presence data as part of connection\r\n         * resuming, in which case protocol message has no presence property */\r\n        if (!message.presence) break;\r\n      // eslint-disable-next-line no-fallthrough\r\n      case actions.PRESENCE: {\r\n        const presence = message.presence;\r\n\r\n        if (!presence) {\r\n          break;\r\n        }\r\n\r\n        const { id, connectionId, timestamp } = message;\r\n\r\n        const options = this.channelOptions;\r\n        let presenceMsg: PresenceMessage;\r\n        for (let i = 0; i < presence.length; i++) {\r\n          try {\r\n            presenceMsg = presence[i];\r\n            await decodePresenceMessage(presenceMsg, options);\r\n            if (!presenceMsg.connectionId) presenceMsg.connectionId = connectionId;\r\n            if (!presenceMsg.timestamp) presenceMsg.timestamp = timestamp;\r\n            if (!presenceMsg.id) presenceMsg.id = id + ':' + i;\r\n          } catch (e) {\r\n            Logger.logAction(Logger.LOG_ERROR, 'RealtimeChannel.processMessage()', (e as Error).toString());\r\n          }\r\n        }\r\n        if (this._presence) {\r\n          this._presence.setPresence(presence, isSync, syncChannelSerial as any);\r\n        }\r\n        break;\r\n      }\r\n      case actions.MESSAGE: {\r\n        //RTL17\r\n        if (this.state !== 'attached') {\r\n          Logger.logAction(\r\n            Logger.LOG_MAJOR,\r\n            'RealtimeChannel.processMessage()',\r\n            'Message \"' +\r\n              message.id +\r\n              '\" skipped as this channel \"' +\r\n              this.name +\r\n              '\" state is not \"attached\" (state is \"' +\r\n              this.state +\r\n              '\").',\r\n          );\r\n          return;\r\n        }\r\n\r\n        const messages = message.messages as Array<Message>,\r\n          firstMessage = messages[0],\r\n          lastMessage = messages[messages.length - 1],\r\n          id = message.id,\r\n          connectionId = message.connectionId,\r\n          timestamp = message.timestamp;\r\n\r\n        if (\r\n          firstMessage.extras &&\r\n          firstMessage.extras.delta &&\r\n          firstMessage.extras.delta.from !== this._lastPayload.messageId\r\n        ) {\r\n          const msg =\r\n            'Delta message decode failure - previous message not available for message \"' +\r\n            message.id +\r\n            '\" on this channel \"' +\r\n            this.name +\r\n            '\".';\r\n          Logger.logAction(Logger.LOG_ERROR, 'RealtimeChannel.processMessage()', msg);\r\n          this._startDecodeFailureRecovery(new ErrorInfo(msg, 40018, 400));\r\n          break;\r\n        }\r\n\r\n        for (let i = 0; i < messages.length; i++) {\r\n          const msg = messages[i];\r\n          try {\r\n            await decodeMessage(msg, this._decodingContext);\r\n          } catch (e) {\r\n            /* decrypt failed .. the most likely cause is that we have the wrong key */\r\n            Logger.logAction(Logger.LOG_ERROR, 'RealtimeChannel.processMessage()', (e as Error).toString());\r\n            switch ((e as ErrorInfo).code) {\r\n              case 40018:\r\n                /* decode failure */\r\n                this._startDecodeFailureRecovery(e as ErrorInfo);\r\n                return;\r\n              case 40019:\r\n              /* No vcdiff plugin passed in - no point recovering, give up */\r\n              // eslint-disable-next-line no-fallthrough\r\n              case 40021:\r\n                /* Browser does not support deltas, similarly no point recovering */\r\n                this.notifyState('failed', e as ErrorInfo);\r\n                return;\r\n            }\r\n          }\r\n          if (!msg.connectionId) msg.connectionId = connectionId;\r\n          if (!msg.timestamp) msg.timestamp = timestamp;\r\n          if (!msg.id) msg.id = id + ':' + i;\r\n        }\r\n        this._lastPayload.messageId = lastMessage.id;\r\n        this._lastPayload.protocolMessageChannelSerial = message.channelSerial;\r\n        this.onEvent(messages);\r\n        break;\r\n      }\r\n\r\n      case actions.ERROR: {\r\n        /* there was a channel-specific error */\r\n        const err = message.error as ErrorInfo;\r\n        if (err && err.code == 80016) {\r\n          /* attach/detach operation attempted on superseded transport handle */\r\n          this.checkPendingState();\r\n        } else {\r\n          this.notifyState('failed', ErrorInfo.fromValues(err));\r\n        }\r\n        break;\r\n      }\r\n\r\n      default:\r\n        Logger.logAction(\r\n          Logger.LOG_ERROR,\r\n          'RealtimeChannel.processMessage()',\r\n          'Fatal protocol error: unrecognised action (' + message.action + ')',\r\n        );\r\n        this.connectionManager.abort(ConnectionErrors.unknownChannelErr());\r\n    }\r\n  }\r\n\r\n  _startDecodeFailureRecovery(reason: ErrorInfo): void {\r\n    if (!this._lastPayload.decodeFailureRecoveryInProgress) {\r\n      Logger.logAction(\r\n        Logger.LOG_MAJOR,\r\n        'RealtimeChannel.processMessage()',\r\n        'Starting decode failure recovery process.',\r\n      );\r\n      this._lastPayload.decodeFailureRecoveryInProgress = true;\r\n      this._attach(true, reason, () => {\r\n        this._lastPayload.decodeFailureRecoveryInProgress = false;\r\n      });\r\n    }\r\n  }\r\n\r\n  onAttached(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel.onAttached', 'activating channel; name = ' + this.name);\r\n  }\r\n\r\n  notifyState(\r\n    state: API.ChannelState,\r\n    reason?: ErrorInfo | null,\r\n    resumed?: boolean,\r\n    hasPresence?: boolean,\r\n    hasBacklog?: boolean,\r\n  ): void {\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'RealtimeChannel.notifyState',\r\n      'name = ' + this.name + ', current state = ' + this.state + ', notifying state ' + state,\r\n    );\r\n    this.clearStateTimer();\r\n\r\n    // RTP5a1\r\n    if (['detached', 'suspended', 'failed'].includes(state)) {\r\n      this.properties.channelSerial = null;\r\n    }\r\n\r\n    if (state === this.state) {\r\n      return;\r\n    }\r\n    if (this._presence) {\r\n      this._presence.actOnChannelState(state, hasPresence, reason);\r\n    }\r\n    if (state === 'suspended' && this.connectionManager.state.sendEvents) {\r\n      this.startRetryTimer();\r\n    } else {\r\n      this.cancelRetryTimer();\r\n    }\r\n    if (reason) {\r\n      this.errorReason = reason;\r\n    }\r\n    const change = new ChannelStateChange(this.state, state, resumed, hasBacklog, reason);\r\n    const action = 'Channel state for channel \"' + this.name + '\"';\r\n    const message = state + (reason ? '; reason: ' + reason : '');\r\n    if (state === 'failed') {\r\n      Logger.logAction(Logger.LOG_ERROR, action, message);\r\n    } else {\r\n      Logger.logAction(Logger.LOG_MAJOR, action, message);\r\n    }\r\n\r\n    if (state !== 'attaching' && state !== 'suspended') {\r\n      this.retryCount = 0;\r\n    }\r\n\r\n    /* Note: we don't set inProgress for pending states until the request is actually in progress */\r\n    if (state === 'attached') {\r\n      this.onAttached();\r\n    }\r\n\r\n    if (state === 'attached') {\r\n      this._attachResume = true;\r\n    } else if (state === 'detaching' || state === 'failed') {\r\n      this._attachResume = false;\r\n    }\r\n\r\n    this.state = state;\r\n    this._allChannelChanges.emit(state, change);\r\n    this.emit(state, change);\r\n  }\r\n\r\n  requestState(state: API.ChannelState, reason?: ErrorInfo | null): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel.requestState', 'name = ' + this.name + ', state = ' + state);\r\n    this.notifyState(state, reason);\r\n    /* send the event and await response */\r\n    this.checkPendingState();\r\n  }\r\n\r\n  checkPendingState(): void {\r\n    /* if can't send events, do nothing */\r\n    const cmState = this.connectionManager.state;\r\n    if (!cmState.sendEvents) {\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'RealtimeChannel.checkPendingState',\r\n        'sendEvents is false; state is ' + this.connectionManager.state.state,\r\n      );\r\n      return;\r\n    }\r\n\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'RealtimeChannel.checkPendingState',\r\n      'name = ' + this.name + ', state = ' + this.state,\r\n    );\r\n    /* Only start the state timer running when actually sending the event */\r\n    switch (this.state) {\r\n      case 'attaching':\r\n        this.startStateTimerIfNotRunning();\r\n        this.attachImpl();\r\n        break;\r\n      case 'detaching':\r\n        this.startStateTimerIfNotRunning();\r\n        this.detachImpl();\r\n        break;\r\n      case 'attached':\r\n        /* resume any sync operation that was in progress */\r\n        this.sync();\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  timeoutPendingState(): void {\r\n    switch (this.state) {\r\n      case 'attaching': {\r\n        const err = new ErrorInfo('Channel attach timed out', 90007, 408);\r\n        this.notifyState('suspended', err);\r\n        break;\r\n      }\r\n      case 'detaching': {\r\n        const err = new ErrorInfo('Channel detach timed out', 90007, 408);\r\n        this.notifyState('attached', err);\r\n        break;\r\n      }\r\n      default:\r\n        this.checkPendingState();\r\n        break;\r\n    }\r\n  }\r\n\r\n  startStateTimerIfNotRunning(): void {\r\n    if (!this.stateTimer) {\r\n      this.stateTimer = setTimeout(() => {\r\n        Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel.startStateTimerIfNotRunning', 'timer expired');\r\n        this.stateTimer = null;\r\n        this.timeoutPendingState();\r\n      }, this.client.options.timeouts.realtimeRequestTimeout);\r\n    }\r\n  }\r\n\r\n  clearStateTimer(): void {\r\n    const stateTimer = this.stateTimer;\r\n    if (stateTimer) {\r\n      clearTimeout(stateTimer);\r\n      this.stateTimer = null;\r\n    }\r\n  }\r\n\r\n  startRetryTimer(): void {\r\n    if (this.retryTimer) return;\r\n\r\n    this.retryCount++;\r\n    const retryDelay = Utils.getRetryTime(this.client.options.timeouts.channelRetryTimeout, this.retryCount);\r\n\r\n    this.retryTimer = setTimeout(() => {\r\n      /* If connection is not connected, just leave in suspended, a reattach\r\n       * will be triggered once it connects again */\r\n      if (this.state === 'suspended' && this.connectionManager.state.sendEvents) {\r\n        this.retryTimer = null;\r\n        Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel retry timer expired', 'attempting a new attach');\r\n        this.requestState('attaching');\r\n      }\r\n    }, retryDelay);\r\n  }\r\n\r\n  cancelRetryTimer(): void {\r\n    if (this.retryTimer) {\r\n      clearTimeout(this.retryTimer as NodeJS.Timeout);\r\n      this.retryTimer = null;\r\n    }\r\n  }\r\n\r\n  history = async function (\r\n    this: RealtimeChannel,\r\n    params: RealtimeHistoryParams | null,\r\n  ): Promise<PaginatedResult<Message>> {\r\n    Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.history()', 'channel = ' + this.name);\r\n\r\n    // We fetch this first so that any plugin-not-provided error takes priority over other errors\r\n    const restMixin = this.client.rest.channelMixin;\r\n\r\n    if (params && params.untilAttach) {\r\n      if (this.state !== 'attached') {\r\n        throw new ErrorInfo('option untilAttach requires the channel to be attached', 40000, 400);\r\n      }\r\n      if (!this.properties.attachSerial) {\r\n        throw new ErrorInfo(\r\n          'untilAttach was specified and channel is attached, but attachSerial is not defined',\r\n          40000,\r\n          400,\r\n        );\r\n      }\r\n      delete params.untilAttach;\r\n      params.from_serial = this.properties.attachSerial;\r\n    }\r\n\r\n    return restMixin.history(this, params);\r\n  } as any;\r\n\r\n  whenState = ((state: string) => {\r\n    return EventEmitter.prototype.whenState.call(this, state, this.state);\r\n  }) as any;\r\n\r\n  /* @returns null (if can safely be released) | ErrorInfo (if cannot) */\r\n  getReleaseErr(): ErrorInfo | null {\r\n    const s = this.state;\r\n    if (s === 'initialized' || s === 'detached' || s === 'failed') {\r\n      return null;\r\n    }\r\n    return new ErrorInfo(\r\n      'Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was ' +\r\n        s,\r\n      90001,\r\n      400,\r\n    );\r\n  }\r\n\r\n  setChannelSerial(channelSerial?: string | null): void {\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'RealtimeChannel.setChannelSerial()',\r\n      'Updating channel serial; serial = ' + channelSerial + '; previous = ' + this.properties.channelSerial,\r\n    );\r\n\r\n    // RTP17h: Only update the channel serial if its present (it won't always\r\n    // be set).\r\n    if (channelSerial) {\r\n      this.properties.channelSerial = channelSerial;\r\n    }\r\n  }\r\n\r\n  async status(): Promise<API.ChannelDetails> {\r\n    return this.client.rest.channelMixin.status(this);\r\n  }\r\n}\r\n\r\nfunction omitAgent(channelParams?: API.ChannelParams) {\r\n  const { agent: _, ...paramsWithoutAgent } = channelParams || {};\r\n  return paramsWithoutAgent;\r\n}\r\n\r\nexport default RealtimeChannel;\r\n", "import * as Utils from '../util/utils';\r\nimport BaseClient from './baseclient';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport Logger from '../util/logger';\r\nimport Connection from './connection';\r\nimport RealtimeChannel from './realtimechannel';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport ProtocolMessage from '../types/protocolmessage';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport * as API from '../../../../ably';\r\nimport { ModularPlugins, RealtimePresencePlugin } from './modularplugins';\r\nimport { TransportNames } from 'common/constants/TransportName';\r\nimport { TransportImplementations } from 'common/platform';\r\nimport Defaults from '../util/defaults';\r\n\r\n/**\r\n `BaseRealtime` is an export of the tree-shakable version of the SDK, and acts as the base class for the `DefaultRealtime` class exported by the non tree-shakable version.\r\n */\r\nclass BaseRealtime extends BaseClient {\r\n  readonly _RealtimePresence: RealtimePresencePlugin | null;\r\n  // Extra transport implementations available to this client, in addition to those in Platform.Transports.bundledImplementations\r\n  readonly _additionalTransportImplementations: TransportImplementations;\r\n  _channels: any;\r\n  connection: Connection;\r\n\r\n  /*\r\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\r\n   *\r\n   * 1. passes a string (which is quite likely if they\u2019re e.g. migrating from the default variant to the modular variant)\r\n   * 2. passes no argument at all\r\n   *\r\n   * tell the compiler that these cases are possible so that it forces us to handle them.\r\n   */\r\n  constructor(options?: ClientOptions | string) {\r\n    super(Defaults.objectifyOptions(options, false, 'BaseRealtime'));\r\n    Logger.logAction(Logger.LOG_MINOR, 'Realtime()', '');\r\n\r\n    // currently we cannot support using Ably.Realtime instances in Vercel Edge runtime.\r\n    // this error can be removed after fixing https://github.com/ably/ably-js/issues/1731,\r\n    // and https://github.com/ably/ably-js/issues/1732\r\n    // @ts-ignore\r\n    if (typeof EdgeRuntime === 'string') {\r\n      throw new ErrorInfo(\r\n        `Ably.Realtime instance cannot be used in Vercel Edge runtime.` +\r\n          ` If you are running Vercel Edge functions, please replace your` +\r\n          ` \"new Ably.Realtime()\" with \"new Ably.Rest()\" and use Ably Rest API` +\r\n          ` instead of the Realtime API. If you are server-rendering your application` +\r\n          ` in the Vercel Edge runtime, please use the condition \"if (typeof EdgeRuntime === 'string')\"` +\r\n          ` to prevent instantiating Ably.Realtime instance during SSR in the Vercel Edge runtime.`,\r\n        40000,\r\n        400,\r\n      );\r\n    }\r\n\r\n    this._additionalTransportImplementations = BaseRealtime.transportImplementationsFromPlugins(this.options.plugins);\r\n    this._RealtimePresence = this.options.plugins?.RealtimePresence ?? null;\r\n    this.connection = new Connection(this, this.options);\r\n    this._channels = new Channels(this);\r\n    if (this.options.autoConnect !== false) this.connect();\r\n  }\r\n\r\n  private static transportImplementationsFromPlugins(plugins?: ModularPlugins) {\r\n    const transports: TransportImplementations = {};\r\n\r\n    if (plugins?.WebSocketTransport) {\r\n      transports[TransportNames.WebSocket] = plugins.WebSocketTransport;\r\n    }\r\n    if (plugins?.XHRPolling) {\r\n      transports[TransportNames.XhrPolling] = plugins.XHRPolling;\r\n    }\r\n\r\n    return transports;\r\n  }\r\n\r\n  get channels() {\r\n    return this._channels;\r\n  }\r\n\r\n  connect(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Realtime.connect()', '');\r\n    this.connection.connect();\r\n  }\r\n\r\n  close(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Realtime.close()', '');\r\n    this.connection.close();\r\n  }\r\n}\r\n\r\nclass Channels extends EventEmitter {\r\n  realtime: BaseRealtime;\r\n  all: Record<string, RealtimeChannel>;\r\n\r\n  constructor(realtime: BaseRealtime) {\r\n    super();\r\n    this.realtime = realtime;\r\n    this.all = Object.create(null);\r\n    realtime.connection.connectionManager.on('transport.active', () => {\r\n      this.onTransportActive();\r\n    });\r\n  }\r\n\r\n  channelSerials(): { [name: string]: string } {\r\n    let serials: { [name: string]: string } = {};\r\n    for (const name of Utils.keysArray(this.all, true)) {\r\n      const channel = this.all[name];\r\n      if (channel.properties.channelSerial) {\r\n        serials[name] = channel.properties.channelSerial;\r\n      }\r\n    }\r\n    return serials;\r\n  }\r\n\r\n  // recoverChannels gets the given channels and sets their channel serials.\r\n  recoverChannels(channelSerials: { [name: string]: string }) {\r\n    for (const name of Utils.keysArray(channelSerials, true)) {\r\n      const channel = this.get(name);\r\n      channel.properties.channelSerial = channelSerials[name];\r\n    }\r\n  }\r\n\r\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage.\r\n  async processChannelMessage(msg: ProtocolMessage) {\r\n    const channelName = msg.channel;\r\n    if (channelName === undefined) {\r\n      Logger.logAction(\r\n        Logger.LOG_ERROR,\r\n        'Channels.processChannelMessage()',\r\n        'received event unspecified channel, action = ' + msg.action,\r\n      );\r\n      return;\r\n    }\r\n    const channel = this.all[channelName];\r\n    if (!channel) {\r\n      Logger.logAction(\r\n        Logger.LOG_ERROR,\r\n        'Channels.processChannelMessage()',\r\n        'received event for non-existent channel: ' + channelName,\r\n      );\r\n      return;\r\n    }\r\n    await channel.processMessage(msg);\r\n  }\r\n\r\n  /* called when a transport becomes connected; reattempt attach/detach\r\n   * for channels that are attaching or detaching. */\r\n  onTransportActive() {\r\n    for (const channelName in this.all) {\r\n      const channel = this.all[channelName];\r\n      if (channel.state === 'attaching' || channel.state === 'detaching') {\r\n        channel.checkPendingState();\r\n      } else if (channel.state === 'suspended') {\r\n        channel._attach(false, null);\r\n      } else if (channel.state === 'attached') {\r\n        // Note explicity request the state, channel.attach() would do nothing\r\n        // as its already attached.\r\n        channel.requestState('attaching');\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Connection interruptions (ie when the connection will no longer queue\r\n   * events) imply connection state changes for any channel which is either\r\n   * attached, pending, or will attempt to become attached in the future */\r\n  propogateConnectionInterruption(connectionState: string, reason: ErrorInfo) {\r\n    const connectionStateToChannelState: Record<string, API.ChannelState> = {\r\n      closing: 'detached',\r\n      closed: 'detached',\r\n      failed: 'failed',\r\n      suspended: 'suspended',\r\n    };\r\n    const fromChannelStates = ['attaching', 'attached', 'detaching', 'suspended'];\r\n    const toChannelState = connectionStateToChannelState[connectionState];\r\n\r\n    for (const channelId in this.all) {\r\n      const channel = this.all[channelId];\r\n      if (fromChannelStates.includes(channel.state)) {\r\n        channel.notifyState(toChannelState, reason);\r\n      }\r\n    }\r\n  }\r\n\r\n  get(name: string, channelOptions?: ChannelOptions) {\r\n    name = String(name);\r\n    let channel = this.all[name];\r\n    if (!channel) {\r\n      channel = this.all[name] = new RealtimeChannel(this.realtime, name, channelOptions);\r\n    } else if (channelOptions) {\r\n      if (channel._shouldReattachToSetOptions(channelOptions, channel.channelOptions)) {\r\n        throw new ErrorInfo(\r\n          'Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.',\r\n          40000,\r\n          400,\r\n        );\r\n      }\r\n      channel.setOptions(channelOptions);\r\n    }\r\n    return channel;\r\n  }\r\n\r\n  getDerived(name: string, deriveOptions: API.DeriveOptions, channelOptions?: ChannelOptions) {\r\n    if (deriveOptions.filter) {\r\n      const filter = Utils.toBase64(deriveOptions.filter);\r\n      const match = Utils.matchDerivedChannel(name);\r\n      name = `[filter=${filter}${match.qualifierParam}]${match.channelName}`;\r\n    }\r\n    return this.get(name, channelOptions);\r\n  }\r\n\r\n  /* Included to support certain niche use-cases; most users should ignore this.\r\n   * Please do not use this unless you know what you're doing */\r\n  release(name: string) {\r\n    name = String(name);\r\n    const channel = this.all[name];\r\n    if (!channel) {\r\n      return;\r\n    }\r\n    const releaseErr = channel.getReleaseErr();\r\n    if (releaseErr) {\r\n      throw releaseErr;\r\n    }\r\n    delete this.all[name];\r\n  }\r\n}\r\n\r\nexport default BaseRealtime;\r\n", "import * as Utils from '../util/utils';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport Logger from '../util/logger';\r\nimport PresenceMessage, {\r\n  fromValues as presenceMessageFromValues,\r\n  fromData as presenceMessageFromData,\r\n  encode as encodePresenceMessage,\r\n} from '../types/presencemessage';\r\nimport ErrorInfo, { PartialErrorInfo } from '../types/errorinfo';\r\nimport RealtimeChannel from './realtimechannel';\r\nimport Multicaster from '../util/multicaster';\r\nimport ChannelStateChange from './channelstatechange';\r\nimport { CipherOptions } from '../types/message';\r\nimport { ErrCallback } from '../../types/utils';\r\nimport { PaginatedResult } from './paginatedresource';\r\n\r\ninterface RealtimePresenceParams {\r\n  waitForSync?: boolean;\r\n  clientId?: string;\r\n  connectionId?: string;\r\n}\r\n\r\ninterface RealtimeHistoryParams {\r\n  start?: number;\r\n  end?: number;\r\n  direction?: string;\r\n  limit?: number;\r\n  untilAttach?: boolean;\r\n  from_serial?: string | null;\r\n}\r\n\r\nfunction getClientId(realtimePresence: RealtimePresence) {\r\n  return realtimePresence.channel.client.auth.clientId;\r\n}\r\n\r\nfunction isAnonymousOrWildcard(realtimePresence: RealtimePresence) {\r\n  const realtime = realtimePresence.channel.client;\r\n  /* If not currently connected, we can't assume that we're an anonymous\r\n   * client, as realtime may inform us of our clientId in the CONNECTED\r\n   * message. So assume we're not anonymous and leave it to realtime to\r\n   * return an error if we are */\r\n  const clientId = realtime.auth.clientId;\r\n  return (!clientId || clientId === '*') && realtime.connection.state === 'connected';\r\n}\r\n\r\n/* Callback is called only in the event of an error */\r\nfunction waitAttached(channel: RealtimeChannel, callback: ErrCallback, action: () => void) {\r\n  switch (channel.state) {\r\n    case 'attached':\r\n    case 'suspended':\r\n      action();\r\n      break;\r\n    case 'initialized':\r\n    case 'detached':\r\n    case 'detaching':\r\n    case 'attaching':\r\n      Utils.whenPromiseSettles(channel.attach(), function (err: Error | null) {\r\n        if (err) callback(err);\r\n        else action();\r\n      });\r\n      break;\r\n    default:\r\n      callback(ErrorInfo.fromValues(channel.invalidStateError()));\r\n  }\r\n}\r\n\r\nfunction newerThan(item: PresenceMessage, existing: PresenceMessage) {\r\n  /* RTP2b1: if either is synthesised, compare by timestamp */\r\n  if (item.isSynthesized() || existing.isSynthesized()) {\r\n    // RTP2b1a: if equal, prefer the newly-arrived one\r\n    return (item.timestamp as number) >= (existing.timestamp as number);\r\n  }\r\n\r\n  /* RTP2b2 */\r\n  const itemOrderings = item.parseId(),\r\n    existingOrderings = existing.parseId();\r\n  if (itemOrderings.msgSerial === existingOrderings.msgSerial) {\r\n    return itemOrderings.index > existingOrderings.index;\r\n  } else {\r\n    return itemOrderings.msgSerial > existingOrderings.msgSerial;\r\n  }\r\n}\r\n\r\nclass RealtimePresence extends EventEmitter {\r\n  channel: RealtimeChannel;\r\n  pendingPresence: { presence: PresenceMessage; callback: ErrCallback }[];\r\n  syncComplete: boolean;\r\n  members: PresenceMap;\r\n  _myMembers: PresenceMap;\r\n  subscriptions: EventEmitter;\r\n  name?: string;\r\n\r\n  constructor(channel: RealtimeChannel) {\r\n    super();\r\n    this.channel = channel;\r\n    this.syncComplete = false;\r\n    this.members = new PresenceMap(this, (item) => item.clientId + ':' + item.connectionId);\r\n    // RTP17h: Store own members by clientId only.\r\n    this._myMembers = new PresenceMap(this, (item) => item.clientId!);\r\n    this.subscriptions = new EventEmitter();\r\n    this.pendingPresence = [];\r\n  }\r\n\r\n  async enter(data: unknown): Promise<void> {\r\n    if (isAnonymousOrWildcard(this)) {\r\n      throw new ErrorInfo('clientId must be specified to enter a presence channel', 40012, 400);\r\n    }\r\n    return this._enterOrUpdateClient(undefined, undefined, data, 'enter');\r\n  }\r\n\r\n  async update(data: unknown): Promise<void> {\r\n    if (isAnonymousOrWildcard(this)) {\r\n      throw new ErrorInfo('clientId must be specified to update presence data', 40012, 400);\r\n    }\r\n    return this._enterOrUpdateClient(undefined, undefined, data, 'update');\r\n  }\r\n\r\n  async enterClient(clientId: string, data: unknown): Promise<void> {\r\n    return this._enterOrUpdateClient(undefined, clientId, data, 'enter');\r\n  }\r\n\r\n  async updateClient(clientId: string, data: unknown): Promise<void> {\r\n    return this._enterOrUpdateClient(undefined, clientId, data, 'update');\r\n  }\r\n\r\n  async _enterOrUpdateClient(\r\n    id: string | undefined,\r\n    clientId: string | undefined,\r\n    data: unknown,\r\n    action: string,\r\n  ): Promise<void> {\r\n    const channel = this.channel;\r\n    if (!channel.connectionManager.activeState()) {\r\n      throw channel.connectionManager.getError();\r\n    }\r\n\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'RealtimePresence.' + action + 'Client()',\r\n      'channel = ' + channel.name + ', id = ' + id + ', client = ' + (clientId || '(implicit) ' + getClientId(this)),\r\n    );\r\n\r\n    const presence = presenceMessageFromData(data);\r\n    presence.action = action;\r\n    if (id) {\r\n      presence.id = id;\r\n    }\r\n    if (clientId) {\r\n      presence.clientId = clientId;\r\n    }\r\n\r\n    await encodePresenceMessage(presence, channel.channelOptions as CipherOptions);\r\n    switch (channel.state) {\r\n      case 'attached':\r\n        return new Promise((resolve, reject) => {\r\n          channel.sendPresence(presence, (err) => (err ? reject(err) : resolve()));\r\n        });\r\n      case 'initialized':\r\n      case 'detached':\r\n        channel.attach();\r\n      // eslint-disable-next-line no-fallthrough\r\n      case 'attaching':\r\n        return new Promise((resolve, reject) => {\r\n          this.pendingPresence.push({\r\n            presence: presence,\r\n            callback: (err) => (err ? reject(err) : resolve()),\r\n          });\r\n        });\r\n      default: {\r\n        const err = new PartialErrorInfo(\r\n          'Unable to ' + action + ' presence channel while in ' + channel.state + ' state',\r\n          90001,\r\n        );\r\n        err.code = 90001;\r\n        throw err;\r\n      }\r\n    }\r\n  }\r\n\r\n  async leave(data: unknown): Promise<void> {\r\n    if (isAnonymousOrWildcard(this)) {\r\n      throw new ErrorInfo('clientId must have been specified to enter or leave a presence channel', 40012, 400);\r\n    }\r\n    return this.leaveClient(undefined, data);\r\n  }\r\n\r\n  async leaveClient(clientId?: string, data?: unknown): Promise<void> {\r\n    const channel = this.channel;\r\n    if (!channel.connectionManager.activeState()) {\r\n      throw channel.connectionManager.getError();\r\n    }\r\n\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'RealtimePresence.leaveClient()',\r\n      'leaving; channel = ' + this.channel.name + ', client = ' + clientId,\r\n    );\r\n    const presence = presenceMessageFromData(data);\r\n    presence.action = 'leave';\r\n    if (clientId) {\r\n      presence.clientId = clientId;\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      switch (channel.state) {\r\n        case 'attached':\r\n          channel.sendPresence(presence, (err) => (err ? reject(err) : resolve()));\r\n          break;\r\n        case 'attaching':\r\n          this.pendingPresence.push({\r\n            presence: presence,\r\n            callback: (err) => (err ? reject(err) : resolve()),\r\n          });\r\n          break;\r\n        case 'initialized':\r\n        case 'failed': {\r\n          /* we're not attached; therefore we let any entered status\r\n           * timeout by itself instead of attaching just in order to leave */\r\n          const err = new PartialErrorInfo('Unable to leave presence channel (incompatible state)', 90001);\r\n          reject(err);\r\n          break;\r\n        }\r\n        default:\r\n          reject(channel.invalidStateError());\r\n      }\r\n    });\r\n  }\r\n\r\n  async get(params?: RealtimePresenceParams): Promise<PresenceMessage[]> {\r\n    const waitForSync = !params || ('waitForSync' in params ? params.waitForSync : true);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      function returnMembers(members: PresenceMap) {\r\n        resolve(params ? members.list(params) : members.values());\r\n      }\r\n\r\n      /* Special-case the suspended state: can still get (stale) presence set if waitForSync is false */\r\n      if (this.channel.state === 'suspended') {\r\n        if (waitForSync) {\r\n          reject(\r\n            ErrorInfo.fromValues({\r\n              statusCode: 400,\r\n              code: 91005,\r\n              message: 'Presence state is out of sync due to channel being in the SUSPENDED state',\r\n            }),\r\n          );\r\n        } else {\r\n          returnMembers(this.members);\r\n        }\r\n        return;\r\n      }\r\n\r\n      waitAttached(\r\n        this.channel,\r\n        (err) => reject(err),\r\n        () => {\r\n          const members = this.members;\r\n          if (waitForSync) {\r\n            members.waitSync(function () {\r\n              returnMembers(members);\r\n            });\r\n          } else {\r\n            returnMembers(members);\r\n          }\r\n        },\r\n      );\r\n    });\r\n  }\r\n\r\n  async history(params: RealtimeHistoryParams | null): Promise<PaginatedResult<PresenceMessage>> {\r\n    Logger.logAction(Logger.LOG_MICRO, 'RealtimePresence.history()', 'channel = ' + this.name);\r\n    // We fetch this first so that any plugin-not-provided error takes priority over other errors\r\n    const restMixin = this.channel.client.rest.presenceMixin;\r\n\r\n    if (params && params.untilAttach) {\r\n      if (this.channel.state === 'attached') {\r\n        delete params.untilAttach;\r\n        params.from_serial = this.channel.properties.attachSerial;\r\n      } else {\r\n        throw new ErrorInfo(\r\n          'option untilAttach requires the channel to be attached, was: ' + this.channel.state,\r\n          40000,\r\n          400,\r\n        );\r\n      }\r\n    }\r\n\r\n    return restMixin.history(this, params);\r\n  }\r\n\r\n  setPresence(presenceSet: PresenceMessage[], isSync: boolean, syncChannelSerial?: string): void {\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'RealtimePresence.setPresence()',\r\n      'received presence for ' + presenceSet.length + ' participants; syncChannelSerial = ' + syncChannelSerial,\r\n    );\r\n    let syncCursor, match;\r\n    const members = this.members,\r\n      myMembers = this._myMembers,\r\n      broadcastMessages = [],\r\n      connId = this.channel.connectionManager.connectionId;\r\n\r\n    if (isSync) {\r\n      this.members.startSync();\r\n      if (syncChannelSerial && (match = syncChannelSerial.match(/^[\\w-]+:(.*)$/))) {\r\n        syncCursor = match[1];\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < presenceSet.length; i++) {\r\n      const presence = presenceMessageFromValues(presenceSet[i]);\r\n      switch (presence.action) {\r\n        case 'leave':\r\n          if (members.remove(presence)) {\r\n            broadcastMessages.push(presence);\r\n          }\r\n          if (presence.connectionId === connId && !presence.isSynthesized()) {\r\n            myMembers.remove(presence);\r\n          }\r\n          break;\r\n        case 'enter':\r\n        case 'present':\r\n        case 'update':\r\n          if (members.put(presence)) {\r\n            broadcastMessages.push(presence);\r\n          }\r\n          if (presence.connectionId === connId) {\r\n            myMembers.put(presence);\r\n          }\r\n          break;\r\n      }\r\n    }\r\n    /* if this is the last (or only) message in a sequence of sync updates, end the sync */\r\n    if (isSync && !syncCursor) {\r\n      members.endSync();\r\n      this.channel.syncChannelSerial = null;\r\n    }\r\n\r\n    /* broadcast to listeners */\r\n    for (let i = 0; i < broadcastMessages.length; i++) {\r\n      const presence = broadcastMessages[i];\r\n      this.subscriptions.emit(presence.action as string, presence);\r\n    }\r\n  }\r\n\r\n  onAttached(hasPresence?: boolean): void {\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'RealtimePresence.onAttached()',\r\n      'channel = ' + this.channel.name + ', hasPresence = ' + hasPresence,\r\n    );\r\n\r\n    if (hasPresence) {\r\n      this.members.startSync();\r\n    } else {\r\n      this._synthesizeLeaves(this.members.values());\r\n      this.members.clear();\r\n    }\r\n\r\n    // RTP17f: Re-enter own members when moving into the attached state.\r\n    this._ensureMyMembersPresent();\r\n\r\n    /* NB this must be after the _ensureMyMembersPresent call, which may add items to pendingPresence */\r\n    const pendingPresence = this.pendingPresence,\r\n      pendingPresCount = pendingPresence.length;\r\n\r\n    if (pendingPresCount) {\r\n      this.pendingPresence = [];\r\n      const presenceArray = [];\r\n      const multicaster = Multicaster.create();\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'RealtimePresence.onAttached',\r\n        'sending ' + pendingPresCount + ' queued presence messages',\r\n      );\r\n      for (let i = 0; i < pendingPresCount; i++) {\r\n        const event = pendingPresence[i];\r\n        presenceArray.push(event.presence);\r\n        multicaster.push(event.callback);\r\n      }\r\n      this.channel.sendPresence(presenceArray, multicaster);\r\n    }\r\n  }\r\n\r\n  actOnChannelState(state: string, hasPresence?: boolean, err?: ErrorInfo | null): void {\r\n    switch (state) {\r\n      case 'attached':\r\n        this.onAttached(hasPresence);\r\n        break;\r\n      case 'detached':\r\n      case 'failed':\r\n        this._clearMyMembers();\r\n        this.members.clear();\r\n      /* falls through */\r\n      case 'suspended':\r\n        this.failPendingPresence(err);\r\n        break;\r\n    }\r\n  }\r\n\r\n  failPendingPresence(err?: ErrorInfo | null): void {\r\n    if (this.pendingPresence.length) {\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'RealtimeChannel.failPendingPresence',\r\n        'channel; name = ' + this.channel.name + ', err = ' + Utils.inspectError(err),\r\n      );\r\n      for (let i = 0; i < this.pendingPresence.length; i++)\r\n        try {\r\n          this.pendingPresence[i].callback(err);\r\n          // eslint-disable-next-line no-empty\r\n        } catch (e) {}\r\n      this.pendingPresence = [];\r\n    }\r\n  }\r\n\r\n  _clearMyMembers(): void {\r\n    this._myMembers.clear();\r\n  }\r\n\r\n  _ensureMyMembersPresent(): void {\r\n    const myMembers = this._myMembers,\r\n      reenterCb = (err?: ErrorInfo | null) => {\r\n        if (err) {\r\n          const msg = 'Presence auto-re-enter failed: ' + err.toString();\r\n          const wrappedErr = new ErrorInfo(msg, 91004, 400);\r\n          Logger.logAction(Logger.LOG_ERROR, 'RealtimePresence._ensureMyMembersPresent()', msg);\r\n          const change = new ChannelStateChange(this.channel.state, this.channel.state, true, false, wrappedErr);\r\n          this.channel.emit('update', change);\r\n        }\r\n      };\r\n\r\n    for (const memberKey in myMembers.map) {\r\n      const entry = myMembers.map[memberKey];\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'RealtimePresence._ensureMyMembersPresent()',\r\n        'Auto-reentering clientId \"' + entry.clientId + '\" into the presence set',\r\n      );\r\n      // RTP17g: Send ENTER containing the member id, clientId and data\r\n      // attributes.\r\n      Utils.whenPromiseSettles(this._enterOrUpdateClient(entry.id, entry.clientId, entry.data, 'enter'), reenterCb);\r\n    }\r\n  }\r\n\r\n  _synthesizeLeaves(items: PresenceMessage[]): void {\r\n    const subscriptions = this.subscriptions;\r\n    items.forEach(function (item) {\r\n      const presence = presenceMessageFromValues({\r\n        action: 'leave',\r\n        connectionId: item.connectionId,\r\n        clientId: item.clientId,\r\n        data: item.data,\r\n        encoding: item.encoding,\r\n        timestamp: Date.now(),\r\n      });\r\n      subscriptions.emit('leave', presence);\r\n    });\r\n  }\r\n\r\n  async subscribe(..._args: unknown[] /* [event], listener */): Promise<void> {\r\n    const args = RealtimeChannel.processListenerArgs(_args);\r\n    const event = args[0];\r\n    const listener = args[1];\r\n    const channel = this.channel;\r\n\r\n    if (channel.state === 'failed') {\r\n      throw ErrorInfo.fromValues(channel.invalidStateError());\r\n    }\r\n\r\n    this.subscriptions.on(event, listener);\r\n    await channel.attach();\r\n  }\r\n\r\n  unsubscribe(..._args: unknown[] /* [event], listener */): void {\r\n    const args = RealtimeChannel.processListenerArgs(_args);\r\n    const event = args[0];\r\n    const listener = args[1];\r\n    this.subscriptions.off(event, listener);\r\n  }\r\n}\r\n\r\nclass PresenceMap extends EventEmitter {\r\n  map: Record<string, PresenceMessage>;\r\n  residualMembers: Record<string, PresenceMessage> | null;\r\n  syncInProgress: boolean;\r\n  presence: RealtimePresence;\r\n  memberKey: (item: PresenceMessage) => string;\r\n\r\n  constructor(presence: RealtimePresence, memberKey: (item: PresenceMessage) => string) {\r\n    super();\r\n    this.presence = presence;\r\n    this.map = Object.create(null);\r\n    this.syncInProgress = false;\r\n    this.residualMembers = null;\r\n    this.memberKey = memberKey;\r\n  }\r\n\r\n  get(key: string) {\r\n    return this.map[key];\r\n  }\r\n\r\n  getClient(clientId: string) {\r\n    const map = this.map,\r\n      result = [];\r\n    for (const key in map) {\r\n      const item = map[key];\r\n      if (item.clientId == clientId && item.action != 'absent') result.push(item);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  list(params: RealtimePresenceParams) {\r\n    const map = this.map,\r\n      clientId = params && params.clientId,\r\n      connectionId = params && params.connectionId,\r\n      result = [];\r\n\r\n    for (const key in map) {\r\n      const item = map[key];\r\n      if (item.action === 'absent') continue;\r\n      if (clientId && clientId != item.clientId) continue;\r\n      if (connectionId && connectionId != item.connectionId) continue;\r\n      result.push(item);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  put(item: PresenceMessage) {\r\n    if (item.action === 'enter' || item.action === 'update') {\r\n      item = presenceMessageFromValues(item);\r\n      item.action = 'present';\r\n    }\r\n    const map = this.map,\r\n      key = this.memberKey(item);\r\n    /* we've seen this member, so do not remove it at the end of sync */\r\n    if (this.residualMembers) delete this.residualMembers[key];\r\n\r\n    /* compare the timestamp of the new item with any existing member (or ABSENT witness) */\r\n    const existingItem = map[key];\r\n    if (existingItem && !newerThan(item, existingItem)) {\r\n      return false;\r\n    }\r\n    map[key] = item;\r\n    return true;\r\n  }\r\n\r\n  values() {\r\n    const map = this.map,\r\n      result = [];\r\n    for (const key in map) {\r\n      const item = map[key];\r\n      if (item.action != 'absent') result.push(item);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  remove(item: PresenceMessage) {\r\n    const map = this.map,\r\n      key = this.memberKey(item);\r\n    const existingItem = map[key];\r\n\r\n    if (existingItem && !newerThan(item, existingItem)) {\r\n      return false;\r\n    }\r\n\r\n    /* RTP2f */\r\n    if (this.syncInProgress) {\r\n      item = presenceMessageFromValues(item);\r\n      item.action = 'absent';\r\n      map[key] = item;\r\n    } else {\r\n      delete map[key];\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  startSync() {\r\n    const map = this.map,\r\n      syncInProgress = this.syncInProgress;\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'PresenceMap.startSync()',\r\n      'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress,\r\n    );\r\n    /* we might be called multiple times while a sync is in progress */\r\n    if (!this.syncInProgress) {\r\n      this.residualMembers = Utils.copy(map);\r\n      this.setInProgress(true);\r\n    }\r\n  }\r\n\r\n  endSync() {\r\n    const map = this.map,\r\n      syncInProgress = this.syncInProgress;\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'PresenceMap.endSync()',\r\n      'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress,\r\n    );\r\n    if (syncInProgress) {\r\n      /* we can now strip out the ABSENT members, as we have\r\n       * received all of the out-of-order sync messages */\r\n      for (const memberKey in map) {\r\n        const entry = map[memberKey];\r\n        if (entry.action === 'absent') {\r\n          delete map[memberKey];\r\n        }\r\n      }\r\n      /* any members that were present at the start of the sync,\r\n       * and have not been seen in sync, can be removed, and leave events emitted */\r\n      this.presence._synthesizeLeaves(Utils.valuesArray(this.residualMembers as Record<string, PresenceMessage>));\r\n      for (const memberKey in this.residualMembers) {\r\n        delete map[memberKey];\r\n      }\r\n      this.residualMembers = null;\r\n\r\n      /* finish, notifying any waiters */\r\n      this.setInProgress(false);\r\n    }\r\n    this.emit('sync');\r\n  }\r\n\r\n  waitSync(callback: () => void) {\r\n    const syncInProgress = this.syncInProgress;\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'PresenceMap.waitSync()',\r\n      'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress,\r\n    );\r\n    if (!syncInProgress) {\r\n      callback();\r\n      return;\r\n    }\r\n    this.once('sync', callback);\r\n  }\r\n\r\n  clear() {\r\n    this.map = {};\r\n    this.setInProgress(false);\r\n    this.residualMembers = null;\r\n  }\r\n\r\n  setInProgress(inProgress: boolean) {\r\n    Logger.logAction(Logger.LOG_MICRO, 'PresenceMap.setInProgress()', 'inProgress = ' + inProgress);\r\n    this.syncInProgress = inProgress;\r\n    this.presence.syncComplete = !inProgress;\r\n  }\r\n}\r\n\r\nexport default RealtimePresence;\r\n", "import Platform from 'common/platform';\r\nimport * as Utils from '../util/utils';\r\nimport Transport from './transport';\r\nimport Defaults from '../util/defaults';\r\nimport Logger from '../util/logger';\r\nimport ProtocolMessage, {\r\n  serialize as serializeProtocolMessage,\r\n  deserialize as deserializeProtocolMessage,\r\n} from '../types/protocolmessage';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport NodeWebSocket from 'ws';\r\nimport ConnectionManager, { TransportParams } from './connectionmanager';\r\nimport Auth from '../client/auth';\r\nimport { TransportNames } from 'common/constants/TransportName';\r\n\r\nconst shortName = TransportNames.WebSocket;\r\n\r\nfunction isNodeWebSocket(ws: WebSocket | NodeWebSocket): ws is NodeWebSocket {\r\n  return !!(ws as NodeWebSocket).on;\r\n}\r\n\r\nclass WebSocketTransport extends Transport {\r\n  shortName = shortName;\r\n  wsHost: string;\r\n  uri?: string;\r\n  wsConnection?: WebSocket | NodeWebSocket;\r\n\r\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams) {\r\n    super(connectionManager, auth, params);\r\n    /* If is a browser, can't detect pings, so request protocol heartbeats */\r\n    params.heartbeats = Platform.Config.useProtocolHeartbeats;\r\n    this.wsHost = params.host as string;\r\n  }\r\n\r\n  static isAvailable() {\r\n    return !!Platform.Config.WebSocket;\r\n  }\r\n\r\n  createWebSocket(uri: string, connectParams: Record<string, string>) {\r\n    this.uri = uri + Utils.toQueryString(connectParams);\r\n    return new Platform.Config.WebSocket(this.uri);\r\n  }\r\n\r\n  toString() {\r\n    return 'WebSocketTransport; uri=' + this.uri;\r\n  }\r\n\r\n  connect() {\r\n    Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.connect()', 'starting');\r\n    Transport.prototype.connect.call(this);\r\n    const self = this,\r\n      params = this.params,\r\n      options = params.options;\r\n    const wsScheme = options.tls ? 'wss://' : 'ws://';\r\n    const wsUri = wsScheme + this.wsHost + ':' + Defaults.getPort(options) + '/';\r\n    Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.connect()', 'uri: ' + wsUri);\r\n    Utils.whenPromiseSettles(\r\n      this.auth.getAuthParams(),\r\n      function (err: ErrorInfo | null, authParams?: Record<string, string>) {\r\n        if (self.isDisposed) {\r\n          return;\r\n        }\r\n        let paramStr = '';\r\n        for (const param in authParams) paramStr += ' ' + param + ': ' + authParams[param] + ';';\r\n        Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.connect()', 'authParams:' + paramStr + ' err: ' + err);\r\n        if (err) {\r\n          self.disconnect(err);\r\n          return;\r\n        }\r\n        const connectParams = params.getConnectParams(authParams!);\r\n        try {\r\n          const wsConnection = (self.wsConnection = self.createWebSocket(wsUri, connectParams));\r\n          wsConnection.binaryType = Platform.Config.binaryType;\r\n          wsConnection.onopen = function () {\r\n            self.onWsOpen();\r\n          };\r\n          wsConnection.onclose = function (ev: CloseEvent) {\r\n            self.onWsClose(ev);\r\n          };\r\n          wsConnection.onmessage = function (ev: MessageEvent) {\r\n            self.onWsData(ev.data);\r\n          };\r\n          wsConnection.onerror = function (ev: Event) {\r\n            self.onWsError(ev as ErrorEvent);\r\n          };\r\n          if (isNodeWebSocket(wsConnection)) {\r\n            /* node; browsers currently don't have a general eventemitter and can't detect\r\n             * pings. Also, no need to reply with a pong explicitly, ws lib handles that */\r\n            wsConnection.on('ping', function () {\r\n              self.onActivity();\r\n            });\r\n          }\r\n        } catch (e) {\r\n          Logger.logAction(\r\n            Logger.LOG_ERROR,\r\n            'WebSocketTransport.connect()',\r\n            'Unexpected exception creating websocket: err = ' + ((e as Error).stack || (e as Error).message),\r\n          );\r\n          self.disconnect(e as Error);\r\n        }\r\n      },\r\n    );\r\n  }\r\n\r\n  send(message: ProtocolMessage) {\r\n    const wsConnection = this.wsConnection;\r\n    if (!wsConnection) {\r\n      Logger.logAction(Logger.LOG_ERROR, 'WebSocketTransport.send()', 'No socket connection');\r\n      return;\r\n    }\r\n    try {\r\n      (wsConnection as NodeWebSocket).send(\r\n        serializeProtocolMessage(message, this.connectionManager.realtime._MsgPack, this.params.format),\r\n      );\r\n    } catch (e) {\r\n      const msg = 'Exception from ws connection when trying to send: ' + Utils.inspectError(e);\r\n      Logger.logAction(Logger.LOG_ERROR, 'WebSocketTransport.send()', msg);\r\n      /* Don't try to request a disconnect, that'll just involve sending data\r\n       * down the websocket again. Just finish the transport. */\r\n      this.finish('disconnected', new ErrorInfo(msg, 50000, 500));\r\n    }\r\n  }\r\n\r\n  onWsData(data: string) {\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'WebSocketTransport.onWsData()',\r\n      'data received; length = ' + data.length + '; type = ' + typeof data,\r\n    );\r\n    try {\r\n      this.onProtocolMessage(\r\n        deserializeProtocolMessage(\r\n          data,\r\n          this.connectionManager.realtime._MsgPack,\r\n          this.connectionManager.realtime._RealtimePresence,\r\n          this.format,\r\n        ),\r\n      );\r\n    } catch (e) {\r\n      Logger.logAction(\r\n        Logger.LOG_ERROR,\r\n        'WebSocketTransport.onWsData()',\r\n        'Unexpected exception handing channel message: ' + (e as Error).stack,\r\n      );\r\n    }\r\n  }\r\n\r\n  onWsOpen() {\r\n    Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.onWsOpen()', 'opened WebSocket');\r\n    this.emit('preconnect');\r\n  }\r\n\r\n  onWsClose(ev: number | CloseEvent) {\r\n    let wasClean, code;\r\n    if (typeof ev == 'object') {\r\n      /* W3C spec-compatible */\r\n      code = ev.code;\r\n      // ev.wasClean is undefined in reactnative\r\n      wasClean = ev.wasClean || code === 1000;\r\n    } /*if(typeof(ev) == 'number')*/ else {\r\n      /* ws in node */\r\n      code = ev;\r\n      wasClean = code == 1000;\r\n    }\r\n    delete this.wsConnection;\r\n    if (wasClean) {\r\n      Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.onWsClose()', 'Cleanly closed WebSocket');\r\n      const err = new ErrorInfo('Websocket closed', 80003, 400);\r\n      this.finish('disconnected', err);\r\n    } else {\r\n      const msg = 'Unclean disconnection of WebSocket ; code = ' + code,\r\n        err = new ErrorInfo(msg, 80003, 400);\r\n      Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.onWsClose()', msg);\r\n      this.finish('disconnected', err);\r\n    }\r\n    this.emit('disposed');\r\n  }\r\n\r\n  onWsError(err: ErrorEvent) {\r\n    Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.onError()', 'Error from WebSocket: ' + err.message);\r\n    /* Wait a tick before aborting: if the websocket was connected, this event\r\n     * will be immediately followed by an onclose event with a close code. Allow\r\n     * that to close it (so we see the close code) rather than anticipating it */\r\n    Platform.Config.nextTick(() => {\r\n      this.disconnect(Error(err.message));\r\n    });\r\n  }\r\n\r\n  dispose() {\r\n    Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.dispose()', '');\r\n    this.isDisposed = true;\r\n    const wsConnection = this.wsConnection;\r\n    if (wsConnection) {\r\n      /* Ignore any messages that come through after dispose() is called but before\r\n       * websocket is actually closed. (mostly would be harmless, but if it's a\r\n       * CONNECTED, it'll re-tick isConnected and cause all sorts of havoc) */\r\n      wsConnection.onmessage = function () {};\r\n      delete this.wsConnection;\r\n      /* defer until the next event loop cycle before closing the socket,\r\n       * giving some implementations the opportunity to send any outstanding close message */\r\n      Platform.Config.nextTick(function () {\r\n        Logger.logAction(Logger.LOG_MICRO, 'WebSocketTransport.dispose()', 'closing websocket');\r\n        if (!wsConnection) {\r\n          throw new Error('WebSocketTransport.dispose(): wsConnection is not defined');\r\n        }\r\n        wsConnection.close();\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport default WebSocketTransport;\r\n", "import * as API from '../../../../ably';\r\nimport RealtimeChannel from './realtimechannel';\r\nimport Message from '../types/message';\r\n\r\nexport class FilteredSubscriptions {\r\n  static subscribeFilter(channel: RealtimeChannel, filter: API.MessageFilter, listener: API.messageCallback<Message>) {\r\n    const filteredListener = (m: Message) => {\r\n      const mapping: { [key in keyof API.MessageFilter]: any } = {\r\n        name: m.name,\r\n        refTimeserial: m.extras?.ref?.timeserial,\r\n        refType: m.extras?.ref?.type,\r\n        isRef: !!m.extras?.ref?.timeserial,\r\n        clientId: m.clientId,\r\n      };\r\n      // Check if any values are defined in the filter and if they match the value in the message object\r\n      if (\r\n        Object.entries(filter).find(([key, value]) =>\r\n          value !== undefined ? mapping[key as keyof API.MessageFilter] !== value : false,\r\n        )\r\n      ) {\r\n        return;\r\n      }\r\n      listener(m);\r\n    };\r\n    this.addFilteredSubscription(channel, filter, listener, filteredListener);\r\n    channel.subscriptions.on(filteredListener);\r\n  }\r\n\r\n  // Adds a new filtered subscription\r\n  static addFilteredSubscription(\r\n    channel: RealtimeChannel,\r\n    filter: API.MessageFilter,\r\n    realListener: API.messageCallback<Message>,\r\n    filteredListener: API.messageCallback<Message>,\r\n  ) {\r\n    if (!channel.filteredSubscriptions) {\r\n      channel.filteredSubscriptions = new Map<\r\n        API.messageCallback<Message>,\r\n        Map<API.MessageFilter, API.messageCallback<Message>[]>\r\n      >();\r\n    }\r\n    if (channel.filteredSubscriptions.has(realListener)) {\r\n      const realListenerMap = channel.filteredSubscriptions.get(realListener) as Map<\r\n        API.MessageFilter,\r\n        API.messageCallback<Message>[]\r\n      >;\r\n      // Add the filtered listener to the map, or append to the array if this filter has already been used\r\n      realListenerMap.set(filter, realListenerMap?.get(filter)?.concat(filteredListener) || [filteredListener]);\r\n    } else {\r\n      channel.filteredSubscriptions.set(\r\n        realListener,\r\n        new Map<API.MessageFilter, API.messageCallback<Message>[]>([[filter, [filteredListener]]]),\r\n      );\r\n    }\r\n  }\r\n\r\n  static getAndDeleteFilteredSubscriptions(\r\n    channel: RealtimeChannel,\r\n    filter: API.MessageFilter | undefined,\r\n    realListener: API.messageCallback<Message> | undefined,\r\n  ): API.messageCallback<Message>[] {\r\n    // No filtered subscriptions map means there has been no filtered subscriptions yet, so return nothing\r\n    if (!channel.filteredSubscriptions) {\r\n      return [];\r\n    }\r\n    // Only a filter is passed in with no specific listener\r\n    if (!realListener && filter) {\r\n      // Return each listener which is attached to the specified filter object\r\n      return Array.from(channel.filteredSubscriptions.entries())\r\n        .map(([key, filterMaps]) => {\r\n          // Get (then delete) the maps matching this filter\r\n          let listenerMaps = filterMaps.get(filter);\r\n          filterMaps.delete(filter);\r\n          // Clear the parent if nothing is left\r\n          if (filterMaps.size === 0) {\r\n            channel.filteredSubscriptions?.delete(key);\r\n          }\r\n          return listenerMaps;\r\n        })\r\n        .reduce(\r\n          (prev, cur) => (cur ? (prev as API.messageCallback<Message>[]).concat(...cur) : prev),\r\n          [],\r\n        ) as API.messageCallback<Message>[];\r\n    }\r\n\r\n    // No subscriptions for this listener\r\n    if (!realListener || !channel.filteredSubscriptions.has(realListener)) {\r\n      return [];\r\n    }\r\n    const realListenerMap = channel.filteredSubscriptions.get(realListener) as Map<\r\n      API.MessageFilter,\r\n      API.messageCallback<Message>[]\r\n    >;\r\n    // If no filter is specified return all listeners using that function\r\n    if (!filter) {\r\n      // array.flat is not available unless we support es2019 or higher\r\n      const listeners = Array.from(realListenerMap.values()).reduce((prev, cur) => prev.concat(...cur), []);\r\n      // remove the listener from the map\r\n      channel.filteredSubscriptions.delete(realListener);\r\n      return listeners;\r\n    }\r\n\r\n    let listeners = realListenerMap.get(filter);\r\n    realListenerMap.delete(filter);\r\n\r\n    return listeners || [];\r\n  }\r\n}\r\n", "import BaseRealtime from './baserealtime';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport { allCommonModularPlugins } from './modularplugins';\r\nimport * as Utils from '../util/utils';\r\nimport ConnectionManager from '../transport/connectionmanager';\r\nimport ProtocolMessage from '../types/protocolmessage';\r\nimport Platform from 'common/platform';\r\nimport { DefaultMessage } from '../types/defaultmessage';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport RealtimePresence from './realtimepresence';\r\nimport { DefaultPresenceMessage } from '../types/defaultpresencemessage';\r\nimport WebSocketTransport from '../transport/websockettransport';\r\nimport { FilteredSubscriptions } from './filteredsubscriptions';\r\nimport {\r\n  fromValues as presenceMessageFromValues,\r\n  fromValuesArray as presenceMessagesFromValuesArray,\r\n} from '../types/presencemessage';\r\nimport { Http } from 'common/types/http';\r\nimport Defaults from '../util/defaults';\r\n\r\n/**\r\n `DefaultRealtime` is the class that the non tree-shakable version of the SDK exports as `Realtime`. It ensures that this version of the SDK includes all of the functionality which is optionally available in the tree-shakable version.\r\n */\r\nexport class DefaultRealtime extends BaseRealtime {\r\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\r\n  constructor(options?: ClientOptions | string) {\r\n    const MsgPack = DefaultRealtime._MsgPack;\r\n    if (!MsgPack) {\r\n      throw new Error('Expected DefaultRealtime._MsgPack to have been set');\r\n    }\r\n\r\n    super(\r\n      Defaults.objectifyOptions(options, true, 'Realtime', {\r\n        ...allCommonModularPlugins,\r\n        Crypto: DefaultRealtime.Crypto ?? undefined,\r\n        MsgPack,\r\n        RealtimePresence: {\r\n          RealtimePresence,\r\n          presenceMessageFromValues,\r\n          presenceMessagesFromValuesArray,\r\n        },\r\n        WebSocketTransport,\r\n        MessageInteractions: FilteredSubscriptions,\r\n      }),\r\n    );\r\n  }\r\n\r\n  static Utils = Utils;\r\n  static ConnectionManager = ConnectionManager;\r\n  static ProtocolMessage = ProtocolMessage;\r\n\r\n  private static _Crypto: typeof Platform.Crypto = null;\r\n  static get Crypto() {\r\n    if (this._Crypto === null) {\r\n      throw new Error('Encryption not enabled; use ably.encryption.js instead');\r\n    }\r\n\r\n    return this._Crypto;\r\n  }\r\n  static set Crypto(newValue: typeof Platform.Crypto) {\r\n    this._Crypto = newValue;\r\n  }\r\n\r\n  static Message = DefaultMessage;\r\n  static PresenceMessage = DefaultPresenceMessage;\r\n\r\n  static _MsgPack: MsgPack | null = null;\r\n\r\n  // Used by tests\r\n  static _Http = Http;\r\n}\r\n", "/**\r\n * Copied from https://gist.github.com/stevendesu/2d52f7b5e1f1184af3b667c0b5e054b8\r\n *\r\n * \"A simple, open-source, HMAC-SHA256 implementation in pure JavaScript. Designed for efficient minification.\"\r\n *\r\n * I asked about licensing, and the author said:\r\n *\r\n * > Feel free to use it however you'd like \uD83D\uDE04 As the gist title indicates,\r\n * > this is \"a simple open source implementation\". Feel free to choose whatever\r\n * > license you find most permissible, but I offer no warranty for the code.\r\n * > It's 100% free to do with as you please.\r\n */\r\n\r\n// To ensure cross-browser support even without a proper SubtleCrypto\r\n// impelmentation (or without access to the impelmentation, as is the case with\r\n// Chrome loaded over HTTP instead of HTTPS), this library can create SHA-256\r\n// HMAC signatures using nothing but raw JavaScript\r\n\r\n/* eslint-disable no-magic-numbers, id-length, no-param-reassign, new-cap */\r\n\r\n// By giving internal functions names that we can mangle, future calls to\r\n// them are reduced to a single byte (minor space savings in minified file)\r\nvar uint8Array = Uint8Array;\r\nvar uint32Array = Uint32Array;\r\nvar pow = Math.pow;\r\n\r\n// Will be initialized below\r\n// Using a Uint32Array instead of a simple array makes the minified code\r\n// a bit bigger (we lose our `unshift()` hack), but comes with huge\r\n// performance gains\r\nvar DEFAULT_STATE = new uint32Array(8);\r\nvar ROUND_CONSTANTS: number[] = [];\r\n\r\n// Reusable object for expanded message\r\n// Using a Uint32Array instead of a simple array makes the minified code\r\n// 7 bytes larger, but comes with huge performance gains\r\nvar M = new uint32Array(64);\r\n\r\n// After minification the code to compute the default state and round\r\n// constants is smaller than the output. More importantly, this serves as a\r\n// good educational aide for anyone wondering where the magic numbers come\r\n// from. No magic numbers FTW!\r\nfunction getFractionalBits(n: number) {\r\n  return ((n - (n | 0)) * pow(2, 32)) | 0;\r\n}\r\n\r\nvar n = 2,\r\n  nPrime = 0;\r\nwhile (nPrime < 64) {\r\n  // isPrime() was in-lined from its original function form to save\r\n  // a few bytes\r\n  var isPrime = true;\r\n  // Math.sqrt() was replaced with pow(n, 1/2) to save a few bytes\r\n  // var sqrtN = pow(n, 1 / 2);\r\n  // So technically to determine if a number is prime you only need to\r\n  // check numbers up to the square root. However this function only runs\r\n  // once and we're only computing the first 64 primes (up to 311), so on\r\n  // any modern CPU this whole function runs in a couple milliseconds.\r\n  // By going to n / 2 instead of sqrt(n) we net 8 byte savings and no\r\n  // scaling performance cost\r\n  for (var factor = 2; factor <= n / 2; factor++) {\r\n    if (n % factor === 0) {\r\n      isPrime = false;\r\n    }\r\n  }\r\n  if (isPrime) {\r\n    if (nPrime < 8) {\r\n      DEFAULT_STATE[nPrime] = getFractionalBits(pow(n, 1 / 2));\r\n    }\r\n    ROUND_CONSTANTS[nPrime] = getFractionalBits(pow(n, 1 / 3));\r\n\r\n    nPrime++;\r\n  }\r\n\r\n  n++;\r\n}\r\n\r\n// For cross-platform support we need to ensure that all 32-bit words are\r\n// in the same endianness. A UTF-8 TextEncoder will return BigEndian data,\r\n// so upon reading or writing to our ArrayBuffer we'll only swap the bytes\r\n// if our system is LittleEndian (which is about 99% of CPUs)\r\nvar LittleEndian = !!new uint8Array(new uint32Array([1]).buffer)[0];\r\n\r\nfunction convertEndian(word: number) {\r\n  if (LittleEndian) {\r\n    return (\r\n      // byte 1 -> byte 4\r\n      (word >>> 24) |\r\n      // byte 2 -> byte 3\r\n      (((word >>> 16) & 0xff) << 8) |\r\n      // byte 3 -> byte 2\r\n      ((word & 0xff00) << 8) |\r\n      // byte 4 -> byte 1\r\n      (word << 24)\r\n    );\r\n  } else {\r\n    return word;\r\n  }\r\n}\r\n\r\nfunction rightRotate(word: number, bits: number) {\r\n  return (word >>> bits) | (word << (32 - bits));\r\n}\r\n\r\nfunction sha256(data: Uint8Array) {\r\n  // Copy default state\r\n  var STATE = DEFAULT_STATE.slice();\r\n\r\n  // Caching this reduces occurrences of \".length\" in minified JavaScript\r\n  // 3 more byte savings! :D\r\n  var legth = data.length;\r\n\r\n  // Pad data\r\n  var bitLength = legth * 8;\r\n  var newBitLength = 512 - ((bitLength + 64) % 512) - 1 + bitLength + 65;\r\n\r\n  // \"bytes\" and \"words\" are stored BigEndian\r\n  var bytes = new uint8Array(newBitLength / 8);\r\n  var words = new uint32Array(bytes.buffer);\r\n\r\n  bytes.set(data, 0);\r\n  // Append a 1\r\n  bytes[legth] = 0b10000000;\r\n  // Store length in BigEndian\r\n  words[words.length - 1] = convertEndian(bitLength);\r\n\r\n  // Loop iterator (avoid two instances of \"var\") -- saves 2 bytes\r\n  var round;\r\n\r\n  // Process blocks (512 bits / 64 bytes / 16 words at a time)\r\n  for (var block = 0; block < newBitLength / 32; block += 16) {\r\n    var workingState = STATE.slice();\r\n\r\n    // Rounds\r\n    for (round = 0; round < 64; round++) {\r\n      var MRound;\r\n      // Expand message\r\n      if (round < 16) {\r\n        // Convert to platform Endianness for later math\r\n        MRound = convertEndian(words[block + round]);\r\n      } else {\r\n        var gamma0x = M[round - 15];\r\n        var gamma1x = M[round - 2];\r\n        MRound =\r\n          M[round - 7] +\r\n          M[round - 16] +\r\n          (rightRotate(gamma0x, 7) ^ rightRotate(gamma0x, 18) ^ (gamma0x >>> 3)) +\r\n          (rightRotate(gamma1x, 17) ^ rightRotate(gamma1x, 19) ^ (gamma1x >>> 10));\r\n      }\r\n\r\n      // M array matches platform endianness\r\n      M[round] = MRound |= 0;\r\n\r\n      // Computation\r\n      var t1 =\r\n        (rightRotate(workingState[4], 6) ^ rightRotate(workingState[4], 11) ^ rightRotate(workingState[4], 25)) +\r\n        ((workingState[4] & workingState[5]) ^ (~workingState[4] & workingState[6])) +\r\n        workingState[7] +\r\n        MRound +\r\n        ROUND_CONSTANTS[round];\r\n      var t2 =\r\n        (rightRotate(workingState[0], 2) ^ rightRotate(workingState[0], 13) ^ rightRotate(workingState[0], 22)) +\r\n        ((workingState[0] & workingState[1]) ^ (workingState[2] & (workingState[0] ^ workingState[1])));\r\n      for (var i = 7; i > 0; i--) {\r\n        workingState[i] = workingState[i - 1];\r\n      }\r\n      workingState[0] = (t1 + t2) | 0;\r\n      workingState[4] = (workingState[4] + t1) | 0;\r\n    }\r\n\r\n    // Update state\r\n    for (round = 0; round < 8; round++) {\r\n      STATE[round] = (STATE[round] + workingState[round]) | 0;\r\n    }\r\n  }\r\n\r\n  // Finally the state needs to be converted to BigEndian for output\r\n  // And we want to return a Uint8Array, not a Uint32Array\r\n  return new uint8Array(\r\n    new uint32Array(\r\n      STATE.map(function (val) {\r\n        return convertEndian(val);\r\n      }),\r\n    ).buffer,\r\n  );\r\n}\r\n\r\nexport function hmac(key: Uint8Array, data: Uint8Array) {\r\n  if (key.length > 64) key = sha256(key);\r\n\r\n  if (key.length < 64) {\r\n    const tmp = new Uint8Array(64);\r\n    tmp.set(key, 0);\r\n    key = tmp;\r\n  }\r\n\r\n  // Generate inner and outer keys\r\n  var innerKey = new Uint8Array(64);\r\n  var outerKey = new Uint8Array(64);\r\n  for (var i = 0; i < 64; i++) {\r\n    innerKey[i] = 0x36 ^ key[i];\r\n    outerKey[i] = 0x5c ^ key[i];\r\n  }\r\n\r\n  // Append the innerKey\r\n  var msg = new Uint8Array(data.length + 64);\r\n  msg.set(innerKey, 0);\r\n  msg.set(data, 64);\r\n\r\n  // Has the previous message and append the outerKey\r\n  var result = new Uint8Array(64 + 32);\r\n  result.set(outerKey, 0);\r\n  result.set(sha256(msg), 64);\r\n\r\n  // Hash the previous message\r\n  return sha256(result);\r\n}\r\n", "import Platform from 'common/platform';\r\nimport IBufferUtils from 'common/types/IBufferUtils';\r\nimport { hmac as hmacSha256 } from './hmac-sha256';\r\n\r\n/* Most BufferUtils methods that return a binary object return an ArrayBuffer\r\n * The exception is toBuffer, which returns a Uint8Array */\r\n\r\nexport type Bufferlike = BufferSource;\r\nexport type Output = Bufferlike;\r\nexport type ToBufferOutput = Uint8Array;\r\n\r\nclass BufferUtils implements IBufferUtils<Bufferlike, Output, ToBufferOutput> {\r\n  base64CharSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n  hexCharSet = '0123456789abcdef';\r\n\r\n  // https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js\r\n  private uint8ViewToBase64(bytes: Uint8Array): string {\r\n    let base64 = '';\r\n    const encodings = this.base64CharSet;\r\n\r\n    const byteLength = bytes.byteLength;\r\n    const byteRemainder = byteLength % 3;\r\n    const mainLength = byteLength - byteRemainder;\r\n\r\n    let a, b, c, d;\r\n    let chunk;\r\n\r\n    // Main loop deals with bytes in chunks of 3\r\n    for (let i = 0; i < mainLength; i = i + 3) {\r\n      // Combine the three bytes into a single integer\r\n      chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\r\n\r\n      // Use bitmasks to extract 6-bit segments from the triplet\r\n      a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\r\n      b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\r\n      c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\r\n      d = chunk & 63; // 63       = 2^6 - 1\r\n\r\n      // Convert the raw binary segments to the appropriate ASCII encoding\r\n      base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\r\n    }\r\n\r\n    // Deal with the remaining bytes and padding\r\n    if (byteRemainder == 1) {\r\n      chunk = bytes[mainLength];\r\n\r\n      a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\r\n\r\n      // Set the 4 least significant bits to zero\r\n      b = (chunk & 3) << 4; // 3   = 2^2 - 1\r\n\r\n      base64 += encodings[a] + encodings[b] + '==';\r\n    } else if (byteRemainder == 2) {\r\n      chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];\r\n\r\n      a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\r\n      b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\r\n\r\n      // Set the 2 least significant bits to zero\r\n      c = (chunk & 15) << 2; // 15    = 2^4 - 1\r\n\r\n      base64 += encodings[a] + encodings[b] + encodings[c] + '=';\r\n    }\r\n\r\n    return base64;\r\n  }\r\n\r\n  private base64ToArrayBuffer(base64: string): Output {\r\n    const binary_string = atob?.(base64) as string; // this will always be defined in browser so it's safe to cast\r\n    const len = binary_string.length;\r\n    const bytes = new Uint8Array(len);\r\n    for (let i = 0; i < len; i++) {\r\n      const ascii = binary_string.charCodeAt(i);\r\n      bytes[i] = ascii;\r\n    }\r\n    return this.toArrayBuffer(bytes);\r\n  }\r\n\r\n  isBuffer(buffer: unknown): buffer is Bufferlike {\r\n    return buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer);\r\n  }\r\n\r\n  toBuffer(buffer: Bufferlike): ToBufferOutput {\r\n    if (!ArrayBuffer) {\r\n      throw new Error(\"Can't convert to Buffer: browser does not support the necessary types\");\r\n    }\r\n\r\n    if (buffer instanceof ArrayBuffer) {\r\n      return new Uint8Array(buffer);\r\n    }\r\n\r\n    if (ArrayBuffer.isView(buffer)) {\r\n      return new Uint8Array(this.toArrayBuffer(buffer));\r\n    }\r\n\r\n    throw new Error('BufferUtils.toBuffer expected an ArrayBuffer or a view onto one');\r\n  }\r\n\r\n  toArrayBuffer(buffer: Bufferlike): ArrayBuffer {\r\n    if (!ArrayBuffer) {\r\n      throw new Error(\"Can't convert to ArrayBuffer: browser does not support the necessary types\");\r\n    }\r\n\r\n    if (buffer instanceof ArrayBuffer) {\r\n      return buffer;\r\n    }\r\n\r\n    if (ArrayBuffer.isView(buffer)) {\r\n      return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\r\n    }\r\n\r\n    throw new Error('BufferUtils.toArrayBuffer expected an ArrayBuffer or a view onto one');\r\n  }\r\n\r\n  base64Encode(buffer: Bufferlike): string {\r\n    return this.uint8ViewToBase64(this.toBuffer(buffer));\r\n  }\r\n\r\n  base64Decode(str: string): Output {\r\n    if (ArrayBuffer && Platform.Config.atob) {\r\n      return this.base64ToArrayBuffer(str);\r\n    } else {\r\n      throw new Error('Expected ArrayBuffer to exist and Platform.Config.atob to be configured');\r\n    }\r\n  }\r\n\r\n  hexEncode(buffer: Bufferlike): string {\r\n    const uint8Array = this.toBuffer(buffer);\r\n    return uint8Array.reduce((accum, byte) => accum + byte.toString(16).padStart(2, '0'), '');\r\n  }\r\n\r\n  hexDecode(hexEncodedBytes: string): Output {\r\n    if (hexEncodedBytes.length % 2 !== 0) {\r\n      throw new Error(\"Can't create a byte array from a hex string of odd length\");\r\n    }\r\n\r\n    const uint8Array = new Uint8Array(hexEncodedBytes.length / 2);\r\n\r\n    for (let i = 0; i < uint8Array.length; i++) {\r\n      uint8Array[i] = parseInt(hexEncodedBytes.slice(2 * i, 2 * (i + 1)), 16);\r\n    }\r\n\r\n    return this.toArrayBuffer(uint8Array);\r\n  }\r\n\r\n  utf8Encode(string: string): Output {\r\n    if (Platform.Config.TextEncoder) {\r\n      const encodedByteArray = new Platform.Config.TextEncoder().encode(string);\r\n      return this.toArrayBuffer(encodedByteArray);\r\n    } else {\r\n      throw new Error('Expected TextEncoder to be configured');\r\n    }\r\n  }\r\n\r\n  /* For utf8 decoding we apply slightly stricter input validation than to\r\n   * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from\r\n   * can take (in particular allowing strings, which are just interpreted as\r\n   * binary); here we ensure that the input is actually a buffer since trying\r\n   * to utf8-decode a string to another string is almost certainly a mistake */\r\n  utf8Decode(buffer: Bufferlike): string {\r\n    if (!this.isBuffer(buffer)) {\r\n      throw new Error('Expected input of utf8decode to be an arraybuffer or typed array');\r\n    }\r\n    if (TextDecoder) {\r\n      return new TextDecoder().decode(buffer);\r\n    } else {\r\n      throw new Error('Expected TextDecoder to be configured');\r\n    }\r\n  }\r\n\r\n  areBuffersEqual(buffer1: Bufferlike, buffer2: Bufferlike): boolean {\r\n    if (!buffer1 || !buffer2) return false;\r\n    const arrayBuffer1 = this.toArrayBuffer(buffer1);\r\n    const arrayBuffer2 = this.toArrayBuffer(buffer2);\r\n\r\n    if (arrayBuffer1.byteLength != arrayBuffer2.byteLength) return false;\r\n\r\n    const bytes1 = new Uint8Array(arrayBuffer1);\r\n    const bytes2 = new Uint8Array(arrayBuffer2);\r\n\r\n    for (var i = 0; i < bytes1.length; i++) {\r\n      if (bytes1[i] != bytes2[i]) return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  byteLength(buffer: Bufferlike): number {\r\n    if (buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer)) {\r\n      return buffer.byteLength;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  arrayBufferViewToBuffer(arrayBufferView: ArrayBufferView): ArrayBuffer {\r\n    return this.toArrayBuffer(arrayBufferView);\r\n  }\r\n\r\n  hmacSha256(message: Bufferlike, key: Bufferlike): Output {\r\n    const hash = hmacSha256(this.toBuffer(key), this.toBuffer(message));\r\n    return this.toArrayBuffer(hash);\r\n  }\r\n}\r\n\r\nexport default new BufferUtils();\r\n", "import Logger from '../../../../common/lib/util/logger';\r\nimport ErrorInfo from 'common/lib/types/errorinfo';\r\nimport * as API from '../../../../../ably';\r\nimport ICryptoStatic, { IGetCipherParams } from '../../../../common/types/ICryptoStatic';\r\nimport ICipher from '../../../../common/types/ICipher';\r\nimport { CryptoDataTypes } from '../../../../common/types/cryptoDataTypes';\r\nimport BufferUtils, { Bufferlike, Output as BufferUtilsOutput } from './bufferutils';\r\nimport { IPlatformConfig } from 'common/types/IPlatformConfig';\r\n\r\n// The type to which ./msgpack.ts deserializes elements of the `bin` or `ext` type\r\ntype MessagePackBinaryType = ArrayBuffer;\r\n\r\ntype IV = CryptoDataTypes.IV<BufferUtilsOutput>;\r\ntype InputPlaintext = CryptoDataTypes.InputPlaintext<Bufferlike, BufferUtilsOutput>;\r\ntype OutputCiphertext = ArrayBuffer;\r\ntype InputCiphertext = CryptoDataTypes.InputCiphertext<MessagePackBinaryType, BufferUtilsOutput>;\r\ntype OutputPlaintext = ArrayBuffer;\r\n\r\nvar createCryptoClass = function (config: IPlatformConfig, bufferUtils: typeof BufferUtils) {\r\n  var DEFAULT_ALGORITHM = 'aes';\r\n  var DEFAULT_KEYLENGTH = 256; // bits\r\n  var DEFAULT_MODE = 'cbc';\r\n  var DEFAULT_BLOCKLENGTH = 16; // bytes\r\n\r\n  /**\r\n   * Internal: checks that the cipherParams are a valid combination. Currently\r\n   * just checks that the calculated keyLength is a valid one for aes-cbc\r\n   */\r\n  function validateCipherParams(params: API.CipherParams) {\r\n    if (params.algorithm === 'aes' && params.mode === 'cbc') {\r\n      if (params.keyLength === 128 || params.keyLength === 256) {\r\n        return;\r\n      }\r\n      throw new Error(\r\n        'Unsupported key length ' +\r\n          params.keyLength +\r\n          ' for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)',\r\n      );\r\n    }\r\n  }\r\n\r\n  function normaliseBase64(string: string) {\r\n    /* url-safe base64 strings use _ and - instread of / and + */\r\n    return string.replace('_', '/').replace('-', '+');\r\n  }\r\n\r\n  function isCipherParams(params: API.CipherParams | API.CipherParamOptions): params is API.CipherParams {\r\n    // Although API.CipherParams is an interface, the documentation for its `key` property makes it clear that the only valid way to form one is by using getDefaultParams. The implementation of getDefaultParams returns an instance of CipherParams.\r\n    return params instanceof CipherParams;\r\n  }\r\n\r\n  /**\r\n   * A class encapsulating the client-specifiable parameters for\r\n   * the cipher.\r\n   *\r\n   * algorithm is the name of the algorithm in the default system provider,\r\n   * or the lower-cased version of it; eg \"aes\" or \"AES\".\r\n   *\r\n   * Clients are recommended to not call this directly, but instead to use the\r\n   * Crypto.getDefaultParams helper, which will fill in any fields not supplied\r\n   * with default values and validation the result.\r\n   */\r\n  class CipherParams implements API.CipherParams {\r\n    algorithm: string;\r\n    keyLength: number;\r\n    mode: string;\r\n    key: ArrayBuffer;\r\n\r\n    constructor(algorithm: string, keyLength: number, mode: string, key: ArrayBuffer) {\r\n      this.algorithm = algorithm;\r\n      this.keyLength = keyLength;\r\n      this.mode = mode;\r\n      this.key = key;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Utility classes and interfaces for message payload encryption.\r\n   *\r\n   * This class supports AES/CBC/PKCS5 with a default keylength of 128 bits\r\n   * but supporting other keylengths. Other algorithms and chaining modes are\r\n   * not supported directly, but supportable by extending/implementing the base\r\n   * classes and interfaces here.\r\n   *\r\n   * Secure random data for creation of Initialization Vectors (IVs) and keys\r\n   * is obtained from window.crypto.getRandomValues.\r\n   *\r\n   * Each message payload is encrypted with an IV in CBC mode, and the IV is\r\n   * concatenated with the resulting raw ciphertext to construct the \"ciphertext\"\r\n   * data passed to the recipient.\r\n   */\r\n  class Crypto {\r\n    static CipherParams = CipherParams;\r\n\r\n    /**\r\n     * Obtain a complete CipherParams instance from the provided params, filling\r\n     * in any not provided with default values, calculating a keyLength from\r\n     * the supplied key, and validating the result.\r\n     * @param params an object containing at a minimum a `key` key with value the\r\n     * key, as either a binary or a base64-encoded string.\r\n     * May optionally also contain: algorithm (defaults to AES),\r\n     * mode (defaults to 'cbc')\r\n     */\r\n    static getDefaultParams(params: API.CipherParamOptions) {\r\n      var key: ArrayBuffer;\r\n\r\n      if (!params.key) {\r\n        throw new Error('Crypto.getDefaultParams: a key is required');\r\n      }\r\n\r\n      if (typeof params.key === 'string') {\r\n        key = bufferUtils.toArrayBuffer(bufferUtils.base64Decode(normaliseBase64(params.key)));\r\n      } else if (params.key instanceof ArrayBuffer) {\r\n        key = params.key;\r\n      } else {\r\n        key = bufferUtils.toArrayBuffer(params.key);\r\n      }\r\n\r\n      var algorithm = params.algorithm || DEFAULT_ALGORITHM;\r\n      var keyLength = key.byteLength * 8;\r\n      var mode = params.mode || DEFAULT_MODE;\r\n      var cipherParams = new CipherParams(algorithm, keyLength, mode, key);\r\n\r\n      if (params.keyLength && params.keyLength !== cipherParams.keyLength) {\r\n        throw new Error(\r\n          'Crypto.getDefaultParams: a keyLength of ' +\r\n            params.keyLength +\r\n            ' was specified, but the key actually has length ' +\r\n            cipherParams.keyLength,\r\n        );\r\n      }\r\n\r\n      validateCipherParams(cipherParams);\r\n      return cipherParams;\r\n    }\r\n\r\n    /**\r\n     * Generate a random encryption key from the supplied keylength (or the\r\n     * default keyLength if none supplied) as an ArrayBuffer\r\n     * @param keyLength (optional) the required keyLength in bits\r\n     */\r\n    static async generateRandomKey(keyLength?: number): Promise<API.CipherKey> {\r\n      try {\r\n        return config.getRandomArrayBuffer((keyLength || DEFAULT_KEYLENGTH) / 8);\r\n      } catch (err) {\r\n        throw new ErrorInfo('Failed to generate random key: ' + (err as Error).message, 400, 50000, err as Error);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Internal; get a ChannelCipher instance based on the given cipherParams\r\n     * @param params either a CipherParams instance or some subset of its\r\n     * fields that includes a key\r\n     */\r\n    static getCipher(params: IGetCipherParams<IV>) {\r\n      var cipherParams = isCipherParams(params) ? (params as CipherParams) : this.getDefaultParams(params);\r\n\r\n      return {\r\n        cipherParams: cipherParams,\r\n        cipher: new CBCCipher(cipherParams, params.iv ?? null),\r\n      };\r\n    }\r\n  }\r\n\r\n  Crypto satisfies ICryptoStatic<IV, InputPlaintext, OutputCiphertext, InputCiphertext, OutputPlaintext>;\r\n\r\n  class CBCCipher implements ICipher<InputPlaintext, OutputCiphertext, InputCiphertext, OutputPlaintext> {\r\n    algorithm: string;\r\n    webCryptoAlgorithm: string;\r\n    key: ArrayBuffer;\r\n    iv: ArrayBuffer | null;\r\n\r\n    constructor(params: CipherParams, iv: IV | null) {\r\n      if (!crypto.subtle) {\r\n        if (isSecureContext) {\r\n          throw new Error(\r\n            'Crypto operations are not possible since the browser\u2019s SubtleCrypto class is unavailable (reason unknown).',\r\n          );\r\n        } else {\r\n          throw new Error(\r\n            'Crypto operations are is not possible since the current environment is a non-secure context and hence the browser\u2019s SubtleCrypto class is not available.',\r\n          );\r\n        }\r\n      }\r\n\r\n      this.algorithm = params.algorithm + '-' + String(params.keyLength) + '-' + params.mode;\r\n      this.webCryptoAlgorithm = params.algorithm + '-' + params.mode;\r\n      this.key = bufferUtils.toArrayBuffer(params.key);\r\n      this.iv = iv ? bufferUtils.toArrayBuffer(iv) : null;\r\n    }\r\n\r\n    private concat(buffer1: Bufferlike, buffer2: Bufferlike) {\r\n      const output = new ArrayBuffer(buffer1.byteLength + buffer2.byteLength);\r\n      const outputView = new DataView(output);\r\n\r\n      const buffer1View = new DataView(bufferUtils.toArrayBuffer(buffer1));\r\n      for (let i = 0; i < buffer1View.byteLength; i++) {\r\n        outputView.setInt8(i, buffer1View.getInt8(i));\r\n      }\r\n\r\n      const buffer2View = new DataView(bufferUtils.toArrayBuffer(buffer2));\r\n      for (let i = 0; i < buffer2View.byteLength; i++) {\r\n        outputView.setInt8(buffer1View.byteLength + i, buffer2View.getInt8(i));\r\n      }\r\n\r\n      return output;\r\n    }\r\n\r\n    async encrypt(plaintext: InputPlaintext): Promise<OutputCiphertext> {\r\n      Logger.logAction(Logger.LOG_MICRO, 'CBCCipher.encrypt()', '');\r\n\r\n      const iv = await this.getIv();\r\n      const cryptoKey = await crypto.subtle.importKey('raw', this.key, this.webCryptoAlgorithm, false, ['encrypt']);\r\n      const ciphertext = await crypto.subtle.encrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, plaintext);\r\n\r\n      return this.concat(iv, ciphertext);\r\n    }\r\n\r\n    async decrypt(ciphertext: InputCiphertext): Promise<OutputPlaintext> {\r\n      Logger.logAction(Logger.LOG_MICRO, 'CBCCipher.decrypt()', '');\r\n\r\n      const ciphertextArrayBuffer = bufferUtils.toArrayBuffer(ciphertext);\r\n      const iv = ciphertextArrayBuffer.slice(0, DEFAULT_BLOCKLENGTH);\r\n      const ciphertextBody = ciphertextArrayBuffer.slice(DEFAULT_BLOCKLENGTH);\r\n\r\n      const cryptoKey = await crypto.subtle.importKey('raw', this.key, this.webCryptoAlgorithm, false, ['decrypt']);\r\n      return crypto.subtle.decrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, ciphertextBody);\r\n    }\r\n\r\n    async getIv(): Promise<ArrayBuffer> {\r\n      if (this.iv) {\r\n        var iv = this.iv;\r\n        this.iv = null;\r\n        return iv;\r\n      }\r\n\r\n      const randomBlock = await config.getRandomArrayBuffer(DEFAULT_BLOCKLENGTH);\r\n      return bufferUtils.toArrayBuffer(randomBlock);\r\n    }\r\n  }\r\n\r\n  return Crypto;\r\n};\r\n\r\nexport { createCryptoClass };\r\n", "enum XHRStates {\n  REQ_SEND = 0,\n  REQ_RECV = 1,\n  REQ_RECV_POLL = 2,\n  REQ_RECV_STREAM = 3,\n}\n\nexport default XHRStates;\n", "import Platform from 'common/platform';\nimport Defaults from 'common/lib/util/defaults';\nimport ErrorInfo, { PartialErrorInfo } from 'common/lib/types/errorinfo';\nimport { RequestBody, RequestResultError, RequestParams, RequestResult } from 'common/types/http';\nimport HttpMethods from 'common/constants/HttpMethods';\nimport BaseClient from 'common/lib/client/baseclient';\nimport XHRStates from 'common/constants/XHRStates';\nimport Logger from 'common/lib/util/logger';\nimport { StandardCallback } from 'common/types/utils';\nimport { isSuccessCode } from 'common/constants/HttpStatusCodes';\nimport { ModularPlugins } from 'common/lib/client/modularplugins';\n\nexport type HTTPRequestImplementations = Pick<ModularPlugins, 'XHRRequest' | 'FetchRequest'>;\n\nfunction createMissingImplementationError() {\n  return new ErrorInfo(\n    'No HTTP request plugin provided. Provide at least one of the FetchRequest or XHRRequest plugins.',\n    400,\n    40000,\n  );\n}\n\nconst Http = class {\n  static methods = [HttpMethods.Get, HttpMethods.Delete, HttpMethods.Post, HttpMethods.Put, HttpMethods.Patch];\n  static methodsWithoutBody = [HttpMethods.Get, HttpMethods.Delete];\n  static methodsWithBody = [HttpMethods.Post, HttpMethods.Put, HttpMethods.Patch];\n  // HTTP request implementations that are available even without a BaseClient object (needed by some tests which directly instantiate `Http` without a client)\n  static bundledRequestImplementations: HTTPRequestImplementations;\n  checksInProgress: Array<StandardCallback<boolean>> | null = null;\n  private client: BaseClient | null;\n\n  constructor(client?: BaseClient) {\n    this.client = client ?? null;\n    const connectivityCheckUrl = client?.options.connectivityCheckUrl || Defaults.connectivityCheckUrl;\n    const connectivityCheckParams = client?.options.connectivityCheckParams ?? null;\n    const connectivityUrlIsDefault = !client?.options.connectivityCheckUrl;\n\n    const requestImplementations = {\n      ...Http.bundledRequestImplementations,\n      ...client?._additionalHTTPRequestImplementations,\n    };\n    const xhrRequestImplementation = requestImplementations.XHRRequest;\n    const fetchRequestImplementation = requestImplementations.FetchRequest;\n    const hasImplementation = !!(xhrRequestImplementation || fetchRequestImplementation);\n\n    if (!hasImplementation) {\n      throw createMissingImplementationError();\n    }\n\n    if (Platform.Config.xhrSupported && xhrRequestImplementation) {\n      this.supportsAuthHeaders = true;\n      this.Request = async function (\n        method: HttpMethods,\n        uri: string,\n        headers: Record<string, string> | null,\n        params: RequestParams,\n        body: RequestBody | null,\n      ) {\n        return new Promise((resolve) => {\n          const req = xhrRequestImplementation.createRequest(\n            uri,\n            headers,\n            params,\n            body,\n            XHRStates.REQ_SEND,\n            (client && client.options.timeouts) ?? null,\n            method,\n          );\n          req.once(\n            'complete',\n            (\n              error: RequestResult['error'],\n              body: RequestResult['body'],\n              headers: RequestResult['headers'],\n              unpacked: RequestResult['unpacked'],\n              statusCode: RequestResult['statusCode'],\n            ) => resolve({ error, body, headers, unpacked, statusCode }),\n          );\n          req.exec();\n        });\n      };\n      if (client?.options.disableConnectivityCheck) {\n        this.checkConnectivity = async function () {\n          return true;\n        };\n      } else {\n        this.checkConnectivity = async function () {\n          Logger.logAction(\n            Logger.LOG_MICRO,\n            '(XHRRequest)Http.checkConnectivity()',\n            'Sending; ' + connectivityCheckUrl,\n          );\n\n          const requestResult = await this.doUri(\n            HttpMethods.Get,\n            connectivityCheckUrl,\n            null,\n            null,\n            connectivityCheckParams,\n          );\n\n          let result = false;\n          if (!connectivityUrlIsDefault) {\n            result = !requestResult.error && isSuccessCode(requestResult.statusCode as number);\n          } else {\n            result = !requestResult.error && (requestResult.body as string)?.replace(/\\n/, '') == 'yes';\n          }\n\n          Logger.logAction(Logger.LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Result: ' + result);\n          return result;\n        };\n      }\n    } else if (Platform.Config.fetchSupported && fetchRequestImplementation) {\n      this.supportsAuthHeaders = true;\n      this.Request = async (method, uri, headers, params, body) => {\n        return fetchRequestImplementation(method, client ?? null, uri, headers, params, body);\n      };\n      this.checkConnectivity = async function () {\n        Logger.logAction(Logger.LOG_MICRO, '(Fetch)Http.checkConnectivity()', 'Sending; ' + connectivityCheckUrl);\n        const requestResult = await this.doUri(HttpMethods.Get, connectivityCheckUrl, null, null, null);\n        const result = !requestResult.error && (requestResult.body as string)?.replace(/\\n/, '') == 'yes';\n        Logger.logAction(Logger.LOG_MICRO, '(Fetch)Http.checkConnectivity()', 'Result: ' + result);\n        return result;\n      };\n    } else {\n      this.Request = async () => {\n        const error = hasImplementation\n          ? new PartialErrorInfo('no supported HTTP transports available', null, 400)\n          : createMissingImplementationError();\n        return { error };\n      };\n    }\n  }\n\n  async doUri(\n    method: HttpMethods,\n    uri: string,\n    headers: Record<string, string> | null,\n    body: RequestBody | null,\n    params: RequestParams,\n  ): Promise<RequestResult> {\n    if (!this.Request) {\n      return { error: new PartialErrorInfo('Request invoked before assigned to', null, 500) };\n    }\n    return this.Request(method, uri, headers, params, body);\n  }\n\n  private Request?: (\n    method: HttpMethods,\n    uri: string,\n    headers: Record<string, string> | null,\n    params: RequestParams,\n    body: RequestBody | null,\n  ) => Promise<RequestResult>;\n\n  checkConnectivity?: () => Promise<boolean> = undefined;\n\n  supportsAuthHeaders = false;\n  supportsLinkHeaders = false;\n\n  shouldFallback(errorInfo: RequestResultError) {\n    const statusCode = errorInfo.statusCode as number;\n    /* 400 + no code = a generic xhr onerror. Browser doesn't give us enough\n     * detail to know whether it's fallback-fixable, but it may be (eg if a\n     * network issue), so try just in case */\n    return (\n      (statusCode === 408 && !errorInfo.code) ||\n      (statusCode === 400 && !errorInfo.code) ||\n      (statusCode >= 500 && statusCode <= 504)\n    );\n  }\n};\n\nexport default Http;\n", "import { IPlatformConfig } from '../../common/types/IPlatformConfig';\r\nimport * as Utils from 'common/lib/util/utils';\r\n\r\n// Workaround for salesforce lightning locker compat\r\nconst globalObject = Utils.getGlobalObject();\r\n\r\n// @ts-ignore\r\nconst isVercelEdgeRuntime = typeof EdgeRuntime === 'string';\r\n\r\n// We get false positive result here in the Vercel Edge runtime because it lacks the usual global browser objects, such as Window.\r\n// However, it is closer to the browser environment, so it intentionally uses browser bundles when importing packages.\r\n// Therefore, we do an additional check to avoid logging this incorrect warning for Vercel Edge runtime.\r\nif (typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined' && !isVercelEdgeRuntime) {\r\n  console.log(\r\n    \"Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm\",\r\n  );\r\n}\r\n\r\nfunction allowComet() {\r\n  /* xhr requests from local files are unreliable in some browsers, such as Chrome 65 and higher -- see eg\r\n   * https://stackoverflow.com/questions/49256429/chrome-65-unable-to-make-post-requests-from-local-files-to-flask\r\n   * So if websockets are supported, then just forget about comet transports and use that */\r\n  const loc = globalObject.location;\r\n  return !globalObject.WebSocket || !loc || !loc.origin || loc.origin.indexOf('http') > -1;\r\n}\r\n\r\n// from: https://stackoverflow.com/a/18002694\r\nexport function isWebWorkerContext(): boolean {\r\n  // run this in global scope of window or worker. since window.self = window, we're ok\r\n  if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nconst userAgent = globalObject.navigator && globalObject.navigator.userAgent.toString();\r\nconst currentUrl = globalObject.location && globalObject.location.href;\r\n\r\nconst Config: IPlatformConfig = {\r\n  agent: 'browser',\r\n  logTimestamps: true,\r\n  userAgent: userAgent,\r\n  currentUrl: currentUrl,\r\n  binaryType: 'arraybuffer',\r\n  WebSocket: globalObject.WebSocket,\r\n  fetchSupported: !!globalObject.fetch,\r\n  xhrSupported: globalObject.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest(),\r\n  allowComet: allowComet(),\r\n  useProtocolHeartbeats: true,\r\n  supportsBinary: !!globalObject.TextDecoder,\r\n  /* Per Paddy (https://ably-real-time.slack.com/archives/CURL4U2FP/p1705674537763479) web intentionally prefers JSON to MessagePack:\r\n   *\r\n   * > browsers' support for binary types in general was historically poor, and JSON transport performance is significantly better in a browser than msgpack. In modern browsers then binary is supported consistently, but I'd still expect that JSON encode/decode performance is dramatically better than msgpack in a browser.\r\n   */\r\n  preferBinary: false,\r\n  ArrayBuffer: globalObject.ArrayBuffer,\r\n  atob: globalObject.atob,\r\n  nextTick:\r\n    typeof globalObject.setImmediate !== 'undefined'\r\n      ? globalObject.setImmediate.bind(globalObject)\r\n      : function (f: () => void) {\r\n          setTimeout(f, 0);\r\n        },\r\n  addEventListener: globalObject.addEventListener,\r\n  inspect: JSON.stringify,\r\n  stringByteSize: function (str: string) {\r\n    /* str.length will be an underestimate for non-ascii strings. But if we're\r\n     * in a browser too old to support TextDecoder, not much we can do. Better\r\n     * to underestimate, so if we do go over-size, the server will reject the\r\n     * message */\r\n    return (globalObject.TextDecoder && new globalObject.TextEncoder().encode(str).length) || str.length;\r\n  },\r\n  TextEncoder: globalObject.TextEncoder,\r\n  TextDecoder: globalObject.TextDecoder,\r\n  getRandomArrayBuffer: async function (byteLength: number): Promise<ArrayBuffer> {\r\n    const byteArray = new Uint8Array(byteLength);\r\n    globalObject.crypto.getRandomValues(byteArray);\r\n    return byteArray.buffer;\r\n  },\r\n  isWebworker: isWebWorkerContext(),\r\n};\r\n\r\nexport default Config;\r\n", "import * as Utils from '../util/utils';\r\nimport ProtocolMessage, {\r\n  actions,\r\n  fromValues as protocolMessageFromValues,\r\n  fromDeserialized as protocolMessageFromDeserialized,\r\n} from '../types/protocolmessage';\r\nimport Transport from './transport';\r\nimport Logger from '../util/logger';\r\nimport Defaults from '../util/defaults';\r\nimport ConnectionErrors from './connectionerrors';\r\nimport Auth from '../client/auth';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport IXHRRequest from '../../types/IXHRRequest';\r\nimport * as API from '../../../../ably';\r\nimport ConnectionManager, { TransportParams } from './connectionmanager';\r\nimport XHRStates from '../../constants/XHRStates';\r\nimport Platform from 'common/platform';\r\n\r\n/* TODO: can remove once realtime sends protocol message responses for comet errors */\r\nfunction shouldBeErrorAction(err: ErrorInfo) {\r\n  const UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];\r\n  if (err.code) {\r\n    if (Auth.isTokenErr(err)) return false;\r\n    if (UNRESOLVABLE_ERROR_CODES.includes(err.code)) return true;\r\n    return err.code >= 40000 && err.code < 50000;\r\n  } else {\r\n    /* Likely a network or transport error of some kind. Certainly not fatal to the connection */\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction protocolMessageFromRawError(err: ErrorInfo) {\r\n  /* err will be either a legacy (non-protocolmessage) comet error response\r\n   * (which will have an err.code), or a xhr/network error (which won't). */\r\n  if (shouldBeErrorAction(err)) {\r\n    return [protocolMessageFromValues({ action: actions.ERROR, error: err })];\r\n  } else {\r\n    return [protocolMessageFromValues({ action: actions.DISCONNECTED, error: err })];\r\n  }\r\n}\r\n\r\n/*\r\n * A base comet transport class\r\n */\r\nabstract class CometTransport extends Transport {\r\n  stream: string | boolean;\r\n  sendRequest: IXHRRequest | null;\r\n  recvRequest: null | IXHRRequest;\r\n  pendingCallback: null;\r\n  pendingItems: null | Array<ProtocolMessage>;\r\n  baseUri?: string;\r\n  authParams?: Record<string, any>;\r\n  closeUri?: string;\r\n  disconnectUri?: string;\r\n  sendUri?: string;\r\n  recvUri?: string;\r\n\r\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams) {\r\n    super(connectionManager, auth, params, /* binary not supported for comet so force JSON protocol */ true);\r\n    this.stream = 'stream' in params ? params.stream : true;\r\n    this.sendRequest = null;\r\n    this.recvRequest = null;\r\n    this.pendingCallback = null;\r\n    this.pendingItems = null;\r\n  }\r\n\r\n  abstract createRequest(\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    params?: Record<string, unknown> | null,\r\n    body?: unknown,\r\n    requestMode?: number,\r\n  ): IXHRRequest;\r\n\r\n  connect(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'CometTransport.connect()', 'starting');\r\n    Transport.prototype.connect.call(this);\r\n    const params = this.params;\r\n    const options = params.options;\r\n    const host = Defaults.getHost(options, params.host);\r\n    const port = Defaults.getPort(options);\r\n    const cometScheme = options.tls ? 'https://' : 'http://';\r\n\r\n    this.baseUri = cometScheme + host + ':' + port + '/comet/';\r\n    const connectUri = this.baseUri + 'connect';\r\n    Logger.logAction(Logger.LOG_MINOR, 'CometTransport.connect()', 'uri: ' + connectUri);\r\n    Utils.whenPromiseSettles(this.auth.getAuthParams(), (err: Error | null, authParams?: Record<string, any>) => {\r\n      if (err) {\r\n        this.disconnect(err);\r\n        return;\r\n      }\r\n      if (this.isDisposed) {\r\n        return;\r\n      }\r\n      this.authParams = authParams;\r\n      const connectParams = this.params.getConnectParams(authParams!);\r\n      if ('stream' in connectParams) this.stream = connectParams.stream;\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'CometTransport.connect()',\r\n        'connectParams:' + Utils.toQueryString(connectParams),\r\n      );\r\n\r\n      /* this will be the 'recvRequest' so this connection can stream messages */\r\n      let preconnected = false;\r\n      const connectRequest = (this.recvRequest = this.createRequest(\r\n        connectUri,\r\n        null,\r\n        connectParams,\r\n        null,\r\n        this.stream ? XHRStates.REQ_RECV_STREAM : XHRStates.REQ_RECV,\r\n      ));\r\n\r\n      connectRequest.on('data', (data: any) => {\r\n        if (!this.recvRequest) {\r\n          /* the transport was disposed before we connected */\r\n          return;\r\n        }\r\n        if (!preconnected) {\r\n          preconnected = true;\r\n          this.emit('preconnect');\r\n        }\r\n        this.onData(data);\r\n      });\r\n      connectRequest.on('complete', (err: ErrorInfo) => {\r\n        if (!this.recvRequest) {\r\n          /* the transport was disposed before we connected */\r\n          err = err || new ErrorInfo('Request cancelled', 80003, 400);\r\n        }\r\n        this.recvRequest = null;\r\n        /* Connect request may complete without a emitting 'data' event since that is not\r\n         * emitted for e.g. a non-streamed error response. Still implies preconnect. */\r\n        if (!preconnected && !err) {\r\n          preconnected = true;\r\n          this.emit('preconnect');\r\n        }\r\n        this.onActivity();\r\n        if (err) {\r\n          if (err.code) {\r\n            /* A protocol error received from realtime. TODO: once realtime\r\n             * consistendly sends errors wrapped in protocol messages, should be\r\n             * able to remove this */\r\n            this.onData(protocolMessageFromRawError(err));\r\n          } else {\r\n            /* A network/xhr error. Don't bother wrapping in a protocol message,\r\n             * just disconnect the transport */\r\n            this.disconnect(err);\r\n          }\r\n          return;\r\n        }\r\n        Platform.Config.nextTick(() => {\r\n          this.recv();\r\n        });\r\n      });\r\n      connectRequest.exec();\r\n    });\r\n  }\r\n\r\n  requestClose(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'CometTransport.requestClose()');\r\n    this._requestCloseOrDisconnect(true);\r\n  }\r\n\r\n  requestDisconnect(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'CometTransport.requestDisconnect()');\r\n    this._requestCloseOrDisconnect(false);\r\n  }\r\n\r\n  _requestCloseOrDisconnect(closing: boolean): void {\r\n    const closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;\r\n    if (closeOrDisconnectUri) {\r\n      const request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, XHRStates.REQ_SEND);\r\n\r\n      request.on('complete', (err: ErrorInfo) => {\r\n        if (err) {\r\n          Logger.logAction(\r\n            Logger.LOG_ERROR,\r\n            'CometTransport.request' + (closing ? 'Close()' : 'Disconnect()'),\r\n            'request returned err = ' + Utils.inspectError(err),\r\n          );\r\n          this.finish('disconnected', err);\r\n        }\r\n      });\r\n      request.exec();\r\n    }\r\n  }\r\n\r\n  dispose(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'CometTransport.dispose()', '');\r\n    if (!this.isDisposed) {\r\n      this.isDisposed = true;\r\n      if (this.recvRequest) {\r\n        Logger.logAction(Logger.LOG_MINOR, 'CometTransport.dispose()', 'aborting recv request');\r\n        this.recvRequest.abort();\r\n        this.recvRequest = null;\r\n      }\r\n      /* In almost all cases the transport will be finished before it's\r\n       * disposed. Finish here just to make sure. */\r\n      this.finish('disconnected', ConnectionErrors.disconnected());\r\n      Platform.Config.nextTick(() => {\r\n        this.emit('disposed');\r\n      });\r\n    }\r\n  }\r\n\r\n  onConnect(message: ProtocolMessage): void {\r\n    /* if this transport has been disposed whilst awaiting connection, do nothing */\r\n    if (this.isDisposed) {\r\n      return;\r\n    }\r\n\r\n    /* the connectionKey in a comet connected response is really\r\n     * <instId>-<connectionKey> */\r\n    const connectionStr = message.connectionDetails?.connectionKey;\r\n    Transport.prototype.onConnect.call(this, message);\r\n\r\n    const baseConnectionUri = (this.baseUri as string) + connectionStr;\r\n    Logger.logAction(Logger.LOG_MICRO, 'CometTransport.onConnect()', 'baseUri = ' + baseConnectionUri);\r\n    this.sendUri = baseConnectionUri + '/send';\r\n    this.recvUri = baseConnectionUri + '/recv';\r\n    this.closeUri = baseConnectionUri + '/close';\r\n    this.disconnectUri = baseConnectionUri + '/disconnect';\r\n  }\r\n\r\n  send(message: ProtocolMessage): void {\r\n    if (this.sendRequest) {\r\n      /* there is a pending send, so queue this message */\r\n      this.pendingItems = this.pendingItems || [];\r\n      this.pendingItems.push(message);\r\n      return;\r\n    }\r\n    /* send this, plus any pending, now */\r\n    const pendingItems = this.pendingItems || [];\r\n    pendingItems.push(message);\r\n    this.pendingItems = null;\r\n\r\n    this.sendItems(pendingItems);\r\n  }\r\n\r\n  sendAnyPending(): void {\r\n    const pendingItems = this.pendingItems;\r\n\r\n    if (!pendingItems) {\r\n      return;\r\n    }\r\n\r\n    this.pendingItems = null;\r\n    this.sendItems(pendingItems);\r\n  }\r\n\r\n  sendItems(items: Array<ProtocolMessage>): void {\r\n    const sendRequest = (this.sendRequest = this.createRequest(\r\n      this.sendUri as string,\r\n      null,\r\n      this.authParams,\r\n      this.encodeRequest(items),\r\n      XHRStates.REQ_SEND,\r\n    ));\r\n\r\n    sendRequest.on('complete', (err: ErrorInfo, data: string) => {\r\n      if (err)\r\n        Logger.logAction(\r\n          Logger.LOG_ERROR,\r\n          'CometTransport.sendItems()',\r\n          'on complete: err = ' + Utils.inspectError(err),\r\n        );\r\n      this.sendRequest = null;\r\n\r\n      /* the result of the request, even if a nack, is usually a protocol response\r\n       * contained in the data. An err is anomolous, and indicates some issue with the\r\n       * network,transport, or connection */\r\n      if (err) {\r\n        if (err.code) {\r\n          /* A protocol error received from realtime. TODO: once realtime\r\n           * consistendly sends errors wrapped in protocol messages, should be\r\n           * able to remove this */\r\n          this.onData(protocolMessageFromRawError(err));\r\n        } else {\r\n          /* A network/xhr error. Don't bother wrapping in a protocol message,\r\n           * just disconnect the transport */\r\n          this.disconnect(err);\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (data) {\r\n        this.onData(data);\r\n      }\r\n\r\n      if (this.pendingItems) {\r\n        Platform.Config.nextTick(() => {\r\n          /* If there's a new send request by now, any pending items will have\r\n           * been picked up by that; any new ones added since then will be\r\n           * picked up after that one completes */\r\n          if (!this.sendRequest) {\r\n            this.sendAnyPending();\r\n          }\r\n        });\r\n      }\r\n    });\r\n    sendRequest.exec();\r\n  }\r\n\r\n  recv(): void {\r\n    /* do nothing if there is an active request, which might be streaming */\r\n    if (this.recvRequest) return;\r\n\r\n    /* If we're no longer connected, do nothing */\r\n    if (!this.isConnected) return;\r\n\r\n    const recvRequest = (this.recvRequest = this.createRequest(\r\n      this.recvUri as string,\r\n      null,\r\n      this.authParams,\r\n      null,\r\n      this.stream ? XHRStates.REQ_RECV_STREAM : XHRStates.REQ_RECV_POLL,\r\n    ));\r\n\r\n    recvRequest.on('data', (data: string) => {\r\n      this.onData(data);\r\n    });\r\n    recvRequest.on('complete', (err: ErrorInfo) => {\r\n      this.recvRequest = null;\r\n      /* A request completing must be considered activity, as realtime sends\r\n       * heartbeats every 15s since a request began, not every 15s absolutely */\r\n      this.onActivity();\r\n      if (err) {\r\n        if (err.code) {\r\n          /* A protocol error received from realtime. TODO: once realtime\r\n           * consistently sends errors wrapped in protocol messages, should be\r\n           * able to remove this */\r\n          this.onData(protocolMessageFromRawError(err));\r\n        } else {\r\n          /* A network/xhr error. Don't bother wrapping in a protocol message,\r\n           * just disconnect the transport */\r\n          this.disconnect(err);\r\n        }\r\n        return;\r\n      }\r\n      Platform.Config.nextTick(() => {\r\n        this.recv();\r\n      });\r\n    });\r\n    recvRequest.exec();\r\n  }\r\n\r\n  onData(responseData: string | Record<string, any>): void {\r\n    try {\r\n      const items = this.decodeResponse(responseData);\r\n      if (items && items.length)\r\n        for (let i = 0; i < items.length; i++)\r\n          this.onProtocolMessage(\r\n            protocolMessageFromDeserialized(items[i], this.connectionManager.realtime._RealtimePresence),\r\n          );\r\n    } catch (e) {\r\n      Logger.logAction(\r\n        Logger.LOG_ERROR,\r\n        'CometTransport.onData()',\r\n        'Unexpected exception handing channel event: ' + (e as Error).stack,\r\n      );\r\n    }\r\n  }\r\n\r\n  encodeRequest(requestItems: Array<ProtocolMessage>): string {\r\n    return JSON.stringify(requestItems);\r\n  }\r\n\r\n  decodeResponse(responseData: string | Record<string, any>): Record<string, any> {\r\n    if (typeof responseData == 'string') return JSON.parse(responseData);\r\n    return responseData;\r\n  }\r\n\r\n  /* Historical comment, back from when we supported JSONP:\r\n   *\r\n   * > For comet, we could do the auth update by aborting the current recv and\r\n   * > starting a new one with the new token, that'd be sufficient for realtime.\r\n   * > Problem is JSONP - you can't cancel truly abort a recv once started. So\r\n   * > we need to send an AUTH for jsonp. In which case it's simpler to keep all\r\n   * > comet transports the same and do it for all of them. So we send the AUTH\r\n   * > instead, and don't need to abort the recv\r\n   *\r\n   * Now that we\u2019ve dropped JSONP support, we may be able to revisit the above;\r\n   * see https://github.com/ably/ably-js/issues/1214.\r\n   */\r\n  onAuthUpdated = (tokenDetails: API.TokenDetails): void => {\r\n    this.authParams = { access_token: tokenDetails.token };\r\n  };\r\n}\r\n\r\nexport default CometTransport;\r\n", "import * as Utils from 'common/lib/util/utils';\r\nimport EventEmitter from 'common/lib/util/eventemitter';\r\nimport ErrorInfo, { IPartialErrorInfo, PartialErrorInfo } from 'common/lib/types/errorinfo';\r\nimport Logger from 'common/lib/util/logger';\r\nimport Defaults from 'common/lib/util/defaults';\r\nimport HttpMethods from 'common/constants/HttpMethods';\r\nimport IXHRRequest from 'common/types/IXHRRequest';\r\nimport { RequestBody, RequestParams } from 'common/types/http';\r\nimport XHRStates from 'common/constants/XHRStates';\r\nimport Platform from 'common/platform';\r\n\r\nfunction isAblyError(responseBody: unknown, headers: Record<string, string>): responseBody is { error?: ErrorInfo } {\r\n  return Utils.allToLowerCase(Utils.keysArray(headers)).includes('x-ably-errorcode');\r\n}\r\n\r\nfunction getAblyError(responseBody: unknown, headers: Record<string, string>) {\r\n  if (isAblyError(responseBody, headers)) {\r\n    return responseBody.error && ErrorInfo.fromValues(responseBody.error);\r\n  }\r\n}\r\n\r\nconst noop = function () {};\r\nlet idCounter = 0;\r\nconst pendingRequests: Record<string, XHRRequest> = {};\r\n\r\nfunction getHeader(xhr: XMLHttpRequest, header: string) {\r\n  return xhr.getResponseHeader && xhr.getResponseHeader(header);\r\n}\r\n\r\n/* Safari mysteriously returns 'Identity' for transfer-encoding when in fact\r\n * it is 'chunked'. So instead, decide that it is chunked when\r\n * transfer-encoding is present or content-length is absent.  ('or' because\r\n * when using http2 streaming, there's no transfer-encoding header, but can\r\n * still deduce streaming from lack of content-length) */\r\nfunction isEncodingChunked(xhr: XMLHttpRequest) {\r\n  return (\r\n    xhr.getResponseHeader && (xhr.getResponseHeader('transfer-encoding') || !xhr.getResponseHeader('content-length'))\r\n  );\r\n}\r\n\r\nfunction getHeadersAsObject(xhr: XMLHttpRequest) {\r\n  const headerPairs = xhr.getAllResponseHeaders().trim().split('\\r\\n');\r\n  const headers: Record<string, string> = {};\r\n  for (let i = 0; i < headerPairs.length; i++) {\r\n    const parts = headerPairs[i].split(':').map((x) => x.trim());\r\n    headers[parts[0].toLowerCase()] = parts[1];\r\n  }\r\n  return headers;\r\n}\r\n\r\nclass XHRRequest extends EventEmitter implements IXHRRequest {\r\n  uri: string;\r\n  headers: Record<string, string>;\r\n  body: RequestBody | null;\r\n  method: string;\r\n  requestMode: number;\r\n  timeouts: Record<string, number>;\r\n  timedOut: boolean;\r\n  requestComplete: boolean;\r\n  id: string;\r\n  streamComplete?: boolean;\r\n  xhr?: XMLHttpRequest | null;\r\n  timer?: NodeJS.Timeout | number | null;\r\n\r\n  constructor(\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    params: Record<string, string>,\r\n    body: RequestBody | null,\r\n    requestMode: number,\r\n    timeouts: Record<string, number>,\r\n    method?: HttpMethods,\r\n  ) {\r\n    super();\r\n    params = params || {};\r\n    params.rnd = Utils.cheapRandStr();\r\n    this.uri = uri + Utils.toQueryString(params);\r\n    this.headers = headers || {};\r\n    this.body = body;\r\n    this.method = method ? method.toUpperCase() : Utils.isNil(body) ? 'GET' : 'POST';\r\n    this.requestMode = requestMode;\r\n    this.timeouts = timeouts;\r\n    this.timedOut = false;\r\n    this.requestComplete = false;\r\n    this.id = String(++idCounter);\r\n    pendingRequests[this.id] = this;\r\n  }\r\n\r\n  static createRequest(\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    params: RequestParams,\r\n    body: RequestBody | null,\r\n    requestMode: number,\r\n    timeouts: Record<string, number> | null,\r\n    method?: HttpMethods,\r\n  ): XHRRequest {\r\n    /* XHR requests are used either with the context being a realtime\r\n     * transport, or with timeouts passed in (for when used by a rest client),\r\n     * or completely standalone.  Use the appropriate timeouts in each case */\r\n    const _timeouts = timeouts || Defaults.TIMEOUTS;\r\n    return new XHRRequest(\r\n      uri,\r\n      headers,\r\n      Utils.copy(params) as Record<string, string>,\r\n      body,\r\n      requestMode,\r\n      _timeouts,\r\n      method,\r\n    );\r\n  }\r\n\r\n  complete(\r\n    err?: IPartialErrorInfo | null,\r\n    body?: unknown,\r\n    headers?: Record<string, string> | null,\r\n    unpacked?: boolean | null,\r\n    statusCode?: number,\r\n  ): void {\r\n    if (!this.requestComplete) {\r\n      this.requestComplete = true;\r\n      if (!err && body) {\r\n        this.emit('data', body);\r\n      }\r\n      this.emit('complete', err, body, headers, unpacked, statusCode);\r\n      this.dispose();\r\n    }\r\n  }\r\n\r\n  abort(): void {\r\n    this.dispose();\r\n  }\r\n\r\n  exec(): void {\r\n    let headers = this.headers;\r\n    const timeout =\r\n        this.requestMode == XHRStates.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout,\r\n      timer = (this.timer = setTimeout(() => {\r\n        this.timedOut = true;\r\n        xhr.abort();\r\n      }, timeout)),\r\n      method = this.method,\r\n      xhr = (this.xhr = new XMLHttpRequest()),\r\n      accept = headers['accept'];\r\n    let body = this.body;\r\n    let responseType: XMLHttpRequestResponseType = 'text';\r\n\r\n    if (!accept) {\r\n      // Default to JSON\r\n      headers['accept'] = 'application/json';\r\n    } else if (accept.indexOf('application/x-msgpack') === 0) {\r\n      // Msgpack responses will be typed as ArrayBuffer\r\n      responseType = 'arraybuffer';\r\n    }\r\n\r\n    if (body) {\r\n      const contentType = headers['content-type'] || (headers['content-type'] = 'application/json');\r\n      if (contentType.indexOf('application/json') > -1 && typeof body != 'string') body = JSON.stringify(body);\r\n    }\r\n\r\n    // Can probably remove this directive if https://github.com/nodesecurity/eslint-plugin-security/issues/26 is resolved\r\n    // eslint-disable-next-line security/detect-non-literal-fs-filename\r\n    xhr.open(method, this.uri, true);\r\n    xhr.responseType = responseType;\r\n\r\n    if ('authorization' in headers) {\r\n      xhr.withCredentials = true;\r\n    }\r\n\r\n    for (const h in headers) xhr.setRequestHeader(h, headers[h]);\r\n\r\n    const errorHandler = (\r\n      errorEvent: ProgressEvent<EventTarget>,\r\n      message: string,\r\n      code: number | null,\r\n      statusCode: number,\r\n    ) => {\r\n      let errorMessage = message + ' (event type: ' + errorEvent.type + ')';\r\n      if (this?.xhr?.statusText) errorMessage += ', current statusText is ' + this.xhr.statusText;\r\n      Logger.logAction(Logger.LOG_ERROR, 'Request.on' + errorEvent.type + '()', errorMessage);\r\n      this.complete(new PartialErrorInfo(errorMessage, code, statusCode));\r\n    };\r\n    xhr.onerror = function (errorEvent) {\r\n      errorHandler(errorEvent, 'XHR error occurred', null, 400);\r\n    };\r\n    xhr.onabort = (errorEvent) => {\r\n      if (this.timedOut) {\r\n        errorHandler(errorEvent, 'Request aborted due to request timeout expiring', null, 408);\r\n      } else {\r\n        errorHandler(errorEvent, 'Request cancelled', null, 400);\r\n      }\r\n    };\r\n    xhr.ontimeout = function (errorEvent) {\r\n      errorHandler(errorEvent, 'Request timed out', null, 408);\r\n    };\r\n\r\n    let streaming: boolean | string;\r\n    let statusCode: number;\r\n    let successResponse: boolean;\r\n    let streamPos = 0;\r\n    let unpacked = false;\r\n\r\n    const onResponse = () => {\r\n      clearTimeout(timer);\r\n      successResponse = statusCode < 400;\r\n      if (statusCode == 204) {\r\n        this.complete(null, null, null, null, statusCode);\r\n        return;\r\n      }\r\n      streaming = this.requestMode == XHRStates.REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr);\r\n    };\r\n\r\n    const onEnd = () => {\r\n      let parsedResponse: any;\r\n      try {\r\n        const contentType = getHeader(xhr, 'content-type');\r\n        /* Be liberal in what we accept; buggy auth servers may respond\r\n         * without the correct contenttype, but assume they're still\r\n         * responding with json */\r\n        const json = contentType ? contentType.indexOf('application/json') >= 0 : xhr.responseType == 'text';\r\n\r\n        if (json) {\r\n          /* If we requested msgpack but server responded with json, then since\r\n           * we set the responseType expecting msgpack, the response will be\r\n           * an ArrayBuffer containing json */\r\n          const jsonResponseBody =\r\n            xhr.responseType === 'arraybuffer'\r\n              ? Platform.BufferUtils.utf8Decode(xhr.response)\r\n              : String(xhr.responseText);\r\n          if (jsonResponseBody.length) {\r\n            parsedResponse = JSON.parse(jsonResponseBody);\r\n          } else {\r\n            parsedResponse = jsonResponseBody;\r\n          }\r\n          unpacked = true;\r\n        } else {\r\n          parsedResponse = xhr.response;\r\n        }\r\n\r\n        if (parsedResponse.response !== undefined) {\r\n          /* unwrap JSON envelope */\r\n          statusCode = parsedResponse.statusCode;\r\n          successResponse = statusCode < 400;\r\n          headers = parsedResponse.headers;\r\n          parsedResponse = parsedResponse.response;\r\n        } else {\r\n          headers = getHeadersAsObject(xhr);\r\n        }\r\n      } catch (e) {\r\n        this.complete(new PartialErrorInfo('Malformed response body from server: ' + (e as Error).message, null, 400));\r\n        return;\r\n      }\r\n\r\n      /* If response is an array, it's an array of protocol messages -- even if\r\n       * is contains an error action (hence the nonsuccess statuscode), we can\r\n       * consider the request to have succeeded, just pass it on to\r\n       * onProtocolMessage to decide what to do */\r\n      if (successResponse || Array.isArray(parsedResponse)) {\r\n        this.complete(null, parsedResponse, headers, unpacked, statusCode);\r\n        return;\r\n      }\r\n\r\n      let err: IPartialErrorInfo | undefined = getAblyError(parsedResponse, headers);\r\n      if (!err) {\r\n        err = new PartialErrorInfo(\r\n          'Error response received from server: ' +\r\n            statusCode +\r\n            ' body was: ' +\r\n            Platform.Config.inspect(parsedResponse),\r\n          null,\r\n          statusCode,\r\n        );\r\n      }\r\n      this.complete(err, parsedResponse, headers, unpacked, statusCode);\r\n    };\r\n\r\n    function onProgress() {\r\n      const responseText = xhr.responseText;\r\n      const bodyEnd = responseText.length - 1;\r\n      let idx, chunk;\r\n      while (streamPos < bodyEnd && (idx = responseText.indexOf('\\n', streamPos)) > -1) {\r\n        chunk = responseText.slice(streamPos, idx);\r\n        streamPos = idx + 1;\r\n        onChunk(chunk);\r\n      }\r\n    }\r\n\r\n    const onChunk = (chunk: string) => {\r\n      try {\r\n        chunk = JSON.parse(chunk);\r\n      } catch (e) {\r\n        this.complete(new PartialErrorInfo('Malformed response body from server: ' + (e as Error).message, null, 400));\r\n        return;\r\n      }\r\n      this.emit('data', chunk);\r\n    };\r\n\r\n    const onStreamEnd = () => {\r\n      onProgress();\r\n      this.streamComplete = true;\r\n      Platform.Config.nextTick(() => {\r\n        this.complete();\r\n      });\r\n    };\r\n\r\n    xhr.onreadystatechange = function () {\r\n      const readyState = xhr.readyState;\r\n      if (readyState < 3) return;\r\n      if (xhr.status !== 0) {\r\n        if (statusCode === undefined) {\r\n          statusCode = xhr.status;\r\n          onResponse();\r\n        }\r\n        if (readyState == 3 && streaming) {\r\n          onProgress();\r\n        } else if (readyState == 4) {\r\n          if (streaming) onStreamEnd();\r\n          else onEnd();\r\n        }\r\n      }\r\n    };\r\n    xhr.send(body as any);\r\n  }\r\n\r\n  dispose(): void {\r\n    const xhr = this.xhr;\r\n    if (xhr) {\r\n      xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop;\r\n      this.xhr = null;\r\n      const timer = this.timer;\r\n      if (timer) {\r\n        clearTimeout(timer as NodeJS.Timeout);\r\n        this.timer = null;\r\n      }\r\n      if (!this.requestComplete) xhr.abort();\r\n    }\r\n    delete pendingRequests[this.id];\r\n  }\r\n}\r\n\r\nexport default XHRRequest;\r\n", "import Platform from '../../../../common/platform';\r\nimport CometTransport from '../../../../common/lib/transport/comettransport';\r\nimport XHRRequest from '../http/request/xhrrequest';\r\nimport ConnectionManager, { TransportParams } from 'common/lib/transport/connectionmanager';\r\nimport Auth from 'common/lib/client/auth';\r\nimport { RequestBody, RequestParams } from 'common/types/http';\r\nimport { TransportNames } from 'common/constants/TransportName';\r\n\r\nvar shortName = TransportNames.XhrPolling;\r\nclass XHRPollingTransport extends CometTransport {\r\n  shortName = shortName;\r\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams) {\r\n    super(connectionManager, auth, params);\r\n    params.stream = false;\r\n    this.shortName = shortName;\r\n  }\r\n\r\n  static isAvailable() {\r\n    return !!(Platform.Config.xhrSupported && Platform.Config.allowComet);\r\n  }\r\n\r\n  toString() {\r\n    return 'XHRPollingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;\r\n  }\r\n\r\n  createRequest(\r\n    uri: string,\r\n    headers: Record<string, string>,\r\n    params: RequestParams,\r\n    body: RequestBody | null,\r\n    requestMode: number,\r\n  ) {\r\n    return XHRRequest.createRequest(uri, headers, params, body, requestMode, this.timeouts);\r\n  }\r\n}\r\n\r\nexport default XHRPollingTransport;\r\n", "import TransportName from 'common/constants/TransportName';\r\nimport Platform from 'common/platform';\r\nimport XhrPollingTransport from './xhrpollingtransport';\r\nimport WebSocketTransport from '../../../../common/lib/transport/websockettransport';\r\n\r\n// For reasons that I don\u2019t understand, if we use [TransportNames.XhrPolling] for the keys in defaultTransports\u2019s, then defaultTransports does not get tree-shaken. Hence using literals instead. They\u2019re still correctly type-checked.\r\n\r\nconst order: TransportName[] = ['xhr_polling'];\r\n\r\nconst defaultTransports: (typeof Platform)['Transports'] = {\r\n  order,\r\n  bundledImplementations: {\r\n    web_socket: WebSocketTransport,\r\n    xhr_polling: XhrPollingTransport,\r\n  },\r\n};\r\n\r\nexport default defaultTransports;\r\n\r\nexport const ModularTransports: (typeof Platform)['Transports'] = {\r\n  order,\r\n  bundledImplementations: {},\r\n};\r\n", "import IWebStorage from 'common/types/IWebStorage';\r\n\r\nconst test = 'ablyjs-storage-test';\r\n\r\nlet globalObject = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : self;\r\n\r\nclass Webstorage implements IWebStorage {\r\n  sessionSupported: boolean;\r\n  localSupported: boolean;\r\n\r\n  constructor() {\r\n    /* Even just accessing the session/localStorage object can throw a\r\n     * security exception in some circumstances with some browsers. In\r\n     * others, calling setItem will throw. So have to check in this\r\n     * somewhat roundabout way. (If unsupported or no global object,\r\n     * will throw on accessing a property of undefined) */\r\n    try {\r\n      globalObject.sessionStorage.setItem(test, test);\r\n      globalObject.sessionStorage.removeItem(test);\r\n      this.sessionSupported = true;\r\n    } catch (e) {\r\n      this.sessionSupported = false;\r\n    }\r\n\r\n    try {\r\n      globalObject.localStorage.setItem(test, test);\r\n      globalObject.localStorage.removeItem(test);\r\n      this.localSupported = true;\r\n    } catch (e) {\r\n      this.localSupported = false;\r\n    }\r\n  }\r\n\r\n  get(name: string): any {\r\n    return this._get(name, false);\r\n  }\r\n\r\n  getSession(name: string): any {\r\n    return this._get(name, true);\r\n  }\r\n\r\n  remove(name: string): void {\r\n    return this._remove(name, false);\r\n  }\r\n\r\n  removeSession(name: string): void {\r\n    return this._remove(name, true);\r\n  }\r\n\r\n  set(name: string, value: string, ttl?: number): void {\r\n    return this._set(name, value, ttl, false);\r\n  }\r\n\r\n  setSession(name: string, value: string, ttl?: number): void {\r\n    return this._set(name, value, ttl, true);\r\n  }\r\n\r\n  private _set(name: string, value: string, ttl: number | undefined, session: any) {\r\n    const wrappedValue: Record<string, any> = { value: value };\r\n    if (ttl) {\r\n      wrappedValue.expires = Date.now() + ttl;\r\n    }\r\n    return this.storageInterface(session).setItem(name, JSON.stringify(wrappedValue));\r\n  }\r\n\r\n  private _get(name: string, session?: boolean) {\r\n    if (session && !this.sessionSupported) throw new Error('Session Storage not supported');\r\n    if (!session && !this.localSupported) throw new Error('Local Storage not supported');\r\n    const rawItem = this.storageInterface(session).getItem(name);\r\n    if (!rawItem) return null;\r\n    const wrappedValue = JSON.parse(rawItem);\r\n    if (wrappedValue.expires && wrappedValue.expires < Date.now()) {\r\n      this.storageInterface(session).removeItem(name);\r\n      return null;\r\n    }\r\n    return wrappedValue.value;\r\n  }\r\n\r\n  private _remove(name: string, session?: boolean) {\r\n    return this.storageInterface(session).removeItem(name);\r\n  }\r\n\r\n  private storageInterface(session?: boolean) {\r\n    return session ? globalObject.sessionStorage : globalObject.localStorage;\r\n  }\r\n}\r\n\r\nexport default new Webstorage();\r\n", "import IDefaults from 'common/types/IDefaults';\r\nimport { TransportNames } from 'common/constants/TransportName';\r\n\r\nconst Defaults: IDefaults = {\r\n  connectivityCheckUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up.txt',\r\n  wsConnectivityUrl: 'wss://ws-up.ably-realtime.com',\r\n  /* Order matters here: the base transport is the leftmost one in the\r\n   * intersection of baseTransportOrder and the transports clientOption that's\r\n   * supported. */\r\n  defaultTransports: [TransportNames.XhrPolling, TransportNames.WebSocket],\r\n};\r\n\r\nexport default Defaults;\r\n", "function inspect(buffer: undefined | ArrayBuffer | DataView) {\n  if (buffer === undefined) return 'undefined';\n  let view;\n  let type;\n  if (buffer instanceof ArrayBuffer) {\n    type = 'ArrayBuffer';\n    view = new DataView(buffer);\n  } else if (buffer instanceof DataView) {\n    type = 'DataView';\n    view = buffer;\n  }\n  if (!view) return JSON.stringify(buffer);\n  const bytes = [];\n  for (let i = 0; i < buffer.byteLength; i++) {\n    if (i > 20) {\n      bytes.push('...');\n      break;\n    }\n    let byte_ = view.getUint8(i).toString(16);\n    if (byte_.length === 1) byte_ = '0' + byte_;\n    bytes.push(byte_);\n  }\n  return '<' + type + ' ' + bytes.join(' ') + '>';\n}\n\n// Encode string as utf8 into dataview at offset\nfunction utf8Write(view: DataView, offset: number, string: string) {\n  for (let i = 0, l = string.length; i < l; i++) {\n    const codePoint = string.charCodeAt(i);\n\n    // One byte of UTF-8\n    if (codePoint < 0x80) {\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x7f) | 0x00);\n      continue;\n    }\n\n    // Two bytes of UTF-8\n    if (codePoint < 0x800) {\n      view.setUint8(offset++, ((codePoint >>> 6) & 0x1f) | 0xc0);\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);\n      continue;\n    }\n\n    // Three bytes of UTF-8.\n    if (codePoint < 0x10000) {\n      view.setUint8(offset++, ((codePoint >>> 12) & 0x0f) | 0xe0);\n      view.setUint8(offset++, ((codePoint >>> 6) & 0x3f) | 0x80);\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);\n      continue;\n    }\n\n    // Four bytes of UTF-8\n    if (codePoint < 0x110000) {\n      view.setUint8(offset++, ((codePoint >>> 18) & 0x07) | 0xf0);\n      view.setUint8(offset++, ((codePoint >>> 12) & 0x3f) | 0x80);\n      view.setUint8(offset++, ((codePoint >>> 6) & 0x3f) | 0x80);\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);\n      continue;\n    }\n    throw new Error('bad codepoint ' + codePoint);\n  }\n}\n\nfunction utf8Read(view: DataView, offset: number, length: number) {\n  let string = '';\n  for (let i = offset, end = offset + length; i < end; i++) {\n    const byte_ = view.getUint8(i);\n    // One byte character\n    if ((byte_ & 0x80) === 0x00) {\n      string += String.fromCharCode(byte_);\n      continue;\n    }\n    // Two byte character\n    if ((byte_ & 0xe0) === 0xc0) {\n      string += String.fromCharCode(((byte_ & 0x0f) << 6) | (view.getUint8(++i) & 0x3f));\n      continue;\n    }\n    // Three byte character\n    if ((byte_ & 0xf0) === 0xe0) {\n      string += String.fromCharCode(\n        ((byte_ & 0x0f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0),\n      );\n      continue;\n    }\n    // Four byte character\n    if ((byte_ & 0xf8) === 0xf0) {\n      string += String.fromCharCode(\n        ((byte_ & 0x07) << 18) |\n          ((view.getUint8(++i) & 0x3f) << 12) |\n          ((view.getUint8(++i) & 0x3f) << 6) |\n          ((view.getUint8(++i) & 0x3f) << 0),\n      );\n      continue;\n    }\n    throw new Error('Invalid byte ' + byte_.toString(16));\n  }\n  return string;\n}\n\nfunction utf8ByteCount(string: string) {\n  let count = 0;\n  for (let i = 0, l = string.length; i < l; i++) {\n    const codePoint = string.charCodeAt(i);\n    if (codePoint < 0x80) {\n      count += 1;\n      continue;\n    }\n    if (codePoint < 0x800) {\n      count += 2;\n      continue;\n    }\n    if (codePoint < 0x10000) {\n      count += 3;\n      continue;\n    }\n    if (codePoint < 0x110000) {\n      count += 4;\n      continue;\n    }\n    throw new Error('bad codepoint ' + codePoint);\n  }\n  return count;\n}\n\nfunction encode(value: unknown, sparse?: boolean) {\n  const size = sizeof(value, sparse);\n  if (size === 0) return undefined;\n  const buffer = new ArrayBuffer(size);\n  const view = new DataView(buffer);\n  _encode(value, view, 0, sparse);\n  return buffer;\n}\n\nconst SH_L_32 = (1 << 16) * (1 << 16),\n  SH_R_32 = 1 / SH_L_32;\nfunction getInt64(view: DataView, offset: number) {\n  offset = offset || 0;\n  return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);\n}\n\nfunction getUint64(view: DataView, offset: number) {\n  offset = offset || 0;\n  return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);\n}\n\nfunction setInt64(view: DataView, offset: number, val: number) {\n  if (val < 0x8000000000000000) {\n    view.setInt32(offset, Math.floor(val * SH_R_32));\n    view.setInt32(offset + 4, val & -1);\n  } else {\n    view.setUint32(offset, 0x7fffffff);\n    view.setUint32(offset + 4, 0x7fffffff);\n  }\n}\n\nfunction setUint64(view: DataView, offset: number, val: number) {\n  if (val < 0x10000000000000000) {\n    view.setUint32(offset, Math.floor(val * SH_R_32));\n    view.setInt32(offset + 4, val & -1);\n  } else {\n    view.setUint32(offset, 0xffffffff);\n    view.setUint32(offset + 4, 0xffffffff);\n  }\n}\n\n// https://gist.github.com/frsyuki/5432559 - v5 spec\n//\n// I've used one extension point from `fixext 1` to store `undefined`. On the wire this\n// should translate to exactly 0xd40000\n//\n// +--------+--------+--------+\n// |  0xd4  |  0x00  |  0x00  |\n// +--------+--------+--------+\n//    ^ fixext |        ^ value part unused (fixed to be 0)\n//             ^ indicates undefined value\n//\n\nclass Decoder {\n  offset: number;\n  view: DataView;\n\n  constructor(view: DataView, offset?: number) {\n    this.offset = offset || 0;\n    this.view = view;\n  }\n\n  map = (length: number) => {\n    const value: { [key: string]: ArrayBuffer } = {};\n    for (let i = 0; i < length; i++) {\n      const key = this.parse();\n      value[key as string] = this.parse() as ArrayBuffer;\n    }\n    return value;\n  };\n\n  bin = (length: number) => {\n    const value = new ArrayBuffer(length);\n    new Uint8Array(value).set(new Uint8Array(this.view.buffer, this.offset, length), 0);\n    this.offset += length;\n    return value;\n  };\n\n  buf = this.bin;\n\n  str = (length: number) => {\n    const value = utf8Read(this.view, this.offset, length);\n    this.offset += length;\n    return value;\n  };\n\n  array = (length: number) => {\n    const value = new Array(length);\n    for (let i = 0; i < length; i++) {\n      value[i] = this.parse();\n    }\n    return value;\n  };\n\n  ext = (length: number) => {\n    this.offset += length;\n    return {\n      type: this.view.getInt8(this.offset),\n      data: this.buf(length),\n    };\n  };\n\n  parse = (): unknown => {\n    const type = this.view.getUint8(this.offset);\n    let value, length;\n\n    // Positive FixInt - 0xxxxxxx\n    if ((type & 0x80) === 0x00) {\n      this.offset++;\n      return type;\n    }\n\n    // FixMap - 1000xxxx\n    if ((type & 0xf0) === 0x80) {\n      length = type & 0x0f;\n      this.offset++;\n      return this.map(length);\n    }\n\n    // FixArray - 1001xxxx\n    if ((type & 0xf0) === 0x90) {\n      length = type & 0x0f;\n      this.offset++;\n      return this.array(length);\n    }\n\n    // FixStr - 101xxxxx\n    if ((type & 0xe0) === 0xa0) {\n      length = type & 0x1f;\n      this.offset++;\n      return this.str(length);\n    }\n\n    // Negative FixInt - 111xxxxx\n    if ((type & 0xe0) === 0xe0) {\n      value = this.view.getInt8(this.offset);\n      this.offset++;\n      return value;\n    }\n\n    switch (type) {\n      // nil\n      case 0xc0:\n        this.offset++;\n        return null;\n\n      // 0xc1 never used - use for undefined (NON-STANDARD)\n      case 0xc1:\n        this.offset++;\n        return undefined;\n\n      // false\n      case 0xc2:\n        this.offset++;\n        return false;\n\n      // true\n      case 0xc3:\n        this.offset++;\n        return true;\n\n      // bin 8\n      case 0xc4:\n        length = this.view.getUint8(this.offset + 1);\n        this.offset += 2;\n        return this.bin(length);\n\n      // bin 16\n      case 0xc5:\n        length = this.view.getUint16(this.offset + 1);\n        this.offset += 3;\n        return this.bin(length);\n\n      // bin 32\n      case 0xc6:\n        length = this.view.getUint32(this.offset + 1);\n        this.offset += 5;\n        return this.bin(length);\n\n      // ext 8\n      case 0xc7:\n        length = this.view.getUint8(this.offset + 1);\n        this.offset += 2;\n        return this.ext(length);\n\n      // ext 16\n      case 0xc8:\n        length = this.view.getUint16(this.offset + 1);\n        this.offset += 3;\n        return this.ext(length);\n\n      // ext 32\n      case 0xc9:\n        length = this.view.getUint32(this.offset + 1);\n        this.offset += 5;\n        return this.ext(length);\n\n      // float 32\n      case 0xca:\n        value = this.view.getFloat32(this.offset + 1);\n        this.offset += 5;\n        return value;\n\n      // float 64\n      case 0xcb:\n        value = this.view.getFloat64(this.offset + 1);\n        this.offset += 9;\n        return value;\n\n      // uint8\n      case 0xcc:\n        value = this.view.getUint8(this.offset + 1);\n        this.offset += 2;\n        return value;\n\n      // uint 16\n      case 0xcd:\n        value = this.view.getUint16(this.offset + 1);\n        this.offset += 3;\n        return value;\n\n      // uint 32\n      case 0xce:\n        value = this.view.getUint32(this.offset + 1);\n        this.offset += 5;\n        return value;\n\n      // uint 64\n      case 0xcf:\n        value = getUint64(this.view, this.offset + 1);\n        this.offset += 9;\n        return value;\n\n      // int 8\n      case 0xd0:\n        value = this.view.getInt8(this.offset + 1);\n        this.offset += 2;\n        return value;\n\n      // int 16\n      case 0xd1:\n        value = this.view.getInt16(this.offset + 1);\n        this.offset += 3;\n        return value;\n\n      // int 32\n      case 0xd2:\n        value = this.view.getInt32(this.offset + 1);\n        this.offset += 5;\n        return value;\n\n      // int 64\n      case 0xd3:\n        value = getInt64(this.view, this.offset + 1);\n        this.offset += 9;\n        return value;\n\n      // fixext 1\n      case 0xd4:\n        length = 1;\n        this.offset++;\n        return this.ext(length);\n\n      // fixext 2\n      case 0xd5:\n        length = 2;\n        this.offset++;\n        return this.ext(length);\n\n      // fixext 4\n      case 0xd6:\n        length = 4;\n        this.offset++;\n        return this.ext(length);\n\n      // fixext 8\n      case 0xd7:\n        length = 8;\n        this.offset++;\n        return this.ext(length);\n\n      // fixext 16\n      case 0xd8:\n        length = 16;\n        this.offset++;\n        return this.ext(length);\n\n      // str8\n      case 0xd9:\n        length = this.view.getUint8(this.offset + 1);\n        this.offset += 2;\n        return this.str(length);\n\n      // str 16\n      case 0xda:\n        length = this.view.getUint16(this.offset + 1);\n        this.offset += 3;\n        return this.str(length);\n\n      // str 32\n      case 0xdb:\n        length = this.view.getUint32(this.offset + 1);\n        this.offset += 5;\n        return this.str(length);\n\n      // array 16\n      case 0xdc:\n        length = this.view.getUint16(this.offset + 1);\n        this.offset += 3;\n        return this.array(length);\n\n      // array 32\n      case 0xdd:\n        length = this.view.getUint32(this.offset + 1);\n        this.offset += 5;\n        return this.array(length);\n\n      // map 16\n      case 0xde:\n        length = this.view.getUint16(this.offset + 1);\n        this.offset += 3;\n        return this.map(length);\n\n      // map 32\n      case 0xdf:\n        length = this.view.getUint32(this.offset + 1);\n        this.offset += 5;\n        return this.map(length);\n    }\n    throw new Error('Unknown type 0x' + type.toString(16));\n  };\n}\n\nfunction decode(buffer: ArrayBuffer) {\n  const view = new DataView(buffer);\n  const decoder = new Decoder(view);\n  const value = decoder.parse();\n  if (decoder.offset !== buffer.byteLength) throw new Error(buffer.byteLength - decoder.offset + ' trailing bytes');\n  return value;\n}\n\nfunction encodeableKeys(value: { [key: string]: unknown }, sparse?: boolean) {\n  return Object.keys(value).filter(function (e) {\n    const val = value[e],\n      type = typeof val;\n    return (!sparse || (val !== undefined && val !== null)) && ('function' !== type || !!(val as Date).toJSON);\n  });\n}\n\nfunction _encode(value: unknown, view: DataView, offset: number, sparse?: boolean): number {\n  const type = typeof value;\n\n  // Strings Bytes\n  // There are four string types: fixstr/str8/str16/str32\n  if (typeof value === 'string') {\n    const length = utf8ByteCount(value);\n\n    // fixstr\n    if (length < 0x20) {\n      view.setUint8(offset, length | 0xa0);\n      utf8Write(view, offset + 1, value);\n      return 1 + length;\n    }\n\n    // str8\n    if (length < 0x100) {\n      view.setUint8(offset, 0xd9);\n      view.setUint8(offset + 1, length);\n      utf8Write(view, offset + 2, value);\n      return 2 + length;\n    }\n\n    // str16\n    if (length < 0x10000) {\n      view.setUint8(offset, 0xda);\n      view.setUint16(offset + 1, length);\n      utf8Write(view, offset + 3, value);\n      return 3 + length;\n    }\n    // str32\n    if (length < 0x100000000) {\n      view.setUint8(offset, 0xdb);\n      view.setUint32(offset + 1, length);\n      utf8Write(view, offset + 5, value);\n      return 5 + length;\n    }\n  }\n\n  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\n    // extract the arraybuffer and fallthrough\n    value = value.buffer;\n  }\n\n  // There are three bin types: bin8/bin16/bin32\n  if (value instanceof ArrayBuffer) {\n    const length = value.byteLength;\n\n    // bin8\n    if (length < 0x100) {\n      view.setUint8(offset, 0xc4);\n      view.setUint8(offset + 1, length);\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 2);\n      return 2 + length;\n    }\n\n    // bin16\n    if (length < 0x10000) {\n      view.setUint8(offset, 0xc5);\n      view.setUint16(offset + 1, length);\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 3);\n      return 3 + length;\n    }\n\n    // bin 32\n    if (length < 0x100000000) {\n      view.setUint8(offset, 0xc6);\n      view.setUint32(offset + 1, length);\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 5);\n      return 5 + length;\n    }\n  }\n\n  if (typeof value === 'number') {\n    // Floating Point\n    // NOTE: We're always using float64\n    if (Math.floor(value) !== value) {\n      view.setUint8(offset, 0xcb);\n      view.setFloat64(offset + 1, value);\n      return 9;\n    }\n\n    // Integers\n    if (value >= 0) {\n      // positive fixnum\n      if (value < 0x80) {\n        view.setUint8(offset, value);\n        return 1;\n      }\n      // uint 8\n      if (value < 0x100) {\n        view.setUint8(offset, 0xcc);\n        view.setUint8(offset + 1, value);\n        return 2;\n      }\n      // uint 16\n      if (value < 0x10000) {\n        view.setUint8(offset, 0xcd);\n        view.setUint16(offset + 1, value);\n        return 3;\n      }\n      // uint 32\n      if (value < 0x100000000) {\n        view.setUint8(offset, 0xce);\n        view.setUint32(offset + 1, value);\n        return 5;\n      }\n      // uint 64\n      if (value < 0x10000000000000000) {\n        view.setUint8(offset, 0xcf);\n        setUint64(view, offset + 1, value);\n        return 9;\n      }\n      throw new Error('Number too big 0x' + value.toString(16));\n    }\n\n    // negative fixnum\n    if (value >= -0x20) {\n      view.setInt8(offset, value);\n      return 1;\n    }\n    // int 8\n    if (value >= -0x80) {\n      view.setUint8(offset, 0xd0);\n      view.setInt8(offset + 1, value);\n      return 2;\n    }\n    // int 16\n    if (value >= -0x8000) {\n      view.setUint8(offset, 0xd1);\n      view.setInt16(offset + 1, value);\n      return 3;\n    }\n    // int 32\n    if (value >= -0x80000000) {\n      view.setUint8(offset, 0xd2);\n      view.setInt32(offset + 1, value);\n      return 5;\n    }\n    // int 64\n    if (value >= -0x8000000000000000) {\n      view.setUint8(offset, 0xd3);\n      setInt64(view, offset + 1, value);\n      return 9;\n    }\n    throw new Error('Number too small -0x' + (-value).toString(16).substr(1));\n  }\n\n  // undefined - use d4 (NON-STANDARD)\n  if (type === 'undefined') {\n    if (sparse) return 0;\n    view.setUint8(offset, 0xd4);\n    view.setUint8(offset + 1, 0x00);\n    view.setUint8(offset + 2, 0x00);\n    return 3;\n  }\n\n  // null\n  if (value === null) {\n    if (sparse) return 0;\n    view.setUint8(offset, 0xc0);\n    return 1;\n  }\n\n  // Boolean\n  if (type === 'boolean') {\n    view.setUint8(offset, value ? 0xc3 : 0xc2);\n    return 1;\n  }\n\n  if ('function' === typeof (value as Date).toJSON) return _encode((value as Date).toJSON(), view, offset, sparse);\n\n  // Container Types\n  if (type === 'object') {\n    let length: number,\n      size = 0;\n    let keys: string[] | undefined;\n    const isArray = Array.isArray(value);\n\n    if (isArray) {\n      length = (value as unknown[]).length;\n    } else {\n      keys = encodeableKeys(value as { [key: string]: unknown }, sparse);\n      length = keys.length;\n    }\n\n    if (length < 0x10) {\n      view.setUint8(offset, length | (isArray ? 0x90 : 0x80));\n      size = 1;\n    } else if (length < 0x10000) {\n      view.setUint8(offset, isArray ? 0xdc : 0xde);\n      view.setUint16(offset + 1, length);\n      size = 3;\n    } else if (length < 0x100000000) {\n      view.setUint8(offset, isArray ? 0xdd : 0xdf);\n      view.setUint32(offset + 1, length);\n      size = 5;\n    }\n\n    if (isArray) {\n      for (let i = 0; i < length; i++) {\n        size += _encode((value as unknown[])[i], view, offset + size, sparse);\n      }\n    } else if (keys) {\n      for (let i = 0; i < length; i++) {\n        const key = keys[i];\n        size += _encode(key, view, offset + size);\n        size += _encode((value as { [key: string]: unknown })[key], view, offset + size, sparse);\n      }\n    }\n\n    return size;\n  }\n  if (type === 'function') return 0;\n\n  throw new Error('Unknown type ' + type);\n}\n\nfunction sizeof(value: unknown, sparse?: boolean): number {\n  const type = typeof value;\n\n  // fixstr or str8 or str16 or str32\n  if (type === 'string') {\n    const length = utf8ByteCount(value as string);\n    if (length < 0x20) {\n      return 1 + length;\n    }\n    if (length < 0x100) {\n      return 2 + length;\n    }\n    if (length < 0x10000) {\n      return 3 + length;\n    }\n    if (length < 0x100000000) {\n      return 5 + length;\n    }\n  }\n\n  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\n    // extract the arraybuffer and fallthrough\n    value = value.buffer;\n  }\n\n  // bin8 or bin16 or bin32\n  if (value instanceof ArrayBuffer) {\n    const length = value.byteLength;\n    if (length < 0x100) {\n      return 2 + length;\n    }\n    if (length < 0x10000) {\n      return 3 + length;\n    }\n    if (length < 0x100000000) {\n      return 5 + length;\n    }\n  }\n\n  if (typeof value === 'number') {\n    // Floating Point (32 bits)\n    // double\n    if (Math.floor(value) !== value) return 9;\n\n    // Integers\n    if (value >= 0) {\n      // positive fixint\n      if (value < 0x80) return 1;\n      // uint 8\n      if (value < 0x100) return 2;\n      // uint 16\n      if (value < 0x10000) return 3;\n      // uint 32\n      if (value < 0x100000000) return 5;\n      // uint 64\n      if (value < 0x10000000000000000) return 9;\n      // Too big\n      throw new Error('Number too big 0x' + value.toString(16));\n    }\n    // negative fixint\n    if (value >= -0x20) return 1;\n    // int 8\n    if (value >= -0x80) return 2;\n    // int 16\n    if (value >= -0x8000) return 3;\n    // int 32\n    if (value >= -0x80000000) return 5;\n    // int 64\n    if (value >= -0x8000000000000000) return 9;\n    // Too small\n    throw new Error('Number too small -0x' + value.toString(16).substr(1));\n  }\n\n  // Boolean\n  if (type === 'boolean') return 1;\n\n  // undefined, null\n  if (value === null) return sparse ? 0 : 1;\n  if (value === undefined) return sparse ? 0 : 3;\n\n  if ('function' === typeof (value as Date).toJSON) return sizeof((value as Date).toJSON(), sparse);\n\n  // Container Types\n  if (type === 'object') {\n    let length: number,\n      size = 0;\n    if (Array.isArray(value)) {\n      length = value.length;\n      for (let i = 0; i < length; i++) {\n        size += sizeof(value[i], sparse);\n      }\n    } else {\n      const keys = encodeableKeys(value as { [key: string]: unknown }, sparse);\n      length = keys.length;\n      for (let i = 0; i < length; i++) {\n        const key = keys[i];\n        size += sizeof(key) + sizeof((value as { [key: string]: unknown })[key], sparse);\n      }\n    }\n    if (length < 0x10) {\n      return 1 + size;\n    }\n    if (length < 0x10000) {\n      return 3 + size;\n    }\n    if (length < 0x100000000) {\n      return 5 + size;\n    }\n    throw new Error('Array or object too long 0x' + length.toString(16));\n  }\n  if (type === 'function') return 0;\n\n  throw new Error('Unknown type ' + type);\n}\n\nexport default {\n  encode,\n  decode,\n  inspect,\n  utf8Write,\n  utf8Read,\n  utf8ByteCount,\n};\n", "import HttpMethods from 'common/constants/HttpMethods';\nimport BaseClient from 'common/lib/client/baseclient';\nimport ErrorInfo, { PartialErrorInfo } from 'common/lib/types/errorinfo';\nimport { RequestBody, RequestResultError, ResponseHeaders, RequestParams, RequestResult } from 'common/types/http';\nimport Platform from 'common/platform';\nimport Defaults from 'common/lib/util/defaults';\nimport * as Utils from 'common/lib/util/utils';\n\nfunction isAblyError(responseBody: unknown, headers: Headers): responseBody is { error?: ErrorInfo } {\n  return !!headers.get('x-ably-errorcode');\n}\n\nfunction getAblyError(responseBody: unknown, headers: Headers) {\n  if (isAblyError(responseBody, headers)) {\n    return responseBody.error && ErrorInfo.fromValues(responseBody.error);\n  }\n}\n\nfunction convertHeaders(headers: Headers) {\n  const result: ResponseHeaders = {};\n\n  headers.forEach((value, key) => {\n    result[key] = value;\n  });\n\n  return result;\n}\n\nexport default async function fetchRequest(\n  method: HttpMethods,\n  client: BaseClient | null,\n  uri: string,\n  headers: Record<string, string> | null,\n  params: RequestParams,\n  body: RequestBody | null,\n): Promise<RequestResult> {\n  const fetchHeaders = new Headers(headers || {});\n  const _method = method ? method.toUpperCase() : Utils.isNil(body) ? 'GET' : 'POST';\n\n  const controller = new AbortController();\n\n  let timeout: ReturnType<typeof setTimeout>; // This way we don\u2019t have to worry about the fact that the TypeScript compiler is \u2014 for reasons I haven\u2019t looked into \u2014 picking up the signature of the Node version of setTimeout, which has a different return type to the web one\n  const timeoutPromise: Promise<RequestResult> = new Promise((resolve) => {\n    timeout = setTimeout(\n      () => {\n        controller.abort();\n        // When AbortController.abort() is called, the fetch() promise rejects with a DOMException named AbortError (source: https://developer.mozilla.org/en-US/docs/Web/API/AbortController)\n        // However, we beat it in the Promise.race() by resolving our custom 'Request timed out' error on the next line, thereby exposing users to the better-formatted error.\n        resolve({ error: new PartialErrorInfo('Request timed out', null, 408) });\n      },\n      client ? client.options.timeouts.httpRequestTimeout : Defaults.TIMEOUTS.httpRequestTimeout,\n    );\n  });\n\n  const requestInit: RequestInit = {\n    method: _method,\n    headers: fetchHeaders,\n    body: body as any,\n    signal: controller.signal,\n  };\n\n  if (!Platform.Config.isWebworker) {\n    requestInit.credentials = fetchHeaders.has('authorization') ? 'include' : 'same-origin';\n  }\n\n  const resultPromise = (async (): Promise<RequestResult> => {\n    try {\n      const res = await Utils.getGlobalObject().fetch(uri + '?' + new URLSearchParams(params || {}), requestInit);\n\n      clearTimeout(timeout!);\n\n      const contentType = res.headers.get('Content-Type');\n      let body;\n      if (contentType && contentType.indexOf('application/x-msgpack') > -1) {\n        body = await res.arrayBuffer();\n      } else if (contentType && contentType.indexOf('application/json') > -1) {\n        body = await res.json();\n      } else {\n        body = await res.text();\n      }\n\n      const unpacked = !!contentType && contentType.indexOf('application/x-msgpack') === -1;\n      const headers = convertHeaders(res.headers);\n\n      if (!res.ok) {\n        const error =\n          getAblyError(body, res.headers) ||\n          new PartialErrorInfo(\n            'Error response received from server: ' + res.status + ' body was: ' + Platform.Config.inspect(body),\n            null,\n            res.status,\n          );\n\n        return { error, body, headers, unpacked, statusCode: res.status };\n      } else {\n        return { error: null, body, headers, unpacked, statusCode: res.status };\n      }\n    } catch (error) {\n      clearTimeout(timeout!);\n      return { error: error as RequestResultError };\n    }\n  })();\n\n  return Promise.race([timeoutPromise, resultPromise]);\n}\n", "import { HTTPRequestImplementations } from '../http';\r\nimport XHRRequest from './xhrrequest';\r\nimport fetchRequest from './fetchrequest';\r\n\r\nexport const defaultBundledRequestImplementations: HTTPRequestImplementations = {\r\n  XHRRequest: XHRRequest,\r\n  FetchRequest: fetchRequest,\r\n};\r\n\r\nexport const modularBundledRequestImplementations: HTTPRequestImplementations = {};\r\n"],
  "mappings": "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",
  "names": ["module", "_a", "_Logger", "Format", "n", "agent", "Crypto", "HttpMethods", "HttpStatusCodes", "tokenDetails", "err", "version", "logResult", "headers", "params", "self", "_PushChannelSubscription", "fromEncoded", "fromValues", "decode", "fromEncodedArray", "fromResponseBody", "fromValuesArray", "_DefaultRest", "actions", "serialize", "TransportNames", "globalObject", "connectionDetails", "noop", "Channels", "listeners", "_DefaultRealtime", "hmac", "uint8Array", "XHRStates", "Http", "body", "statusCode", "shortName", "transport_default", "Defaults", "defaults_default", "encode", "isAblyError", "getAblyError"]
}
